
My_First_NiosII.elf:     file format elf32-littlenios2
My_First_NiosII.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x040401b4

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x04040020 paddr 0x04040020 align 2**12
         filesz 0x00007f14 memsz 0x00007f14 flags r-x
    LOAD off    0x00008f34 vaddr 0x04047f34 paddr 0x04049a5c align 2**12
         filesz 0x00001b28 memsz 0x00001b28 flags rw-
    LOAD off    0x0000b584 vaddr 0x0404b584 paddr 0x0404b584 align 2**12
         filesz 0x00000000 memsz 0x000002e0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00000000  00000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000194  04040020  04040020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00007d28  040401b4  040401b4  000011b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000058  04047edc  04047edc  00008edc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001b28  04047f34  04049a5c  00008f34  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000002e0  0404b584  0404b584  0000b584  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  0000aa5c  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000009f8  00000000  00000000  0000aa80  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000011d1  00000000  00000000  0000b478  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0001cce9  00000000  00000000  0000c649  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00005742  00000000  00000000  00029332  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000e63a  00000000  00000000  0002ea74  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  000014e8  00000000  00000000  0003d0b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001943  00000000  00000000  0003e598  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000045e7  00000000  00000000  0003fedb  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000060  00000000  00000000  000444c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000002f8  00000000  00000000  00044528  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  000474c6  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000a  00000000  00000000  000474c9  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000474d3  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000474d4  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  000474d5  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  000474d9  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  000474dd  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000009  00000000  00000000  000474e1  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000009  00000000  00000000  000474ea  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000009  00000000  00000000  000474f3  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000d  00000000  00000000  000474fc  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000012  00000000  00000000  00047509  2**0
                  CONTENTS, READONLY
 29 .jdi          00004ffd  00000000  00000000  0004751b  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     0003d87f  00000000  00000000  0004c518  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    d  .entry	00000000 .entry
04040020 l    d  .exceptions	00000000 .exceptions
040401b4 l    d  .text	00000000 .text
04047edc l    d  .rodata	00000000 .rodata
04047f34 l    d  .rwdata	00000000 .rwdata
0404b584 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
040401fc l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 impure.c
04047f34 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
04041ba0 l     F .text	00000058 std
04041cac l     F .text	00000008 __fp_lock
04041cb4 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 alt_close.c
04042c74 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
04042cd4 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
04042dd4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
04042ef4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
04042fd4 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
04043130 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
0404335c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
04049a44 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
040435f8 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
040488e4 l     O .rwdata	000000d8 cfi_flash
040489bc l     O .rwdata	00001060 jtag_uart
040436dc l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
040437b0 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
040445a0 l     F .text	0000007c alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0404562c l     F .text	00000228 altera_avalon_jtag_uart_irq
04045854 l     F .text	000000b0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
04046194 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
04046688 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
040467c4 l     F .text	000000dc alt_file_locked
04046a28 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
04046ff0 l     F .text	000000bc alt_write_word_amd
04046ecc l     F .text	00000124 alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
040472a4 l     F .text	0000018c alt_unlock_block_intel
04047430 l     F .text	000000dc alt_write_word_intel
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
04047b78 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 lib2-divmod.c
04047d2c l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 alt_exit.c
04047e78 l     F .text	00000040 alt_sim_halt
04042a18 g     F .text	00000070 _isatty_r
04043190 g     F .text	0000006c alt_main
04040268 g     F .text	000000a0 _puts_r
04044060 g     F .text	00000048 alt_read_query_entry_32bit
0404b5d4 g     O .bss	00000100 alt_irq
04042a88 g     F .text	00000078 _lseek_r
040437e8 g     F .text	000002c0 alt_flash_cfi_write
04049a5c g       *ABS*	00000000 __flash_rwdata_start
0404b864 g       *ABS*	00000000 __alt_heap_start
04042654 g     F .text	00000068 __sseek
04041c08 g     F .text	000000a4 __sinit
04041d08 g     F .text	00000068 __sfmoreglue
0404321c g     F .text	00000020 __malloc_unlock
040410f0 g     F .text	000000e0 memmove
04041cf8 g     F .text	00000010 _cleanup
00000000  w      *UND*	00000000 __errno
040441ec g     F .text	00000048 alt_write_flash_command_32bit_device_16bit_mode
00000000 g     F .entry	0000001c __reset
04040020 g       *ABS*	00000000 __flash_exceptions_start
040429a4 g     F .text	00000074 _fstat_r
04043d04 g     F .text	000002d8 alt_flash_program_block
0404b590 g     O .bss	00000004 errno
0404b598 g     O .bss	00000004 alt_argv
04051a1c g       *ABS*	00000000 _gp
04047808 g     F .text	00000030 usleep
04048764 g     O .rwdata	00000180 alt_fd_list
0404750c g     F .text	00000094 alt_find_dev
04041050 g     F .text	000000a0 memcpy
04041cec g     F .text	0000000c _cleanup_r
0404674c g     F .text	00000078 alt_io_redirect
04047edc g       *ABS*	00000000 __DTOR_END__
04040308 g     F .text	00000014 puts
04045a6c g     F .text	00000224 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
04047e68 g     F .text	00000008 __udivsi3
04042e34 g     F .text	000000c0 isatty
04047778 g     F .text	00000090 alt_icache_flush
0404b584 g     O .bss	00000004 __malloc_top_pad
04040390 g     F .text	0000049c __sfvwrite_r
040417c4 g     F .text	00000070 _sbrk_r
040470ac g     F .text	00000084 alt_program_intel
04042b00 g     F .text	00000078 _read_r
04046024 g     F .text	00000078 alt_dcache_flush
04049a3c g     O .rwdata	00000004 alt_max_fd
04043fdc g     F .text	00000040 alt_read_query_entry_8bit
04042880 g     F .text	00000110 _fclose_r
04047130 g     F .text	00000174 alt_erase_block_intel
04041b6c g     F .text	00000034 fflush
0404b588 g     O .bss	00000004 __malloc_max_sbrked_mem
04043040 g     F .text	000000f0 lseek
04049a20 g     O .rwdata	00000004 _global_impure_ptr
040411d0 g     F .text	000005f4 _realloc_r
0404b864 g       *ABS*	00000000 __bss_end
04046590 g     F .text	000000f8 alt_iic_isr_register
04046b20 g     F .text	0000010c alt_tick
04041cd4 g     F .text	00000018 __fp_lock_all
04046548 g     F .text	00000048 alt_ic_irq_enabled
04046a88 g     F .text	00000098 alt_alarm_stop
0404b5a0 g     O .bss	00000004 alt_irq_active
040400ec g     F .exceptions	000000c8 alt_irq_handler
0404873c g     O .rwdata	00000028 alt_dev_null
040444f4 g     F .text	000000ac alt_set_flash_algorithm_func
0404609c g     F .text	00000044 alt_dcache_flush_all
040440a8 g     F .text	0000003c alt_write_flash_command_8bit_device_8bit_mode
04049a5c g       *ABS*	00000000 __ram_rwdata_end
04049a34 g     O .rwdata	00000008 alt_dev_list
040434d8 g     F .text	00000120 write
04047f34 g       *ABS*	00000000 __ram_rodata_end
04042d00 g     F .text	000000d4 fstat
04045348 g     F .text	000000dc alt_check_primary_table
04047e70 g     F .text	00000008 __umodsi3
04043b38 g     F .text	00000068 alt_flash_cfi_read
0404427c g     F .text	00000034 alt_write_native_8bit
0404b864 g       *ABS*	00000000 end
040440e4 g     F .text	0000007c alt_write_flash_command_16bit_device_8bit_mode
0404461c g     F .text	00000580 alt_read_cfi_table
0404556c g     F .text	000000c0 altera_avalon_jtag_uart_init
04047ed8 g       *ABS*	00000000 __CTOR_LIST__
04072000 g       *ABS*	00000000 __alt_stack_pointer
04045c90 g     F .text	00000240 altera_avalon_jtag_uart_write
04043714 g     F .text	0000009c alt_flash_cfi_init
04041bf8 g     F .text	00000004 __sfp_lock_acquire
04040f6c g     F .text	000000e4 memchr
04041f8c g     F .text	00000314 _free_r
04047b7c g     F .text	000001b0 __call_exitprocs
04049a28 g     O .rwdata	00000004 __malloc_sbrk_base
040401b4 g     F .text	0000004c _start
0404b5a4 g     O .bss	00000004 _alt_tick_rate
0404b5a8 g     O .bss	00000004 _alt_nticks
0404323c g     F .text	00000120 read
0404368c g     F .text	00000050 alt_sys_init
04047a44 g     F .text	00000134 __register_exitproc
0404401c g     F .text	00000044 alt_read_query_entry_16bit
04045904 g     F .text	00000074 altera_avalon_jtag_uart_close
04047f34 g       *ABS*	00000000 __ram_rwdata_start
04047edc g       *ABS*	00000000 __ram_rodata_start
0404b5ac g     O .bss	00000028 __malloc_current_mallinfo
04044314 g     F .text	000001e0 alt_set_flash_width_func
04045424 g     F .text	00000058 altera_avalon_jtag_uart_read_fd
040476c0 g     F .text	000000b8 alt_get_fd
04047838 g     F .text	0000014c alt_busy_sleep
04042810 g     F .text	00000070 _close_r
04046cb4 g     F .text	00000218 alt_erase_block_amd
040479d0 g     F .text	00000074 memcmp
040454d4 g     F .text	00000048 altera_avalon_jtag_uart_close_fd
0404b864 g       *ABS*	00000000 __alt_stack_base
0404551c g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
04041834 g     F .text	0000013c __swsetup_r
04044b9c g     F .text	000007ac alt_read_cfi_width
04041d70 g     F .text	000000f0 __sfp
04048334 g     O .rwdata	00000408 __malloc_av_
04041c04 g     F .text	00000004 __sinit_lock_release
04042738 g     F .text	00000060 __sread
040475a0 g     F .text	00000120 alt_find_file
040460e0 g     F .text	000000b4 alt_dev_llist_insert
040431fc g     F .text	00000020 __malloc_lock
0404341c g     F .text	000000bc sbrk
04041970 g     F .text	000001fc _fflush_r
04049a48 g     O .rwdata	00000008 alt_flash_dev_list
040441a8 g     F .text	00000044 alt_write_flash_command_16bit_device_16bit_mode
0404b584 g       *ABS*	00000000 __bss_start
040425b4 g     F .text	00000098 memset
04040200 g     F .text	00000068 main
0404b59c g     O .bss	00000004 alt_envp
0404b58c g     O .bss	00000004 __malloc_max_total_mem
0404547c g     F .text	00000058 altera_avalon_jtag_uart_write_fd
0404264c g     F .text	00000008 __sclose
04072000 g       *ABS*	00000000 __alt_heap_limit
04042990 g     F .text	00000014 fclose
0404b6d4 g     O .bss	00000190 _atexit0
0404082c g     F .text	00000740 _malloc_r
04049a40 g     O .rwdata	00000004 alt_errno
04044234 g     F .text	00000048 alt_write_flash_command_32bit_device_32bit_mode
04042368 g     F .text	000000b8 _fwalk
04043ba0 g     F .text	00000164 alt_write_value_to_flash
040442b0 g     F .text	00000034 alt_write_native_16bit
04047da8 g     F .text	00000060 __divsi3
00000000 g       *ABS*	00000000 __alt_mem_cfi_flash
04041e60 g     F .text	0000012c _malloc_trim_r
04047edc g       *ABS*	00000000 __CTOR_END__
04047edc g       *ABS*	00000000 __flash_rodata_start
04047edc g       *ABS*	00000000 __DTOR_LIST__
04043658 g     F .text	00000034 alt_irq_init
040433bc g     F .text	00000060 alt_release_fd
04047984 g     F .text	00000014 atexit
04042798 g     F .text	00000078 _write_r
04049a1c g     O .rwdata	00000004 _impure_ptr
0404b594 g     O .bss	00000004 alt_argc
04046258 g     F .text	00000064 _do_dtors
04040020 g       .exceptions	00000000 alt_irq_entry
04041cbc g     F .text	00000018 __fp_unlock_all
04049a2c g     O .rwdata	00000008 alt_fs_list
04044160 g     F .text	00000048 alt_write_flash_command_32bit_device_8bit_mode
04040020 g       *ABS*	00000000 __ram_exceptions_start
04040000 g       *ABS*	00000000 __alt_mem_onchip_memory2
040463bc g     F .text	00000050 alt_ic_isr_register
04049a5c g       *ABS*	00000000 _edata
0404b864 g       *ABS*	00000000 _end
040462bc g     F .text	0000007c alt_flash_open_dev
040401b4 g       *ABS*	00000000 __ram_exceptions_end
04045978 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
040464a8 g     F .text	000000a0 alt_ic_irq_disable
040426bc g     F .text	0000007c __swrite
04049a24 g     O .rwdata	00000004 __malloc_trim_threshold
04046c2c g     F .text	00000020 altera_nios2_qsys_irq_init
04047998 g     F .text	00000038 exit
040422a0 g     F .text	000000c8 _fwalk_reent
04046338 g     F .text	00000054 alt_flash_close_dev
04047e08 g     F .text	00000060 __modsi3
04072000 g       *ABS*	00000000 __alt_data_end
04040020 g     F .exceptions	00000000 alt_exception
04041bfc g     F .text	00000004 __sfp_lock_release
04047eb8 g     F .text	00000020 _exit
04045ed0 g     F .text	00000154 alt_alarm_start
04042420 g     F .text	00000194 __smakebuf_r
040442e4 g     F .text	00000030 alt_write_native_32bit
0404031c g     F .text	00000074 strlen
040468a0 g     F .text	00000188 open
04043aa8 g     F .text	00000090 alt_flash_cfi_get_info
0404638c g     F .text	00000030 alt_icache_flush_all
04049a50 g     O .rwdata	00000004 alt_priority_mask
0404640c g     F .text	0000009c alt_ic_irq_enable
04049a54 g     O .rwdata	00000008 alt_alarm_list
040461f4 g     F .text	00000064 _do_ctors
04042b78 g     F .text	000000fc close
04046c4c g     F .text	00000068 alt_program_amd
04042f54 g     F .text	00000080 alt_load
00000000  w      *UND*	00000000 free
04041c00 g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .entry:

00000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   0:	00840014 	movui	r2,4096
#endif

0:
    initi r2
   4:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   8:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   c:	00bffd16 	blt	zero,r2,4 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  10:	00410134 	movhi	at,1028
    ori r1, r1, %lo(_start)
  14:	08406d14 	ori	at,at,436
    jmp r1
  18:	0800683a 	jmp	at
  1c:	00000000 	call	0 <__reset>

Disassembly of section .exceptions:

04040020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 4040020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 4040024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 4040028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 404002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 4040030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 4040034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 4040038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 404003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 4040040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 4040044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 4040048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 404004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 4040050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 4040054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 4040058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 404005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 4040060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 4040064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 4040068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 404006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 4040070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 4040074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 4040078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 404007c:	10000326 	beq	r2,zero,404008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 4040080:	20000226 	beq	r4,zero,404008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 4040084:	40400ec0 	call	40400ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 4040088:	00000306 	br	4040098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 404008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 4040090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 4040094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 4040098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 404009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 40400a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 40400a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 40400a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 40400ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 40400b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 40400b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 40400b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 40400bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 40400c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 40400c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 40400c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 40400cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 40400d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 40400d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 40400d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 40400dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 40400e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 40400e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 40400e8:	ef80083a 	eret

040400ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 40400ec:	defff904 	addi	sp,sp,-28
 40400f0:	dfc00615 	stw	ra,24(sp)
 40400f4:	df000515 	stw	fp,20(sp)
 40400f8:	df000504 	addi	fp,sp,20
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 40400fc:	0005313a 	rdctl	r2,ipending
 4040100:	e0bffc15 	stw	r2,-16(fp)

  return active;
 4040104:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 4040108:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 404010c:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 4040110:	00800044 	movi	r2,1
 4040114:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 4040118:	e0ffff17 	ldw	r3,-4(fp)
 404011c:	e0bffe17 	ldw	r2,-8(fp)
 4040120:	1884703a 	and	r2,r3,r2
 4040124:	1005003a 	cmpeq	r2,r2,zero
 4040128:	1000161e 	bne	r2,zero,4040184 <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 404012c:	e0bffd17 	ldw	r2,-12(fp)
 4040130:	00c10174 	movhi	r3,1029
 4040134:	18ed7504 	addi	r3,r3,-18988
 4040138:	100490fa 	slli	r2,r2,3
 404013c:	10c5883a 	add	r2,r2,r3
 4040140:	11400017 	ldw	r5,0(r2)
 4040144:	e0bffd17 	ldw	r2,-12(fp)
 4040148:	00c10174 	movhi	r3,1029
 404014c:	18ed7504 	addi	r3,r3,-18988
 4040150:	100490fa 	slli	r2,r2,3
 4040154:	10c5883a 	add	r2,r2,r3
 4040158:	10800104 	addi	r2,r2,4
 404015c:	11000017 	ldw	r4,0(r2)
 4040160:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 4040164:	0005313a 	rdctl	r2,ipending
 4040168:	e0bffb15 	stw	r2,-20(fp)

  return active;
 404016c:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 4040170:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 4040174:	e0bfff17 	ldw	r2,-4(fp)
 4040178:	1004c03a 	cmpne	r2,r2,zero
 404017c:	103fe31e 	bne	r2,zero,404010c <alt_irq_handler+0x20>
 4040180:	00000706 	br	40401a0 <alt_irq_handler+0xb4>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 4040184:	e0bffe17 	ldw	r2,-8(fp)
 4040188:	1085883a 	add	r2,r2,r2
 404018c:	e0bffe15 	stw	r2,-8(fp)
      i++;
 4040190:	e0bffd17 	ldw	r2,-12(fp)
 4040194:	10800044 	addi	r2,r2,1
 4040198:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 404019c:	003fde06 	br	4040118 <alt_irq_handler+0x2c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
 40401a0:	e037883a 	mov	sp,fp
 40401a4:	dfc00117 	ldw	ra,4(sp)
 40401a8:	df000017 	ldw	fp,0(sp)
 40401ac:	dec00204 	addi	sp,sp,8
 40401b0:	f800283a 	ret

Disassembly of section .text:

040401b4 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 40401b4:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 40401b8:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 40401bc:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 40401c0:	00bffd16 	blt	zero,r2,40401b8 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 40401c4:	06c101f4 	movhi	sp,1031
    ori sp, sp, %lo(__alt_stack_pointer)
 40401c8:	dec80014 	ori	sp,sp,8192

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 40401cc:	06810174 	movhi	gp,1029
    ori gp, gp, %lo(_gp)
 40401d0:	d6868714 	ori	gp,gp,6684
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 40401d4:	00810134 	movhi	r2,1028
    ori r2, r2, %lo(__bss_start)
 40401d8:	10ad6114 	ori	r2,r2,46468

    movhi r3, %hi(__bss_end)
 40401dc:	00c10134 	movhi	r3,1028
    ori r3, r3, %lo(__bss_end)
 40401e0:	18ee1914 	ori	r3,r3,47204

    beq r2, r3, 1f
 40401e4:	10c00326 	beq	r2,r3,40401f4 <_start+0x40>

0:
    stw zero, (r2)
 40401e8:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 40401ec:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 40401f0:	10fffd36 	bltu	r2,r3,40401e8 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 40401f4:	4042f540 	call	4042f54 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 40401f8:	40431900 	call	4043190 <alt_main>

040401fc <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 40401fc:	003fff06 	br	40401fc <alt_after_alt_main>

04040200 <main>:

#include <stdio.h>
#include "system.h"
#include "altera_avalon_pio_regs.h"
int main()
{
 4040200:	defffc04 	addi	sp,sp,-16
 4040204:	dfc00315 	stw	ra,12(sp)
 4040208:	df000215 	stw	fp,8(sp)
 404020c:	df000204 	addi	fp,sp,8
    printf("Hello from Nios II!\n");
 4040210:	01010134 	movhi	r4,1028
 4040214:	211fb704 	addi	r4,r4,32476
 4040218:	40403080 	call	4040308 <puts>
    int count = 0;
 404021c:	e03fff15 	stw	zero,-4(fp)
    int delay;
    while(1)
    {
        IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, count & 0x01);
 4040220:	e0bfff17 	ldw	r2,-4(fp)
 4040224:	10c0004c 	andi	r3,r2,1
 4040228:	00810234 	movhi	r2,1032
 404022c:	10840004 	addi	r2,r2,4096
 4040230:	10c00035 	stwio	r3,0(r2)
        delay = 0;
 4040234:	e03ffe15 	stw	zero,-8(fp)
        while(delay < 1000000)
 4040238:	00000306 	br	4040248 <main+0x48>
        {
            delay++;
 404023c:	e0bffe17 	ldw	r2,-8(fp)
 4040240:	10800044 	addi	r2,r2,1
 4040244:	e0bffe15 	stw	r2,-8(fp)
    int delay;
    while(1)
    {
        IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, count & 0x01);
        delay = 0;
        while(delay < 1000000)
 4040248:	e0fffe17 	ldw	r3,-8(fp)
 404024c:	008003f4 	movhi	r2,15
 4040250:	10908fc4 	addi	r2,r2,16959
 4040254:	10fff90e 	bge	r2,r3,404023c <main+0x3c>
        {
            delay++;
        }
        count++;
 4040258:	e0bfff17 	ldw	r2,-4(fp)
 404025c:	10800044 	addi	r2,r2,1
 4040260:	e0bfff15 	stw	r2,-4(fp)
    }
 4040264:	003fee06 	br	4040220 <main+0x20>

04040268 <_puts_r>:
 4040268:	defff604 	addi	sp,sp,-40
 404026c:	dc400715 	stw	r17,28(sp)
 4040270:	2023883a 	mov	r17,r4
 4040274:	2809883a 	mov	r4,r5
 4040278:	dfc00915 	stw	ra,36(sp)
 404027c:	dcc00815 	stw	r19,32(sp)
 4040280:	2827883a 	mov	r19,r5
 4040284:	404031c0 	call	404031c <strlen>
 4040288:	89400217 	ldw	r5,8(r17)
 404028c:	00c10134 	movhi	r3,1028
 4040290:	18dfbc04 	addi	r3,r3,32496
 4040294:	01c00044 	movi	r7,1
 4040298:	12000044 	addi	r8,r2,1
 404029c:	d8c00515 	stw	r3,20(sp)
 40402a0:	d9c00615 	stw	r7,24(sp)
 40402a4:	d8c00304 	addi	r3,sp,12
 40402a8:	01c00084 	movi	r7,2
 40402ac:	8809883a 	mov	r4,r17
 40402b0:	d80d883a 	mov	r6,sp
 40402b4:	d8c00015 	stw	r3,0(sp)
 40402b8:	dcc00315 	stw	r19,12(sp)
 40402bc:	da000215 	stw	r8,8(sp)
 40402c0:	d9c00115 	stw	r7,4(sp)
 40402c4:	d8800415 	stw	r2,16(sp)
 40402c8:	40403900 	call	4040390 <__sfvwrite_r>
 40402cc:	00ffffc4 	movi	r3,-1
 40402d0:	10000626 	beq	r2,zero,40402ec <_puts_r+0x84>
 40402d4:	1805883a 	mov	r2,r3
 40402d8:	dfc00917 	ldw	ra,36(sp)
 40402dc:	dcc00817 	ldw	r19,32(sp)
 40402e0:	dc400717 	ldw	r17,28(sp)
 40402e4:	dec00a04 	addi	sp,sp,40
 40402e8:	f800283a 	ret
 40402ec:	00c00284 	movi	r3,10
 40402f0:	1805883a 	mov	r2,r3
 40402f4:	dfc00917 	ldw	ra,36(sp)
 40402f8:	dcc00817 	ldw	r19,32(sp)
 40402fc:	dc400717 	ldw	r17,28(sp)
 4040300:	dec00a04 	addi	sp,sp,40
 4040304:	f800283a 	ret

04040308 <puts>:
 4040308:	00810174 	movhi	r2,1029
 404030c:	10a68704 	addi	r2,r2,-26084
 4040310:	200b883a 	mov	r5,r4
 4040314:	11000017 	ldw	r4,0(r2)
 4040318:	40402681 	jmpi	4040268 <_puts_r>

0404031c <strlen>:
 404031c:	208000cc 	andi	r2,r4,3
 4040320:	2011883a 	mov	r8,r4
 4040324:	1000161e 	bne	r2,zero,4040380 <strlen+0x64>
 4040328:	20c00017 	ldw	r3,0(r4)
 404032c:	017fbff4 	movhi	r5,65279
 4040330:	297fbfc4 	addi	r5,r5,-257
 4040334:	01e02074 	movhi	r7,32897
 4040338:	39e02004 	addi	r7,r7,-32640
 404033c:	1945883a 	add	r2,r3,r5
 4040340:	11c4703a 	and	r2,r2,r7
 4040344:	00c6303a 	nor	r3,zero,r3
 4040348:	1886703a 	and	r3,r3,r2
 404034c:	18000c1e 	bne	r3,zero,4040380 <strlen+0x64>
 4040350:	280d883a 	mov	r6,r5
 4040354:	380b883a 	mov	r5,r7
 4040358:	21000104 	addi	r4,r4,4
 404035c:	20800017 	ldw	r2,0(r4)
 4040360:	1187883a 	add	r3,r2,r6
 4040364:	1946703a 	and	r3,r3,r5
 4040368:	0084303a 	nor	r2,zero,r2
 404036c:	10c4703a 	and	r2,r2,r3
 4040370:	103ff926 	beq	r2,zero,4040358 <strlen+0x3c>
 4040374:	20800007 	ldb	r2,0(r4)
 4040378:	10000326 	beq	r2,zero,4040388 <strlen+0x6c>
 404037c:	21000044 	addi	r4,r4,1
 4040380:	20800007 	ldb	r2,0(r4)
 4040384:	103ffd1e 	bne	r2,zero,404037c <strlen+0x60>
 4040388:	2205c83a 	sub	r2,r4,r8
 404038c:	f800283a 	ret

04040390 <__sfvwrite_r>:
 4040390:	30800217 	ldw	r2,8(r6)
 4040394:	defff504 	addi	sp,sp,-44
 4040398:	df000915 	stw	fp,36(sp)
 404039c:	dd800715 	stw	r22,28(sp)
 40403a0:	dc800315 	stw	r18,12(sp)
 40403a4:	dfc00a15 	stw	ra,40(sp)
 40403a8:	ddc00815 	stw	r23,32(sp)
 40403ac:	dd400615 	stw	r21,24(sp)
 40403b0:	dd000515 	stw	r20,20(sp)
 40403b4:	dcc00415 	stw	r19,16(sp)
 40403b8:	dc400215 	stw	r17,8(sp)
 40403bc:	dc000115 	stw	r16,4(sp)
 40403c0:	302d883a 	mov	r22,r6
 40403c4:	2039883a 	mov	fp,r4
 40403c8:	2825883a 	mov	r18,r5
 40403cc:	10001c26 	beq	r2,zero,4040440 <__sfvwrite_r+0xb0>
 40403d0:	29c0030b 	ldhu	r7,12(r5)
 40403d4:	3880020c 	andi	r2,r7,8
 40403d8:	10002726 	beq	r2,zero,4040478 <__sfvwrite_r+0xe8>
 40403dc:	28800417 	ldw	r2,16(r5)
 40403e0:	10002526 	beq	r2,zero,4040478 <__sfvwrite_r+0xe8>
 40403e4:	3880008c 	andi	r2,r7,2
 40403e8:	b5400017 	ldw	r21,0(r22)
 40403ec:	10002826 	beq	r2,zero,4040490 <__sfvwrite_r+0x100>
 40403f0:	0021883a 	mov	r16,zero
 40403f4:	0023883a 	mov	r17,zero
 40403f8:	880d883a 	mov	r6,r17
 40403fc:	e009883a 	mov	r4,fp
 4040400:	00810004 	movi	r2,1024
 4040404:	80006e26 	beq	r16,zero,40405c0 <__sfvwrite_r+0x230>
 4040408:	800f883a 	mov	r7,r16
 404040c:	91400717 	ldw	r5,28(r18)
 4040410:	1400012e 	bgeu	r2,r16,4040418 <__sfvwrite_r+0x88>
 4040414:	100f883a 	mov	r7,r2
 4040418:	90c00917 	ldw	r3,36(r18)
 404041c:	183ee83a 	callr	r3
 4040420:	1007883a 	mov	r3,r2
 4040424:	80a1c83a 	sub	r16,r16,r2
 4040428:	88a3883a 	add	r17,r17,r2
 404042c:	00806d0e 	bge	zero,r2,40405e4 <__sfvwrite_r+0x254>
 4040430:	b0800217 	ldw	r2,8(r22)
 4040434:	10c5c83a 	sub	r2,r2,r3
 4040438:	b0800215 	stw	r2,8(r22)
 404043c:	103fee1e 	bne	r2,zero,40403f8 <__sfvwrite_r+0x68>
 4040440:	0009883a 	mov	r4,zero
 4040444:	2005883a 	mov	r2,r4
 4040448:	dfc00a17 	ldw	ra,40(sp)
 404044c:	df000917 	ldw	fp,36(sp)
 4040450:	ddc00817 	ldw	r23,32(sp)
 4040454:	dd800717 	ldw	r22,28(sp)
 4040458:	dd400617 	ldw	r21,24(sp)
 404045c:	dd000517 	ldw	r20,20(sp)
 4040460:	dcc00417 	ldw	r19,16(sp)
 4040464:	dc800317 	ldw	r18,12(sp)
 4040468:	dc400217 	ldw	r17,8(sp)
 404046c:	dc000117 	ldw	r16,4(sp)
 4040470:	dec00b04 	addi	sp,sp,44
 4040474:	f800283a 	ret
 4040478:	40418340 	call	4041834 <__swsetup_r>
 404047c:	1000e41e 	bne	r2,zero,4040810 <__sfvwrite_r+0x480>
 4040480:	91c0030b 	ldhu	r7,12(r18)
 4040484:	b5400017 	ldw	r21,0(r22)
 4040488:	3880008c 	andi	r2,r7,2
 404048c:	103fd81e 	bne	r2,zero,40403f0 <__sfvwrite_r+0x60>
 4040490:	3880004c 	andi	r2,r7,1
 4040494:	1005003a 	cmpeq	r2,r2,zero
 4040498:	10005726 	beq	r2,zero,40405f8 <__sfvwrite_r+0x268>
 404049c:	0029883a 	mov	r20,zero
 40404a0:	002f883a 	mov	r23,zero
 40404a4:	a0004226 	beq	r20,zero,40405b0 <__sfvwrite_r+0x220>
 40404a8:	3880800c 	andi	r2,r7,512
 40404ac:	94000217 	ldw	r16,8(r18)
 40404b0:	10008b26 	beq	r2,zero,40406e0 <__sfvwrite_r+0x350>
 40404b4:	800d883a 	mov	r6,r16
 40404b8:	a400a536 	bltu	r20,r16,4040750 <__sfvwrite_r+0x3c0>
 40404bc:	3881200c 	andi	r2,r7,1152
 40404c0:	10002726 	beq	r2,zero,4040560 <__sfvwrite_r+0x1d0>
 40404c4:	90800517 	ldw	r2,20(r18)
 40404c8:	92000417 	ldw	r8,16(r18)
 40404cc:	91400017 	ldw	r5,0(r18)
 40404d0:	1087883a 	add	r3,r2,r2
 40404d4:	1887883a 	add	r3,r3,r2
 40404d8:	1808d7fa 	srli	r4,r3,31
 40404dc:	2a21c83a 	sub	r16,r5,r8
 40404e0:	80800044 	addi	r2,r16,1
 40404e4:	20c9883a 	add	r4,r4,r3
 40404e8:	2027d07a 	srai	r19,r4,1
 40404ec:	a085883a 	add	r2,r20,r2
 40404f0:	980d883a 	mov	r6,r19
 40404f4:	9880022e 	bgeu	r19,r2,4040500 <__sfvwrite_r+0x170>
 40404f8:	1027883a 	mov	r19,r2
 40404fc:	100d883a 	mov	r6,r2
 4040500:	3881000c 	andi	r2,r7,1024
 4040504:	1000b826 	beq	r2,zero,40407e8 <__sfvwrite_r+0x458>
 4040508:	300b883a 	mov	r5,r6
 404050c:	e009883a 	mov	r4,fp
 4040510:	404082c0 	call	404082c <_malloc_r>
 4040514:	10003126 	beq	r2,zero,40405dc <__sfvwrite_r+0x24c>
 4040518:	91400417 	ldw	r5,16(r18)
 404051c:	1009883a 	mov	r4,r2
 4040520:	800d883a 	mov	r6,r16
 4040524:	1023883a 	mov	r17,r2
 4040528:	40410500 	call	4041050 <memcpy>
 404052c:	90c0030b 	ldhu	r3,12(r18)
 4040530:	00beffc4 	movi	r2,-1025
 4040534:	1886703a 	and	r3,r3,r2
 4040538:	18c02014 	ori	r3,r3,128
 404053c:	90c0030d 	sth	r3,12(r18)
 4040540:	9c07c83a 	sub	r3,r19,r16
 4040544:	8c05883a 	add	r2,r17,r16
 4040548:	a00d883a 	mov	r6,r20
 404054c:	a021883a 	mov	r16,r20
 4040550:	90800015 	stw	r2,0(r18)
 4040554:	90c00215 	stw	r3,8(r18)
 4040558:	94400415 	stw	r17,16(r18)
 404055c:	94c00515 	stw	r19,20(r18)
 4040560:	91000017 	ldw	r4,0(r18)
 4040564:	b80b883a 	mov	r5,r23
 4040568:	a023883a 	mov	r17,r20
 404056c:	40410f00 	call	40410f0 <memmove>
 4040570:	90c00217 	ldw	r3,8(r18)
 4040574:	90800017 	ldw	r2,0(r18)
 4040578:	a027883a 	mov	r19,r20
 404057c:	1c07c83a 	sub	r3,r3,r16
 4040580:	1405883a 	add	r2,r2,r16
 4040584:	90c00215 	stw	r3,8(r18)
 4040588:	a021883a 	mov	r16,r20
 404058c:	90800015 	stw	r2,0(r18)
 4040590:	b0800217 	ldw	r2,8(r22)
 4040594:	1405c83a 	sub	r2,r2,r16
 4040598:	b0800215 	stw	r2,8(r22)
 404059c:	103fa826 	beq	r2,zero,4040440 <__sfvwrite_r+0xb0>
 40405a0:	a469c83a 	sub	r20,r20,r17
 40405a4:	91c0030b 	ldhu	r7,12(r18)
 40405a8:	bcef883a 	add	r23,r23,r19
 40405ac:	a03fbe1e 	bne	r20,zero,40404a8 <__sfvwrite_r+0x118>
 40405b0:	adc00017 	ldw	r23,0(r21)
 40405b4:	ad000117 	ldw	r20,4(r21)
 40405b8:	ad400204 	addi	r21,r21,8
 40405bc:	003fb906 	br	40404a4 <__sfvwrite_r+0x114>
 40405c0:	ac400017 	ldw	r17,0(r21)
 40405c4:	ac000117 	ldw	r16,4(r21)
 40405c8:	ad400204 	addi	r21,r21,8
 40405cc:	003f8a06 	br	40403f8 <__sfvwrite_r+0x68>
 40405d0:	91400417 	ldw	r5,16(r18)
 40405d4:	e009883a 	mov	r4,fp
 40405d8:	4041f8c0 	call	4041f8c <_free_r>
 40405dc:	00800304 	movi	r2,12
 40405e0:	e0800015 	stw	r2,0(fp)
 40405e4:	9080030b 	ldhu	r2,12(r18)
 40405e8:	013fffc4 	movi	r4,-1
 40405ec:	10801014 	ori	r2,r2,64
 40405f0:	9080030d 	sth	r2,12(r18)
 40405f4:	003f9306 	br	4040444 <__sfvwrite_r+0xb4>
 40405f8:	0027883a 	mov	r19,zero
 40405fc:	002f883a 	mov	r23,zero
 4040600:	d8000015 	stw	zero,0(sp)
 4040604:	0029883a 	mov	r20,zero
 4040608:	98001e26 	beq	r19,zero,4040684 <__sfvwrite_r+0x2f4>
 404060c:	d8c00017 	ldw	r3,0(sp)
 4040610:	1804c03a 	cmpne	r2,r3,zero
 4040614:	10005e26 	beq	r2,zero,4040790 <__sfvwrite_r+0x400>
 4040618:	9821883a 	mov	r16,r19
 404061c:	a4c0012e 	bgeu	r20,r19,4040624 <__sfvwrite_r+0x294>
 4040620:	a021883a 	mov	r16,r20
 4040624:	91000017 	ldw	r4,0(r18)
 4040628:	90800417 	ldw	r2,16(r18)
 404062c:	91800217 	ldw	r6,8(r18)
 4040630:	91c00517 	ldw	r7,20(r18)
 4040634:	1100022e 	bgeu	r2,r4,4040640 <__sfvwrite_r+0x2b0>
 4040638:	31e3883a 	add	r17,r6,r7
 404063c:	8c001616 	blt	r17,r16,4040698 <__sfvwrite_r+0x308>
 4040640:	81c03816 	blt	r16,r7,4040724 <__sfvwrite_r+0x394>
 4040644:	90c00917 	ldw	r3,36(r18)
 4040648:	91400717 	ldw	r5,28(r18)
 404064c:	e009883a 	mov	r4,fp
 4040650:	b80d883a 	mov	r6,r23
 4040654:	183ee83a 	callr	r3
 4040658:	1023883a 	mov	r17,r2
 404065c:	00bfe10e 	bge	zero,r2,40405e4 <__sfvwrite_r+0x254>
 4040660:	a469c83a 	sub	r20,r20,r17
 4040664:	a0001826 	beq	r20,zero,40406c8 <__sfvwrite_r+0x338>
 4040668:	b0800217 	ldw	r2,8(r22)
 404066c:	1445c83a 	sub	r2,r2,r17
 4040670:	b0800215 	stw	r2,8(r22)
 4040674:	103f7226 	beq	r2,zero,4040440 <__sfvwrite_r+0xb0>
 4040678:	9c67c83a 	sub	r19,r19,r17
 404067c:	bc6f883a 	add	r23,r23,r17
 4040680:	983fe21e 	bne	r19,zero,404060c <__sfvwrite_r+0x27c>
 4040684:	adc00017 	ldw	r23,0(r21)
 4040688:	acc00117 	ldw	r19,4(r21)
 404068c:	ad400204 	addi	r21,r21,8
 4040690:	d8000015 	stw	zero,0(sp)
 4040694:	003fdc06 	br	4040608 <__sfvwrite_r+0x278>
 4040698:	b80b883a 	mov	r5,r23
 404069c:	880d883a 	mov	r6,r17
 40406a0:	40410f00 	call	40410f0 <memmove>
 40406a4:	90c00017 	ldw	r3,0(r18)
 40406a8:	e009883a 	mov	r4,fp
 40406ac:	900b883a 	mov	r5,r18
 40406b0:	1c47883a 	add	r3,r3,r17
 40406b4:	90c00015 	stw	r3,0(r18)
 40406b8:	40419700 	call	4041970 <_fflush_r>
 40406bc:	103fc91e 	bne	r2,zero,40405e4 <__sfvwrite_r+0x254>
 40406c0:	a469c83a 	sub	r20,r20,r17
 40406c4:	a03fe81e 	bne	r20,zero,4040668 <__sfvwrite_r+0x2d8>
 40406c8:	e009883a 	mov	r4,fp
 40406cc:	900b883a 	mov	r5,r18
 40406d0:	40419700 	call	4041970 <_fflush_r>
 40406d4:	103fc31e 	bne	r2,zero,40405e4 <__sfvwrite_r+0x254>
 40406d8:	d8000015 	stw	zero,0(sp)
 40406dc:	003fe206 	br	4040668 <__sfvwrite_r+0x2d8>
 40406e0:	91000017 	ldw	r4,0(r18)
 40406e4:	90800417 	ldw	r2,16(r18)
 40406e8:	1100022e 	bgeu	r2,r4,40406f4 <__sfvwrite_r+0x364>
 40406ec:	8023883a 	mov	r17,r16
 40406f0:	85003136 	bltu	r16,r20,40407b8 <__sfvwrite_r+0x428>
 40406f4:	91c00517 	ldw	r7,20(r18)
 40406f8:	a1c01836 	bltu	r20,r7,404075c <__sfvwrite_r+0x3cc>
 40406fc:	90c00917 	ldw	r3,36(r18)
 4040700:	91400717 	ldw	r5,28(r18)
 4040704:	e009883a 	mov	r4,fp
 4040708:	b80d883a 	mov	r6,r23
 404070c:	183ee83a 	callr	r3
 4040710:	1021883a 	mov	r16,r2
 4040714:	00bfb30e 	bge	zero,r2,40405e4 <__sfvwrite_r+0x254>
 4040718:	1023883a 	mov	r17,r2
 404071c:	1027883a 	mov	r19,r2
 4040720:	003f9b06 	br	4040590 <__sfvwrite_r+0x200>
 4040724:	b80b883a 	mov	r5,r23
 4040728:	800d883a 	mov	r6,r16
 404072c:	40410f00 	call	40410f0 <memmove>
 4040730:	90c00217 	ldw	r3,8(r18)
 4040734:	90800017 	ldw	r2,0(r18)
 4040738:	8023883a 	mov	r17,r16
 404073c:	1c07c83a 	sub	r3,r3,r16
 4040740:	1405883a 	add	r2,r2,r16
 4040744:	90c00215 	stw	r3,8(r18)
 4040748:	90800015 	stw	r2,0(r18)
 404074c:	003fc406 	br	4040660 <__sfvwrite_r+0x2d0>
 4040750:	a00d883a 	mov	r6,r20
 4040754:	a021883a 	mov	r16,r20
 4040758:	003f8106 	br	4040560 <__sfvwrite_r+0x1d0>
 404075c:	b80b883a 	mov	r5,r23
 4040760:	a00d883a 	mov	r6,r20
 4040764:	40410f00 	call	40410f0 <memmove>
 4040768:	90c00217 	ldw	r3,8(r18)
 404076c:	90800017 	ldw	r2,0(r18)
 4040770:	a021883a 	mov	r16,r20
 4040774:	1d07c83a 	sub	r3,r3,r20
 4040778:	1505883a 	add	r2,r2,r20
 404077c:	a023883a 	mov	r17,r20
 4040780:	a027883a 	mov	r19,r20
 4040784:	90c00215 	stw	r3,8(r18)
 4040788:	90800015 	stw	r2,0(r18)
 404078c:	003f8006 	br	4040590 <__sfvwrite_r+0x200>
 4040790:	b809883a 	mov	r4,r23
 4040794:	01400284 	movi	r5,10
 4040798:	980d883a 	mov	r6,r19
 404079c:	4040f6c0 	call	4040f6c <memchr>
 40407a0:	10001726 	beq	r2,zero,4040800 <__sfvwrite_r+0x470>
 40407a4:	15c5c83a 	sub	r2,r2,r23
 40407a8:	15000044 	addi	r20,r2,1
 40407ac:	00800044 	movi	r2,1
 40407b0:	d8800015 	stw	r2,0(sp)
 40407b4:	003f9806 	br	4040618 <__sfvwrite_r+0x288>
 40407b8:	b80b883a 	mov	r5,r23
 40407bc:	800d883a 	mov	r6,r16
 40407c0:	40410f00 	call	40410f0 <memmove>
 40407c4:	90c00017 	ldw	r3,0(r18)
 40407c8:	e009883a 	mov	r4,fp
 40407cc:	900b883a 	mov	r5,r18
 40407d0:	1c07883a 	add	r3,r3,r16
 40407d4:	90c00015 	stw	r3,0(r18)
 40407d8:	8027883a 	mov	r19,r16
 40407dc:	40419700 	call	4041970 <_fflush_r>
 40407e0:	103f6b26 	beq	r2,zero,4040590 <__sfvwrite_r+0x200>
 40407e4:	003f7f06 	br	40405e4 <__sfvwrite_r+0x254>
 40407e8:	400b883a 	mov	r5,r8
 40407ec:	e009883a 	mov	r4,fp
 40407f0:	40411d00 	call	40411d0 <_realloc_r>
 40407f4:	103f7626 	beq	r2,zero,40405d0 <__sfvwrite_r+0x240>
 40407f8:	1023883a 	mov	r17,r2
 40407fc:	003f5006 	br	4040540 <__sfvwrite_r+0x1b0>
 4040800:	00c00044 	movi	r3,1
 4040804:	9d000044 	addi	r20,r19,1
 4040808:	d8c00015 	stw	r3,0(sp)
 404080c:	003f8206 	br	4040618 <__sfvwrite_r+0x288>
 4040810:	9080030b 	ldhu	r2,12(r18)
 4040814:	00c00244 	movi	r3,9
 4040818:	013fffc4 	movi	r4,-1
 404081c:	10801014 	ori	r2,r2,64
 4040820:	9080030d 	sth	r2,12(r18)
 4040824:	e0c00015 	stw	r3,0(fp)
 4040828:	003f0606 	br	4040444 <__sfvwrite_r+0xb4>

0404082c <_malloc_r>:
 404082c:	defff604 	addi	sp,sp,-40
 4040830:	28c002c4 	addi	r3,r5,11
 4040834:	00800584 	movi	r2,22
 4040838:	dc800215 	stw	r18,8(sp)
 404083c:	dfc00915 	stw	ra,36(sp)
 4040840:	df000815 	stw	fp,32(sp)
 4040844:	ddc00715 	stw	r23,28(sp)
 4040848:	dd800615 	stw	r22,24(sp)
 404084c:	dd400515 	stw	r21,20(sp)
 4040850:	dd000415 	stw	r20,16(sp)
 4040854:	dcc00315 	stw	r19,12(sp)
 4040858:	dc400115 	stw	r17,4(sp)
 404085c:	dc000015 	stw	r16,0(sp)
 4040860:	2025883a 	mov	r18,r4
 4040864:	10c01236 	bltu	r2,r3,40408b0 <_malloc_r+0x84>
 4040868:	04400404 	movi	r17,16
 404086c:	8940142e 	bgeu	r17,r5,40408c0 <_malloc_r+0x94>
 4040870:	00800304 	movi	r2,12
 4040874:	0007883a 	mov	r3,zero
 4040878:	90800015 	stw	r2,0(r18)
 404087c:	1805883a 	mov	r2,r3
 4040880:	dfc00917 	ldw	ra,36(sp)
 4040884:	df000817 	ldw	fp,32(sp)
 4040888:	ddc00717 	ldw	r23,28(sp)
 404088c:	dd800617 	ldw	r22,24(sp)
 4040890:	dd400517 	ldw	r21,20(sp)
 4040894:	dd000417 	ldw	r20,16(sp)
 4040898:	dcc00317 	ldw	r19,12(sp)
 404089c:	dc800217 	ldw	r18,8(sp)
 40408a0:	dc400117 	ldw	r17,4(sp)
 40408a4:	dc000017 	ldw	r16,0(sp)
 40408a8:	dec00a04 	addi	sp,sp,40
 40408ac:	f800283a 	ret
 40408b0:	00bffe04 	movi	r2,-8
 40408b4:	18a2703a 	and	r17,r3,r2
 40408b8:	883fed16 	blt	r17,zero,4040870 <_malloc_r+0x44>
 40408bc:	897fec36 	bltu	r17,r5,4040870 <_malloc_r+0x44>
 40408c0:	9009883a 	mov	r4,r18
 40408c4:	40431fc0 	call	40431fc <__malloc_lock>
 40408c8:	00807dc4 	movi	r2,503
 40408cc:	14402b2e 	bgeu	r2,r17,404097c <_malloc_r+0x150>
 40408d0:	8806d27a 	srli	r3,r17,9
 40408d4:	18003f1e 	bne	r3,zero,40409d4 <_malloc_r+0x1a8>
 40408d8:	880cd0fa 	srli	r6,r17,3
 40408dc:	300490fa 	slli	r2,r6,3
 40408e0:	02c10174 	movhi	r11,1029
 40408e4:	5ae0cd04 	addi	r11,r11,-31948
 40408e8:	12cb883a 	add	r5,r2,r11
 40408ec:	2c000317 	ldw	r16,12(r5)
 40408f0:	580f883a 	mov	r7,r11
 40408f4:	2c00041e 	bne	r5,r16,4040908 <_malloc_r+0xdc>
 40408f8:	00000a06 	br	4040924 <_malloc_r+0xf8>
 40408fc:	1800860e 	bge	r3,zero,4040b18 <_malloc_r+0x2ec>
 4040900:	84000317 	ldw	r16,12(r16)
 4040904:	2c000726 	beq	r5,r16,4040924 <_malloc_r+0xf8>
 4040908:	80800117 	ldw	r2,4(r16)
 404090c:	00ffff04 	movi	r3,-4
 4040910:	10c8703a 	and	r4,r2,r3
 4040914:	2447c83a 	sub	r3,r4,r17
 4040918:	008003c4 	movi	r2,15
 404091c:	10fff70e 	bge	r2,r3,40408fc <_malloc_r+0xd0>
 4040920:	31bfffc4 	addi	r6,r6,-1
 4040924:	32400044 	addi	r9,r6,1
 4040928:	02810174 	movhi	r10,1029
 404092c:	52a0cf04 	addi	r10,r10,-31940
 4040930:	54000217 	ldw	r16,8(r10)
 4040934:	8280a026 	beq	r16,r10,4040bb8 <_malloc_r+0x38c>
 4040938:	80800117 	ldw	r2,4(r16)
 404093c:	00ffff04 	movi	r3,-4
 4040940:	10ca703a 	and	r5,r2,r3
 4040944:	2c4dc83a 	sub	r6,r5,r17
 4040948:	008003c4 	movi	r2,15
 404094c:	11808316 	blt	r2,r6,4040b5c <_malloc_r+0x330>
 4040950:	52800315 	stw	r10,12(r10)
 4040954:	52800215 	stw	r10,8(r10)
 4040958:	30002916 	blt	r6,zero,4040a00 <_malloc_r+0x1d4>
 404095c:	8147883a 	add	r3,r16,r5
 4040960:	18800117 	ldw	r2,4(r3)
 4040964:	9009883a 	mov	r4,r18
 4040968:	10800054 	ori	r2,r2,1
 404096c:	18800115 	stw	r2,4(r3)
 4040970:	404321c0 	call	404321c <__malloc_unlock>
 4040974:	80c00204 	addi	r3,r16,8
 4040978:	003fc006 	br	404087c <_malloc_r+0x50>
 404097c:	02c10174 	movhi	r11,1029
 4040980:	5ae0cd04 	addi	r11,r11,-31948
 4040984:	8ac5883a 	add	r2,r17,r11
 4040988:	14000317 	ldw	r16,12(r2)
 404098c:	580f883a 	mov	r7,r11
 4040990:	8806d0fa 	srli	r3,r17,3
 4040994:	14006c26 	beq	r2,r16,4040b48 <_malloc_r+0x31c>
 4040998:	80c00117 	ldw	r3,4(r16)
 404099c:	00bfff04 	movi	r2,-4
 40409a0:	81800317 	ldw	r6,12(r16)
 40409a4:	1886703a 	and	r3,r3,r2
 40409a8:	80c7883a 	add	r3,r16,r3
 40409ac:	18800117 	ldw	r2,4(r3)
 40409b0:	81400217 	ldw	r5,8(r16)
 40409b4:	9009883a 	mov	r4,r18
 40409b8:	10800054 	ori	r2,r2,1
 40409bc:	18800115 	stw	r2,4(r3)
 40409c0:	31400215 	stw	r5,8(r6)
 40409c4:	29800315 	stw	r6,12(r5)
 40409c8:	404321c0 	call	404321c <__malloc_unlock>
 40409cc:	80c00204 	addi	r3,r16,8
 40409d0:	003faa06 	br	404087c <_malloc_r+0x50>
 40409d4:	00800104 	movi	r2,4
 40409d8:	10c0052e 	bgeu	r2,r3,40409f0 <_malloc_r+0x1c4>
 40409dc:	00800504 	movi	r2,20
 40409e0:	10c07836 	bltu	r2,r3,4040bc4 <_malloc_r+0x398>
 40409e4:	198016c4 	addi	r6,r3,91
 40409e8:	300490fa 	slli	r2,r6,3
 40409ec:	003fbc06 	br	40408e0 <_malloc_r+0xb4>
 40409f0:	8804d1ba 	srli	r2,r17,6
 40409f4:	11800e04 	addi	r6,r2,56
 40409f8:	300490fa 	slli	r2,r6,3
 40409fc:	003fb806 	br	40408e0 <_malloc_r+0xb4>
 4040a00:	00807fc4 	movi	r2,511
 4040a04:	1140bb36 	bltu	r2,r5,4040cf4 <_malloc_r+0x4c8>
 4040a08:	2806d0fa 	srli	r3,r5,3
 4040a0c:	573ffe04 	addi	fp,r10,-8
 4040a10:	00800044 	movi	r2,1
 4040a14:	180890fa 	slli	r4,r3,3
 4040a18:	1807d0ba 	srai	r3,r3,2
 4040a1c:	e1c00117 	ldw	r7,4(fp)
 4040a20:	5909883a 	add	r4,r11,r4
 4040a24:	21400217 	ldw	r5,8(r4)
 4040a28:	10c4983a 	sll	r2,r2,r3
 4040a2c:	81000315 	stw	r4,12(r16)
 4040a30:	81400215 	stw	r5,8(r16)
 4040a34:	388eb03a 	or	r7,r7,r2
 4040a38:	2c000315 	stw	r16,12(r5)
 4040a3c:	24000215 	stw	r16,8(r4)
 4040a40:	e1c00115 	stw	r7,4(fp)
 4040a44:	4807883a 	mov	r3,r9
 4040a48:	4800cd16 	blt	r9,zero,4040d80 <_malloc_r+0x554>
 4040a4c:	1807d0ba 	srai	r3,r3,2
 4040a50:	00800044 	movi	r2,1
 4040a54:	10c8983a 	sll	r4,r2,r3
 4040a58:	39004436 	bltu	r7,r4,4040b6c <_malloc_r+0x340>
 4040a5c:	21c4703a 	and	r2,r4,r7
 4040a60:	10000a1e 	bne	r2,zero,4040a8c <_malloc_r+0x260>
 4040a64:	2109883a 	add	r4,r4,r4
 4040a68:	00bfff04 	movi	r2,-4
 4040a6c:	4884703a 	and	r2,r9,r2
 4040a70:	3906703a 	and	r3,r7,r4
 4040a74:	12400104 	addi	r9,r2,4
 4040a78:	1800041e 	bne	r3,zero,4040a8c <_malloc_r+0x260>
 4040a7c:	2109883a 	add	r4,r4,r4
 4040a80:	3904703a 	and	r2,r7,r4
 4040a84:	4a400104 	addi	r9,r9,4
 4040a88:	103ffc26 	beq	r2,zero,4040a7c <_malloc_r+0x250>
 4040a8c:	480490fa 	slli	r2,r9,3
 4040a90:	4819883a 	mov	r12,r9
 4040a94:	023fff04 	movi	r8,-4
 4040a98:	589b883a 	add	r13,r11,r2
 4040a9c:	6807883a 	mov	r3,r13
 4040aa0:	014003c4 	movi	r5,15
 4040aa4:	1c000317 	ldw	r16,12(r3)
 4040aa8:	1c00041e 	bne	r3,r16,4040abc <_malloc_r+0x290>
 4040aac:	0000a706 	br	4040d4c <_malloc_r+0x520>
 4040ab0:	3000ab0e 	bge	r6,zero,4040d60 <_malloc_r+0x534>
 4040ab4:	84000317 	ldw	r16,12(r16)
 4040ab8:	1c00a426 	beq	r3,r16,4040d4c <_malloc_r+0x520>
 4040abc:	80800117 	ldw	r2,4(r16)
 4040ac0:	1204703a 	and	r2,r2,r8
 4040ac4:	144dc83a 	sub	r6,r2,r17
 4040ac8:	29bff90e 	bge	r5,r6,4040ab0 <_malloc_r+0x284>
 4040acc:	81000317 	ldw	r4,12(r16)
 4040ad0:	80c00217 	ldw	r3,8(r16)
 4040ad4:	89400054 	ori	r5,r17,1
 4040ad8:	8445883a 	add	r2,r16,r17
 4040adc:	20c00215 	stw	r3,8(r4)
 4040ae0:	19000315 	stw	r4,12(r3)
 4040ae4:	81400115 	stw	r5,4(r16)
 4040ae8:	1187883a 	add	r3,r2,r6
 4040aec:	31000054 	ori	r4,r6,1
 4040af0:	50800315 	stw	r2,12(r10)
 4040af4:	50800215 	stw	r2,8(r10)
 4040af8:	19800015 	stw	r6,0(r3)
 4040afc:	11000115 	stw	r4,4(r2)
 4040b00:	12800215 	stw	r10,8(r2)
 4040b04:	12800315 	stw	r10,12(r2)
 4040b08:	9009883a 	mov	r4,r18
 4040b0c:	404321c0 	call	404321c <__malloc_unlock>
 4040b10:	80c00204 	addi	r3,r16,8
 4040b14:	003f5906 	br	404087c <_malloc_r+0x50>
 4040b18:	8109883a 	add	r4,r16,r4
 4040b1c:	20800117 	ldw	r2,4(r4)
 4040b20:	80c00217 	ldw	r3,8(r16)
 4040b24:	81400317 	ldw	r5,12(r16)
 4040b28:	10800054 	ori	r2,r2,1
 4040b2c:	20800115 	stw	r2,4(r4)
 4040b30:	28c00215 	stw	r3,8(r5)
 4040b34:	19400315 	stw	r5,12(r3)
 4040b38:	9009883a 	mov	r4,r18
 4040b3c:	404321c0 	call	404321c <__malloc_unlock>
 4040b40:	80c00204 	addi	r3,r16,8
 4040b44:	003f4d06 	br	404087c <_malloc_r+0x50>
 4040b48:	80800204 	addi	r2,r16,8
 4040b4c:	14000317 	ldw	r16,12(r2)
 4040b50:	143f911e 	bne	r2,r16,4040998 <_malloc_r+0x16c>
 4040b54:	1a400084 	addi	r9,r3,2
 4040b58:	003f7306 	br	4040928 <_malloc_r+0xfc>
 4040b5c:	88c00054 	ori	r3,r17,1
 4040b60:	8445883a 	add	r2,r16,r17
 4040b64:	80c00115 	stw	r3,4(r16)
 4040b68:	003fdf06 	br	4040ae8 <_malloc_r+0x2bc>
 4040b6c:	e4000217 	ldw	r16,8(fp)
 4040b70:	00bfff04 	movi	r2,-4
 4040b74:	80c00117 	ldw	r3,4(r16)
 4040b78:	802d883a 	mov	r22,r16
 4040b7c:	18aa703a 	and	r21,r3,r2
 4040b80:	ac401636 	bltu	r21,r17,4040bdc <_malloc_r+0x3b0>
 4040b84:	ac49c83a 	sub	r4,r21,r17
 4040b88:	008003c4 	movi	r2,15
 4040b8c:	1100130e 	bge	r2,r4,4040bdc <_malloc_r+0x3b0>
 4040b90:	88800054 	ori	r2,r17,1
 4040b94:	8447883a 	add	r3,r16,r17
 4040b98:	80800115 	stw	r2,4(r16)
 4040b9c:	20800054 	ori	r2,r4,1
 4040ba0:	18800115 	stw	r2,4(r3)
 4040ba4:	e0c00215 	stw	r3,8(fp)
 4040ba8:	9009883a 	mov	r4,r18
 4040bac:	404321c0 	call	404321c <__malloc_unlock>
 4040bb0:	80c00204 	addi	r3,r16,8
 4040bb4:	003f3106 	br	404087c <_malloc_r+0x50>
 4040bb8:	39c00117 	ldw	r7,4(r7)
 4040bbc:	573ffe04 	addi	fp,r10,-8
 4040bc0:	003fa006 	br	4040a44 <_malloc_r+0x218>
 4040bc4:	00801504 	movi	r2,84
 4040bc8:	10c06736 	bltu	r2,r3,4040d68 <_malloc_r+0x53c>
 4040bcc:	8804d33a 	srli	r2,r17,12
 4040bd0:	11801b84 	addi	r6,r2,110
 4040bd4:	300490fa 	slli	r2,r6,3
 4040bd8:	003f4106 	br	40408e0 <_malloc_r+0xb4>
 4040bdc:	d0a6da17 	ldw	r2,-25752(gp)
 4040be0:	d0e00317 	ldw	r3,-32756(gp)
 4040be4:	053fffc4 	movi	r20,-1
 4040be8:	10800404 	addi	r2,r2,16
 4040bec:	88a7883a 	add	r19,r17,r2
 4040bf0:	1d000326 	beq	r3,r20,4040c00 <_malloc_r+0x3d4>
 4040bf4:	98c3ffc4 	addi	r3,r19,4095
 4040bf8:	00bc0004 	movi	r2,-4096
 4040bfc:	18a6703a 	and	r19,r3,r2
 4040c00:	9009883a 	mov	r4,r18
 4040c04:	980b883a 	mov	r5,r19
 4040c08:	40417c40 	call	40417c4 <_sbrk_r>
 4040c0c:	1009883a 	mov	r4,r2
 4040c10:	15000426 	beq	r2,r20,4040c24 <_malloc_r+0x3f8>
 4040c14:	854b883a 	add	r5,r16,r21
 4040c18:	1029883a 	mov	r20,r2
 4040c1c:	11405a2e 	bgeu	r2,r5,4040d88 <_malloc_r+0x55c>
 4040c20:	87000c26 	beq	r16,fp,4040c54 <_malloc_r+0x428>
 4040c24:	e4000217 	ldw	r16,8(fp)
 4040c28:	80c00117 	ldw	r3,4(r16)
 4040c2c:	00bfff04 	movi	r2,-4
 4040c30:	1884703a 	and	r2,r3,r2
 4040c34:	14400336 	bltu	r2,r17,4040c44 <_malloc_r+0x418>
 4040c38:	1449c83a 	sub	r4,r2,r17
 4040c3c:	008003c4 	movi	r2,15
 4040c40:	113fd316 	blt	r2,r4,4040b90 <_malloc_r+0x364>
 4040c44:	9009883a 	mov	r4,r18
 4040c48:	404321c0 	call	404321c <__malloc_unlock>
 4040c4c:	0007883a 	mov	r3,zero
 4040c50:	003f0a06 	br	404087c <_malloc_r+0x50>
 4040c54:	05c10174 	movhi	r23,1029
 4040c58:	bded6b04 	addi	r23,r23,-19028
 4040c5c:	b8800017 	ldw	r2,0(r23)
 4040c60:	988d883a 	add	r6,r19,r2
 4040c64:	b9800015 	stw	r6,0(r23)
 4040c68:	d0e00317 	ldw	r3,-32756(gp)
 4040c6c:	00bfffc4 	movi	r2,-1
 4040c70:	18808e26 	beq	r3,r2,4040eac <_malloc_r+0x680>
 4040c74:	2145c83a 	sub	r2,r4,r5
 4040c78:	3085883a 	add	r2,r6,r2
 4040c7c:	b8800015 	stw	r2,0(r23)
 4040c80:	20c001cc 	andi	r3,r4,7
 4040c84:	18005f1e 	bne	r3,zero,4040e04 <_malloc_r+0x5d8>
 4040c88:	000b883a 	mov	r5,zero
 4040c8c:	a4c5883a 	add	r2,r20,r19
 4040c90:	1083ffcc 	andi	r2,r2,4095
 4040c94:	00c40004 	movi	r3,4096
 4040c98:	1887c83a 	sub	r3,r3,r2
 4040c9c:	28e7883a 	add	r19,r5,r3
 4040ca0:	9009883a 	mov	r4,r18
 4040ca4:	980b883a 	mov	r5,r19
 4040ca8:	40417c40 	call	40417c4 <_sbrk_r>
 4040cac:	1007883a 	mov	r3,r2
 4040cb0:	00bfffc4 	movi	r2,-1
 4040cb4:	18807a26 	beq	r3,r2,4040ea0 <_malloc_r+0x674>
 4040cb8:	1d05c83a 	sub	r2,r3,r20
 4040cbc:	9885883a 	add	r2,r19,r2
 4040cc0:	10c00054 	ori	r3,r2,1
 4040cc4:	b8800017 	ldw	r2,0(r23)
 4040cc8:	a021883a 	mov	r16,r20
 4040ccc:	a0c00115 	stw	r3,4(r20)
 4040cd0:	9885883a 	add	r2,r19,r2
 4040cd4:	b8800015 	stw	r2,0(r23)
 4040cd8:	e5000215 	stw	r20,8(fp)
 4040cdc:	b7003626 	beq	r22,fp,4040db8 <_malloc_r+0x58c>
 4040ce0:	018003c4 	movi	r6,15
 4040ce4:	35404b36 	bltu	r6,r21,4040e14 <_malloc_r+0x5e8>
 4040ce8:	00800044 	movi	r2,1
 4040cec:	a0800115 	stw	r2,4(r20)
 4040cf0:	003fcd06 	br	4040c28 <_malloc_r+0x3fc>
 4040cf4:	2808d27a 	srli	r4,r5,9
 4040cf8:	2000371e 	bne	r4,zero,4040dd8 <_malloc_r+0x5ac>
 4040cfc:	2808d0fa 	srli	r4,r5,3
 4040d00:	200690fa 	slli	r3,r4,3
 4040d04:	1ad1883a 	add	r8,r3,r11
 4040d08:	41800217 	ldw	r6,8(r8)
 4040d0c:	41805b26 	beq	r8,r6,4040e7c <_malloc_r+0x650>
 4040d10:	30800117 	ldw	r2,4(r6)
 4040d14:	00ffff04 	movi	r3,-4
 4040d18:	10c4703a 	and	r2,r2,r3
 4040d1c:	2880022e 	bgeu	r5,r2,4040d28 <_malloc_r+0x4fc>
 4040d20:	31800217 	ldw	r6,8(r6)
 4040d24:	41bffa1e 	bne	r8,r6,4040d10 <_malloc_r+0x4e4>
 4040d28:	32000317 	ldw	r8,12(r6)
 4040d2c:	39c00117 	ldw	r7,4(r7)
 4040d30:	82000315 	stw	r8,12(r16)
 4040d34:	81800215 	stw	r6,8(r16)
 4040d38:	07010174 	movhi	fp,1029
 4040d3c:	e720cd04 	addi	fp,fp,-31948
 4040d40:	34000315 	stw	r16,12(r6)
 4040d44:	44000215 	stw	r16,8(r8)
 4040d48:	003f3e06 	br	4040a44 <_malloc_r+0x218>
 4040d4c:	63000044 	addi	r12,r12,1
 4040d50:	608000cc 	andi	r2,r12,3
 4040d54:	10005d26 	beq	r2,zero,4040ecc <_malloc_r+0x6a0>
 4040d58:	18c00204 	addi	r3,r3,8
 4040d5c:	003f5106 	br	4040aa4 <_malloc_r+0x278>
 4040d60:	8089883a 	add	r4,r16,r2
 4040d64:	003f6d06 	br	4040b1c <_malloc_r+0x2f0>
 4040d68:	00805504 	movi	r2,340
 4040d6c:	10c02036 	bltu	r2,r3,4040df0 <_malloc_r+0x5c4>
 4040d70:	8804d3fa 	srli	r2,r17,15
 4040d74:	11801dc4 	addi	r6,r2,119
 4040d78:	300490fa 	slli	r2,r6,3
 4040d7c:	003ed806 	br	40408e0 <_malloc_r+0xb4>
 4040d80:	48c000c4 	addi	r3,r9,3
 4040d84:	003f3106 	br	4040a4c <_malloc_r+0x220>
 4040d88:	05c10174 	movhi	r23,1029
 4040d8c:	bded6b04 	addi	r23,r23,-19028
 4040d90:	b8800017 	ldw	r2,0(r23)
 4040d94:	988d883a 	add	r6,r19,r2
 4040d98:	b9800015 	stw	r6,0(r23)
 4040d9c:	293fb21e 	bne	r5,r4,4040c68 <_malloc_r+0x43c>
 4040da0:	2083ffcc 	andi	r2,r4,4095
 4040da4:	103fb01e 	bne	r2,zero,4040c68 <_malloc_r+0x43c>
 4040da8:	e4000217 	ldw	r16,8(fp)
 4040dac:	9d45883a 	add	r2,r19,r21
 4040db0:	10800054 	ori	r2,r2,1
 4040db4:	80800115 	stw	r2,4(r16)
 4040db8:	b8c00017 	ldw	r3,0(r23)
 4040dbc:	d0a6db17 	ldw	r2,-25748(gp)
 4040dc0:	10c0012e 	bgeu	r2,r3,4040dc8 <_malloc_r+0x59c>
 4040dc4:	d0e6db15 	stw	r3,-25748(gp)
 4040dc8:	d0a6dc17 	ldw	r2,-25744(gp)
 4040dcc:	10ff962e 	bgeu	r2,r3,4040c28 <_malloc_r+0x3fc>
 4040dd0:	d0e6dc15 	stw	r3,-25744(gp)
 4040dd4:	003f9406 	br	4040c28 <_malloc_r+0x3fc>
 4040dd8:	00800104 	movi	r2,4
 4040ddc:	11001e36 	bltu	r2,r4,4040e58 <_malloc_r+0x62c>
 4040de0:	2804d1ba 	srli	r2,r5,6
 4040de4:	11000e04 	addi	r4,r2,56
 4040de8:	200690fa 	slli	r3,r4,3
 4040dec:	003fc506 	br	4040d04 <_malloc_r+0x4d8>
 4040df0:	00815504 	movi	r2,1364
 4040df4:	10c01d2e 	bgeu	r2,r3,4040e6c <_malloc_r+0x640>
 4040df8:	01801f84 	movi	r6,126
 4040dfc:	0080fc04 	movi	r2,1008
 4040e00:	003eb706 	br	40408e0 <_malloc_r+0xb4>
 4040e04:	00800204 	movi	r2,8
 4040e08:	10cbc83a 	sub	r5,r2,r3
 4040e0c:	2169883a 	add	r20,r4,r5
 4040e10:	003f9e06 	br	4040c8c <_malloc_r+0x460>
 4040e14:	00bffe04 	movi	r2,-8
 4040e18:	a93ffd04 	addi	r4,r21,-12
 4040e1c:	2088703a 	and	r4,r4,r2
 4040e20:	b10b883a 	add	r5,r22,r4
 4040e24:	00c00144 	movi	r3,5
 4040e28:	28c00215 	stw	r3,8(r5)
 4040e2c:	28c00115 	stw	r3,4(r5)
 4040e30:	b0800117 	ldw	r2,4(r22)
 4040e34:	1080004c 	andi	r2,r2,1
 4040e38:	2084b03a 	or	r2,r4,r2
 4040e3c:	b0800115 	stw	r2,4(r22)
 4040e40:	313fdd2e 	bgeu	r6,r4,4040db8 <_malloc_r+0x58c>
 4040e44:	b1400204 	addi	r5,r22,8
 4040e48:	9009883a 	mov	r4,r18
 4040e4c:	4041f8c0 	call	4041f8c <_free_r>
 4040e50:	e4000217 	ldw	r16,8(fp)
 4040e54:	003fd806 	br	4040db8 <_malloc_r+0x58c>
 4040e58:	00800504 	movi	r2,20
 4040e5c:	11001536 	bltu	r2,r4,4040eb4 <_malloc_r+0x688>
 4040e60:	210016c4 	addi	r4,r4,91
 4040e64:	200690fa 	slli	r3,r4,3
 4040e68:	003fa606 	br	4040d04 <_malloc_r+0x4d8>
 4040e6c:	8804d4ba 	srli	r2,r17,18
 4040e70:	11801f04 	addi	r6,r2,124
 4040e74:	300490fa 	slli	r2,r6,3
 4040e78:	003e9906 	br	40408e0 <_malloc_r+0xb4>
 4040e7c:	2009d0ba 	srai	r4,r4,2
 4040e80:	01410174 	movhi	r5,1029
 4040e84:	2960cd04 	addi	r5,r5,-31948
 4040e88:	00c00044 	movi	r3,1
 4040e8c:	28800117 	ldw	r2,4(r5)
 4040e90:	1906983a 	sll	r3,r3,r4
 4040e94:	10c4b03a 	or	r2,r2,r3
 4040e98:	28800115 	stw	r2,4(r5)
 4040e9c:	003fa306 	br	4040d2c <_malloc_r+0x500>
 4040ea0:	0027883a 	mov	r19,zero
 4040ea4:	00c00044 	movi	r3,1
 4040ea8:	003f8606 	br	4040cc4 <_malloc_r+0x498>
 4040eac:	d1200315 	stw	r4,-32756(gp)
 4040eb0:	003f7306 	br	4040c80 <_malloc_r+0x454>
 4040eb4:	00801504 	movi	r2,84
 4040eb8:	11001936 	bltu	r2,r4,4040f20 <_malloc_r+0x6f4>
 4040ebc:	2804d33a 	srli	r2,r5,12
 4040ec0:	11001b84 	addi	r4,r2,110
 4040ec4:	200690fa 	slli	r3,r4,3
 4040ec8:	003f8e06 	br	4040d04 <_malloc_r+0x4d8>
 4040ecc:	480b883a 	mov	r5,r9
 4040ed0:	6807883a 	mov	r3,r13
 4040ed4:	288000cc 	andi	r2,r5,3
 4040ed8:	18fffe04 	addi	r3,r3,-8
 4040edc:	297fffc4 	addi	r5,r5,-1
 4040ee0:	10001526 	beq	r2,zero,4040f38 <_malloc_r+0x70c>
 4040ee4:	18800217 	ldw	r2,8(r3)
 4040ee8:	10fffa26 	beq	r2,r3,4040ed4 <_malloc_r+0x6a8>
 4040eec:	2109883a 	add	r4,r4,r4
 4040ef0:	393f1e36 	bltu	r7,r4,4040b6c <_malloc_r+0x340>
 4040ef4:	203f1d26 	beq	r4,zero,4040b6c <_malloc_r+0x340>
 4040ef8:	21c4703a 	and	r2,r4,r7
 4040efc:	10000226 	beq	r2,zero,4040f08 <_malloc_r+0x6dc>
 4040f00:	6013883a 	mov	r9,r12
 4040f04:	003ee106 	br	4040a8c <_malloc_r+0x260>
 4040f08:	2109883a 	add	r4,r4,r4
 4040f0c:	3904703a 	and	r2,r7,r4
 4040f10:	63000104 	addi	r12,r12,4
 4040f14:	103ffc26 	beq	r2,zero,4040f08 <_malloc_r+0x6dc>
 4040f18:	6013883a 	mov	r9,r12
 4040f1c:	003edb06 	br	4040a8c <_malloc_r+0x260>
 4040f20:	00805504 	movi	r2,340
 4040f24:	11000836 	bltu	r2,r4,4040f48 <_malloc_r+0x71c>
 4040f28:	2804d3fa 	srli	r2,r5,15
 4040f2c:	11001dc4 	addi	r4,r2,119
 4040f30:	200690fa 	slli	r3,r4,3
 4040f34:	003f7306 	br	4040d04 <_malloc_r+0x4d8>
 4040f38:	0104303a 	nor	r2,zero,r4
 4040f3c:	388e703a 	and	r7,r7,r2
 4040f40:	e1c00115 	stw	r7,4(fp)
 4040f44:	003fe906 	br	4040eec <_malloc_r+0x6c0>
 4040f48:	00815504 	movi	r2,1364
 4040f4c:	1100032e 	bgeu	r2,r4,4040f5c <_malloc_r+0x730>
 4040f50:	01001f84 	movi	r4,126
 4040f54:	00c0fc04 	movi	r3,1008
 4040f58:	003f6a06 	br	4040d04 <_malloc_r+0x4d8>
 4040f5c:	2804d4ba 	srli	r2,r5,18
 4040f60:	11001f04 	addi	r4,r2,124
 4040f64:	200690fa 	slli	r3,r4,3
 4040f68:	003f6606 	br	4040d04 <_malloc_r+0x4d8>

04040f6c <memchr>:
 4040f6c:	008000c4 	movi	r2,3
 4040f70:	29403fcc 	andi	r5,r5,255
 4040f74:	2007883a 	mov	r3,r4
 4040f78:	1180022e 	bgeu	r2,r6,4040f84 <memchr+0x18>
 4040f7c:	2084703a 	and	r2,r4,r2
 4040f80:	10000b26 	beq	r2,zero,4040fb0 <memchr+0x44>
 4040f84:	313fffc4 	addi	r4,r6,-1
 4040f88:	3000051e 	bne	r6,zero,4040fa0 <memchr+0x34>
 4040f8c:	00002c06 	br	4041040 <memchr+0xd4>
 4040f90:	213fffc4 	addi	r4,r4,-1
 4040f94:	00bfffc4 	movi	r2,-1
 4040f98:	18c00044 	addi	r3,r3,1
 4040f9c:	20802826 	beq	r4,r2,4041040 <memchr+0xd4>
 4040fa0:	18800003 	ldbu	r2,0(r3)
 4040fa4:	28bffa1e 	bne	r5,r2,4040f90 <memchr+0x24>
 4040fa8:	1805883a 	mov	r2,r3
 4040fac:	f800283a 	ret
 4040fb0:	0011883a 	mov	r8,zero
 4040fb4:	0007883a 	mov	r3,zero
 4040fb8:	01c00104 	movi	r7,4
 4040fbc:	4004923a 	slli	r2,r8,8
 4040fc0:	18c00044 	addi	r3,r3,1
 4040fc4:	1151883a 	add	r8,r2,r5
 4040fc8:	19fffc1e 	bne	r3,r7,4040fbc <memchr+0x50>
 4040fcc:	02bfbff4 	movhi	r10,65279
 4040fd0:	52bfbfc4 	addi	r10,r10,-257
 4040fd4:	02602074 	movhi	r9,32897
 4040fd8:	4a602004 	addi	r9,r9,-32640
 4040fdc:	02c000c4 	movi	r11,3
 4040fe0:	20800017 	ldw	r2,0(r4)
 4040fe4:	31bfff04 	addi	r6,r6,-4
 4040fe8:	200f883a 	mov	r7,r4
 4040fec:	1204f03a 	xor	r2,r2,r8
 4040ff0:	1287883a 	add	r3,r2,r10
 4040ff4:	1a46703a 	and	r3,r3,r9
 4040ff8:	0084303a 	nor	r2,zero,r2
 4040ffc:	10c4703a 	and	r2,r2,r3
 4041000:	10000b26 	beq	r2,zero,4041030 <memchr+0xc4>
 4041004:	20800003 	ldbu	r2,0(r4)
 4041008:	28800f26 	beq	r5,r2,4041048 <memchr+0xdc>
 404100c:	20800043 	ldbu	r2,1(r4)
 4041010:	21c00044 	addi	r7,r4,1
 4041014:	28800c26 	beq	r5,r2,4041048 <memchr+0xdc>
 4041018:	20800083 	ldbu	r2,2(r4)
 404101c:	21c00084 	addi	r7,r4,2
 4041020:	28800926 	beq	r5,r2,4041048 <memchr+0xdc>
 4041024:	208000c3 	ldbu	r2,3(r4)
 4041028:	21c000c4 	addi	r7,r4,3
 404102c:	28800626 	beq	r5,r2,4041048 <memchr+0xdc>
 4041030:	21000104 	addi	r4,r4,4
 4041034:	59bfea36 	bltu	r11,r6,4040fe0 <memchr+0x74>
 4041038:	2007883a 	mov	r3,r4
 404103c:	003fd106 	br	4040f84 <memchr+0x18>
 4041040:	0005883a 	mov	r2,zero
 4041044:	f800283a 	ret
 4041048:	3805883a 	mov	r2,r7
 404104c:	f800283a 	ret

04041050 <memcpy>:
 4041050:	01c003c4 	movi	r7,15
 4041054:	2007883a 	mov	r3,r4
 4041058:	3980032e 	bgeu	r7,r6,4041068 <memcpy+0x18>
 404105c:	2904b03a 	or	r2,r5,r4
 4041060:	108000cc 	andi	r2,r2,3
 4041064:	10000926 	beq	r2,zero,404108c <memcpy+0x3c>
 4041068:	30000626 	beq	r6,zero,4041084 <memcpy+0x34>
 404106c:	30cd883a 	add	r6,r6,r3
 4041070:	28800003 	ldbu	r2,0(r5)
 4041074:	29400044 	addi	r5,r5,1
 4041078:	18800005 	stb	r2,0(r3)
 404107c:	18c00044 	addi	r3,r3,1
 4041080:	30fffb1e 	bne	r6,r3,4041070 <memcpy+0x20>
 4041084:	2005883a 	mov	r2,r4
 4041088:	f800283a 	ret
 404108c:	3811883a 	mov	r8,r7
 4041090:	200f883a 	mov	r7,r4
 4041094:	28c00017 	ldw	r3,0(r5)
 4041098:	31bffc04 	addi	r6,r6,-16
 404109c:	38c00015 	stw	r3,0(r7)
 40410a0:	28800117 	ldw	r2,4(r5)
 40410a4:	38800115 	stw	r2,4(r7)
 40410a8:	28c00217 	ldw	r3,8(r5)
 40410ac:	38c00215 	stw	r3,8(r7)
 40410b0:	28800317 	ldw	r2,12(r5)
 40410b4:	29400404 	addi	r5,r5,16
 40410b8:	38800315 	stw	r2,12(r7)
 40410bc:	39c00404 	addi	r7,r7,16
 40410c0:	41bff436 	bltu	r8,r6,4041094 <memcpy+0x44>
 40410c4:	008000c4 	movi	r2,3
 40410c8:	1180072e 	bgeu	r2,r6,40410e8 <memcpy+0x98>
 40410cc:	1007883a 	mov	r3,r2
 40410d0:	28800017 	ldw	r2,0(r5)
 40410d4:	31bfff04 	addi	r6,r6,-4
 40410d8:	29400104 	addi	r5,r5,4
 40410dc:	38800015 	stw	r2,0(r7)
 40410e0:	39c00104 	addi	r7,r7,4
 40410e4:	19bffa36 	bltu	r3,r6,40410d0 <memcpy+0x80>
 40410e8:	3807883a 	mov	r3,r7
 40410ec:	003fde06 	br	4041068 <memcpy+0x18>

040410f0 <memmove>:
 40410f0:	2807883a 	mov	r3,r5
 40410f4:	2011883a 	mov	r8,r4
 40410f8:	29000c2e 	bgeu	r5,r4,404112c <memmove+0x3c>
 40410fc:	298f883a 	add	r7,r5,r6
 4041100:	21c00a2e 	bgeu	r4,r7,404112c <memmove+0x3c>
 4041104:	30000726 	beq	r6,zero,4041124 <memmove+0x34>
 4041108:	2187883a 	add	r3,r4,r6
 404110c:	198dc83a 	sub	r6,r3,r6
 4041110:	39ffffc4 	addi	r7,r7,-1
 4041114:	38800003 	ldbu	r2,0(r7)
 4041118:	18ffffc4 	addi	r3,r3,-1
 404111c:	18800005 	stb	r2,0(r3)
 4041120:	19bffb1e 	bne	r3,r6,4041110 <memmove+0x20>
 4041124:	2005883a 	mov	r2,r4
 4041128:	f800283a 	ret
 404112c:	01c003c4 	movi	r7,15
 4041130:	39800a36 	bltu	r7,r6,404115c <memmove+0x6c>
 4041134:	303ffb26 	beq	r6,zero,4041124 <memmove+0x34>
 4041138:	400f883a 	mov	r7,r8
 404113c:	320d883a 	add	r6,r6,r8
 4041140:	28800003 	ldbu	r2,0(r5)
 4041144:	29400044 	addi	r5,r5,1
 4041148:	38800005 	stb	r2,0(r7)
 404114c:	39c00044 	addi	r7,r7,1
 4041150:	39bffb1e 	bne	r7,r6,4041140 <memmove+0x50>
 4041154:	2005883a 	mov	r2,r4
 4041158:	f800283a 	ret
 404115c:	1904b03a 	or	r2,r3,r4
 4041160:	108000cc 	andi	r2,r2,3
 4041164:	103ff31e 	bne	r2,zero,4041134 <memmove+0x44>
 4041168:	3811883a 	mov	r8,r7
 404116c:	180b883a 	mov	r5,r3
 4041170:	200f883a 	mov	r7,r4
 4041174:	28c00017 	ldw	r3,0(r5)
 4041178:	31bffc04 	addi	r6,r6,-16
 404117c:	38c00015 	stw	r3,0(r7)
 4041180:	28800117 	ldw	r2,4(r5)
 4041184:	38800115 	stw	r2,4(r7)
 4041188:	28c00217 	ldw	r3,8(r5)
 404118c:	38c00215 	stw	r3,8(r7)
 4041190:	28800317 	ldw	r2,12(r5)
 4041194:	29400404 	addi	r5,r5,16
 4041198:	38800315 	stw	r2,12(r7)
 404119c:	39c00404 	addi	r7,r7,16
 40411a0:	41bff436 	bltu	r8,r6,4041174 <memmove+0x84>
 40411a4:	008000c4 	movi	r2,3
 40411a8:	1180072e 	bgeu	r2,r6,40411c8 <memmove+0xd8>
 40411ac:	1007883a 	mov	r3,r2
 40411b0:	28800017 	ldw	r2,0(r5)
 40411b4:	31bfff04 	addi	r6,r6,-4
 40411b8:	29400104 	addi	r5,r5,4
 40411bc:	38800015 	stw	r2,0(r7)
 40411c0:	39c00104 	addi	r7,r7,4
 40411c4:	19bffa36 	bltu	r3,r6,40411b0 <memmove+0xc0>
 40411c8:	3811883a 	mov	r8,r7
 40411cc:	003fd906 	br	4041134 <memmove+0x44>

040411d0 <_realloc_r>:
 40411d0:	defff404 	addi	sp,sp,-48
 40411d4:	dd800815 	stw	r22,32(sp)
 40411d8:	dc800415 	stw	r18,16(sp)
 40411dc:	dc400315 	stw	r17,12(sp)
 40411e0:	dfc00b15 	stw	ra,44(sp)
 40411e4:	df000a15 	stw	fp,40(sp)
 40411e8:	ddc00915 	stw	r23,36(sp)
 40411ec:	dd400715 	stw	r21,28(sp)
 40411f0:	dd000615 	stw	r20,24(sp)
 40411f4:	dcc00515 	stw	r19,20(sp)
 40411f8:	dc000215 	stw	r16,8(sp)
 40411fc:	2825883a 	mov	r18,r5
 4041200:	3023883a 	mov	r17,r6
 4041204:	202d883a 	mov	r22,r4
 4041208:	2800c926 	beq	r5,zero,4041530 <_realloc_r+0x360>
 404120c:	40431fc0 	call	40431fc <__malloc_lock>
 4041210:	943ffe04 	addi	r16,r18,-8
 4041214:	88c002c4 	addi	r3,r17,11
 4041218:	00800584 	movi	r2,22
 404121c:	82000117 	ldw	r8,4(r16)
 4041220:	10c01b2e 	bgeu	r2,r3,4041290 <_realloc_r+0xc0>
 4041224:	00bffe04 	movi	r2,-8
 4041228:	188e703a 	and	r7,r3,r2
 404122c:	3839883a 	mov	fp,r7
 4041230:	38001a16 	blt	r7,zero,404129c <_realloc_r+0xcc>
 4041234:	e4401936 	bltu	fp,r17,404129c <_realloc_r+0xcc>
 4041238:	013fff04 	movi	r4,-4
 404123c:	4126703a 	and	r19,r8,r4
 4041240:	99c02616 	blt	r19,r7,40412dc <_realloc_r+0x10c>
 4041244:	802b883a 	mov	r21,r16
 4041248:	9829883a 	mov	r20,r19
 404124c:	84000204 	addi	r16,r16,8
 4041250:	a80f883a 	mov	r7,r21
 4041254:	a70dc83a 	sub	r6,r20,fp
 4041258:	008003c4 	movi	r2,15
 404125c:	1180c136 	bltu	r2,r6,4041564 <_realloc_r+0x394>
 4041260:	38800117 	ldw	r2,4(r7)
 4041264:	a549883a 	add	r4,r20,r21
 4041268:	1080004c 	andi	r2,r2,1
 404126c:	a084b03a 	or	r2,r20,r2
 4041270:	38800115 	stw	r2,4(r7)
 4041274:	20c00117 	ldw	r3,4(r4)
 4041278:	18c00054 	ori	r3,r3,1
 404127c:	20c00115 	stw	r3,4(r4)
 4041280:	b009883a 	mov	r4,r22
 4041284:	404321c0 	call	404321c <__malloc_unlock>
 4041288:	8023883a 	mov	r17,r16
 404128c:	00000606 	br	40412a8 <_realloc_r+0xd8>
 4041290:	01c00404 	movi	r7,16
 4041294:	3839883a 	mov	fp,r7
 4041298:	e47fe72e 	bgeu	fp,r17,4041238 <_realloc_r+0x68>
 404129c:	00800304 	movi	r2,12
 40412a0:	0023883a 	mov	r17,zero
 40412a4:	b0800015 	stw	r2,0(r22)
 40412a8:	8805883a 	mov	r2,r17
 40412ac:	dfc00b17 	ldw	ra,44(sp)
 40412b0:	df000a17 	ldw	fp,40(sp)
 40412b4:	ddc00917 	ldw	r23,36(sp)
 40412b8:	dd800817 	ldw	r22,32(sp)
 40412bc:	dd400717 	ldw	r21,28(sp)
 40412c0:	dd000617 	ldw	r20,24(sp)
 40412c4:	dcc00517 	ldw	r19,20(sp)
 40412c8:	dc800417 	ldw	r18,16(sp)
 40412cc:	dc400317 	ldw	r17,12(sp)
 40412d0:	dc000217 	ldw	r16,8(sp)
 40412d4:	dec00c04 	addi	sp,sp,48
 40412d8:	f800283a 	ret
 40412dc:	00810174 	movhi	r2,1029
 40412e0:	10a0cd04 	addi	r2,r2,-31948
 40412e4:	12400217 	ldw	r9,8(r2)
 40412e8:	84cd883a 	add	r6,r16,r19
 40412ec:	802b883a 	mov	r21,r16
 40412f0:	3240b926 	beq	r6,r9,40415d8 <_realloc_r+0x408>
 40412f4:	31400117 	ldw	r5,4(r6)
 40412f8:	00bfff84 	movi	r2,-2
 40412fc:	2884703a 	and	r2,r5,r2
 4041300:	1185883a 	add	r2,r2,r6
 4041304:	10c00117 	ldw	r3,4(r2)
 4041308:	18c0004c 	andi	r3,r3,1
 404130c:	1807003a 	cmpeq	r3,r3,zero
 4041310:	1800a326 	beq	r3,zero,40415a0 <_realloc_r+0x3d0>
 4041314:	2908703a 	and	r4,r5,r4
 4041318:	9929883a 	add	r20,r19,r4
 404131c:	a1c0a30e 	bge	r20,r7,40415ac <_realloc_r+0x3dc>
 4041320:	4080004c 	andi	r2,r8,1
 4041324:	1000551e 	bne	r2,zero,404147c <_realloc_r+0x2ac>
 4041328:	80800017 	ldw	r2,0(r16)
 404132c:	80afc83a 	sub	r23,r16,r2
 4041330:	b8c00117 	ldw	r3,4(r23)
 4041334:	00bfff04 	movi	r2,-4
 4041338:	1884703a 	and	r2,r3,r2
 404133c:	30002e26 	beq	r6,zero,40413f8 <_realloc_r+0x228>
 4041340:	3240b926 	beq	r6,r9,4041628 <_realloc_r+0x458>
 4041344:	98a9883a 	add	r20,r19,r2
 4041348:	2509883a 	add	r4,r4,r20
 404134c:	d9000015 	stw	r4,0(sp)
 4041350:	21c02a16 	blt	r4,r7,40413fc <_realloc_r+0x22c>
 4041354:	30800317 	ldw	r2,12(r6)
 4041358:	30c00217 	ldw	r3,8(r6)
 404135c:	01400904 	movi	r5,36
 4041360:	99bfff04 	addi	r6,r19,-4
 4041364:	18800315 	stw	r2,12(r3)
 4041368:	10c00215 	stw	r3,8(r2)
 404136c:	b9000317 	ldw	r4,12(r23)
 4041370:	b8800217 	ldw	r2,8(r23)
 4041374:	b82b883a 	mov	r21,r23
 4041378:	bc000204 	addi	r16,r23,8
 404137c:	20800215 	stw	r2,8(r4)
 4041380:	11000315 	stw	r4,12(r2)
 4041384:	2980e436 	bltu	r5,r6,4041718 <_realloc_r+0x548>
 4041388:	008004c4 	movi	r2,19
 404138c:	9009883a 	mov	r4,r18
 4041390:	8011883a 	mov	r8,r16
 4041394:	11800f2e 	bgeu	r2,r6,40413d4 <_realloc_r+0x204>
 4041398:	90800017 	ldw	r2,0(r18)
 404139c:	ba000404 	addi	r8,r23,16
 40413a0:	91000204 	addi	r4,r18,8
 40413a4:	b8800215 	stw	r2,8(r23)
 40413a8:	90c00117 	ldw	r3,4(r18)
 40413ac:	008006c4 	movi	r2,27
 40413b0:	b8c00315 	stw	r3,12(r23)
 40413b4:	1180072e 	bgeu	r2,r6,40413d4 <_realloc_r+0x204>
 40413b8:	90c00217 	ldw	r3,8(r18)
 40413bc:	ba000604 	addi	r8,r23,24
 40413c0:	91000404 	addi	r4,r18,16
 40413c4:	b8c00415 	stw	r3,16(r23)
 40413c8:	90800317 	ldw	r2,12(r18)
 40413cc:	b8800515 	stw	r2,20(r23)
 40413d0:	3140e726 	beq	r6,r5,4041770 <_realloc_r+0x5a0>
 40413d4:	20800017 	ldw	r2,0(r4)
 40413d8:	dd000017 	ldw	r20,0(sp)
 40413dc:	b80f883a 	mov	r7,r23
 40413e0:	40800015 	stw	r2,0(r8)
 40413e4:	20c00117 	ldw	r3,4(r4)
 40413e8:	40c00115 	stw	r3,4(r8)
 40413ec:	20800217 	ldw	r2,8(r4)
 40413f0:	40800215 	stw	r2,8(r8)
 40413f4:	003f9706 	br	4041254 <_realloc_r+0x84>
 40413f8:	98a9883a 	add	r20,r19,r2
 40413fc:	a1c01f16 	blt	r20,r7,404147c <_realloc_r+0x2ac>
 4041400:	b8c00317 	ldw	r3,12(r23)
 4041404:	b8800217 	ldw	r2,8(r23)
 4041408:	99bfff04 	addi	r6,r19,-4
 404140c:	01400904 	movi	r5,36
 4041410:	b82b883a 	mov	r21,r23
 4041414:	18800215 	stw	r2,8(r3)
 4041418:	10c00315 	stw	r3,12(r2)
 404141c:	bc000204 	addi	r16,r23,8
 4041420:	2980c336 	bltu	r5,r6,4041730 <_realloc_r+0x560>
 4041424:	008004c4 	movi	r2,19
 4041428:	9009883a 	mov	r4,r18
 404142c:	8011883a 	mov	r8,r16
 4041430:	11800f2e 	bgeu	r2,r6,4041470 <_realloc_r+0x2a0>
 4041434:	90800017 	ldw	r2,0(r18)
 4041438:	ba000404 	addi	r8,r23,16
 404143c:	91000204 	addi	r4,r18,8
 4041440:	b8800215 	stw	r2,8(r23)
 4041444:	90c00117 	ldw	r3,4(r18)
 4041448:	008006c4 	movi	r2,27
 404144c:	b8c00315 	stw	r3,12(r23)
 4041450:	1180072e 	bgeu	r2,r6,4041470 <_realloc_r+0x2a0>
 4041454:	90c00217 	ldw	r3,8(r18)
 4041458:	ba000604 	addi	r8,r23,24
 404145c:	91000404 	addi	r4,r18,16
 4041460:	b8c00415 	stw	r3,16(r23)
 4041464:	90800317 	ldw	r2,12(r18)
 4041468:	b8800515 	stw	r2,20(r23)
 404146c:	3140c726 	beq	r6,r5,404178c <_realloc_r+0x5bc>
 4041470:	20800017 	ldw	r2,0(r4)
 4041474:	b80f883a 	mov	r7,r23
 4041478:	003fd906 	br	40413e0 <_realloc_r+0x210>
 404147c:	880b883a 	mov	r5,r17
 4041480:	b009883a 	mov	r4,r22
 4041484:	404082c0 	call	404082c <_malloc_r>
 4041488:	1023883a 	mov	r17,r2
 404148c:	10002526 	beq	r2,zero,4041524 <_realloc_r+0x354>
 4041490:	80800117 	ldw	r2,4(r16)
 4041494:	00ffff84 	movi	r3,-2
 4041498:	893ffe04 	addi	r4,r17,-8
 404149c:	10c4703a 	and	r2,r2,r3
 40414a0:	8085883a 	add	r2,r16,r2
 40414a4:	20809526 	beq	r4,r2,40416fc <_realloc_r+0x52c>
 40414a8:	99bfff04 	addi	r6,r19,-4
 40414ac:	01c00904 	movi	r7,36
 40414b0:	39804536 	bltu	r7,r6,40415c8 <_realloc_r+0x3f8>
 40414b4:	008004c4 	movi	r2,19
 40414b8:	9009883a 	mov	r4,r18
 40414bc:	880b883a 	mov	r5,r17
 40414c0:	11800f2e 	bgeu	r2,r6,4041500 <_realloc_r+0x330>
 40414c4:	90800017 	ldw	r2,0(r18)
 40414c8:	89400204 	addi	r5,r17,8
 40414cc:	91000204 	addi	r4,r18,8
 40414d0:	88800015 	stw	r2,0(r17)
 40414d4:	90c00117 	ldw	r3,4(r18)
 40414d8:	008006c4 	movi	r2,27
 40414dc:	88c00115 	stw	r3,4(r17)
 40414e0:	1180072e 	bgeu	r2,r6,4041500 <_realloc_r+0x330>
 40414e4:	90c00217 	ldw	r3,8(r18)
 40414e8:	89400404 	addi	r5,r17,16
 40414ec:	91000404 	addi	r4,r18,16
 40414f0:	88c00215 	stw	r3,8(r17)
 40414f4:	90800317 	ldw	r2,12(r18)
 40414f8:	88800315 	stw	r2,12(r17)
 40414fc:	31c09126 	beq	r6,r7,4041744 <_realloc_r+0x574>
 4041500:	20800017 	ldw	r2,0(r4)
 4041504:	28800015 	stw	r2,0(r5)
 4041508:	20c00117 	ldw	r3,4(r4)
 404150c:	28c00115 	stw	r3,4(r5)
 4041510:	20800217 	ldw	r2,8(r4)
 4041514:	28800215 	stw	r2,8(r5)
 4041518:	900b883a 	mov	r5,r18
 404151c:	b009883a 	mov	r4,r22
 4041520:	4041f8c0 	call	4041f8c <_free_r>
 4041524:	b009883a 	mov	r4,r22
 4041528:	404321c0 	call	404321c <__malloc_unlock>
 404152c:	003f5e06 	br	40412a8 <_realloc_r+0xd8>
 4041530:	300b883a 	mov	r5,r6
 4041534:	dfc00b17 	ldw	ra,44(sp)
 4041538:	df000a17 	ldw	fp,40(sp)
 404153c:	ddc00917 	ldw	r23,36(sp)
 4041540:	dd800817 	ldw	r22,32(sp)
 4041544:	dd400717 	ldw	r21,28(sp)
 4041548:	dd000617 	ldw	r20,24(sp)
 404154c:	dcc00517 	ldw	r19,20(sp)
 4041550:	dc800417 	ldw	r18,16(sp)
 4041554:	dc400317 	ldw	r17,12(sp)
 4041558:	dc000217 	ldw	r16,8(sp)
 404155c:	dec00c04 	addi	sp,sp,48
 4041560:	404082c1 	jmpi	404082c <_malloc_r>
 4041564:	38800117 	ldw	r2,4(r7)
 4041568:	e54b883a 	add	r5,fp,r21
 404156c:	31000054 	ori	r4,r6,1
 4041570:	1080004c 	andi	r2,r2,1
 4041574:	1704b03a 	or	r2,r2,fp
 4041578:	38800115 	stw	r2,4(r7)
 404157c:	29000115 	stw	r4,4(r5)
 4041580:	2987883a 	add	r3,r5,r6
 4041584:	18800117 	ldw	r2,4(r3)
 4041588:	29400204 	addi	r5,r5,8
 404158c:	b009883a 	mov	r4,r22
 4041590:	10800054 	ori	r2,r2,1
 4041594:	18800115 	stw	r2,4(r3)
 4041598:	4041f8c0 	call	4041f8c <_free_r>
 404159c:	003f3806 	br	4041280 <_realloc_r+0xb0>
 40415a0:	000d883a 	mov	r6,zero
 40415a4:	0009883a 	mov	r4,zero
 40415a8:	003f5d06 	br	4041320 <_realloc_r+0x150>
 40415ac:	30c00217 	ldw	r3,8(r6)
 40415b0:	30800317 	ldw	r2,12(r6)
 40415b4:	800f883a 	mov	r7,r16
 40415b8:	84000204 	addi	r16,r16,8
 40415bc:	10c00215 	stw	r3,8(r2)
 40415c0:	18800315 	stw	r2,12(r3)
 40415c4:	003f2306 	br	4041254 <_realloc_r+0x84>
 40415c8:	8809883a 	mov	r4,r17
 40415cc:	900b883a 	mov	r5,r18
 40415d0:	40410f00 	call	40410f0 <memmove>
 40415d4:	003fd006 	br	4041518 <_realloc_r+0x348>
 40415d8:	30800117 	ldw	r2,4(r6)
 40415dc:	e0c00404 	addi	r3,fp,16
 40415e0:	1108703a 	and	r4,r2,r4
 40415e4:	9905883a 	add	r2,r19,r4
 40415e8:	10ff4d16 	blt	r2,r3,4041320 <_realloc_r+0x150>
 40415ec:	1705c83a 	sub	r2,r2,fp
 40415f0:	870b883a 	add	r5,r16,fp
 40415f4:	10800054 	ori	r2,r2,1
 40415f8:	28800115 	stw	r2,4(r5)
 40415fc:	80c00117 	ldw	r3,4(r16)
 4041600:	00810174 	movhi	r2,1029
 4041604:	10a0cd04 	addi	r2,r2,-31948
 4041608:	b009883a 	mov	r4,r22
 404160c:	18c0004c 	andi	r3,r3,1
 4041610:	e0c6b03a 	or	r3,fp,r3
 4041614:	11400215 	stw	r5,8(r2)
 4041618:	80c00115 	stw	r3,4(r16)
 404161c:	404321c0 	call	404321c <__malloc_unlock>
 4041620:	84400204 	addi	r17,r16,8
 4041624:	003f2006 	br	40412a8 <_realloc_r+0xd8>
 4041628:	98a9883a 	add	r20,r19,r2
 404162c:	2509883a 	add	r4,r4,r20
 4041630:	e0800404 	addi	r2,fp,16
 4041634:	d9000115 	stw	r4,4(sp)
 4041638:	20bf7016 	blt	r4,r2,40413fc <_realloc_r+0x22c>
 404163c:	b8c00317 	ldw	r3,12(r23)
 4041640:	b8800217 	ldw	r2,8(r23)
 4041644:	99bfff04 	addi	r6,r19,-4
 4041648:	01400904 	movi	r5,36
 404164c:	18800215 	stw	r2,8(r3)
 4041650:	10c00315 	stw	r3,12(r2)
 4041654:	bc400204 	addi	r17,r23,8
 4041658:	29804136 	bltu	r5,r6,4041760 <_realloc_r+0x590>
 404165c:	008004c4 	movi	r2,19
 4041660:	9009883a 	mov	r4,r18
 4041664:	880f883a 	mov	r7,r17
 4041668:	11800f2e 	bgeu	r2,r6,40416a8 <_realloc_r+0x4d8>
 404166c:	90800017 	ldw	r2,0(r18)
 4041670:	b9c00404 	addi	r7,r23,16
 4041674:	91000204 	addi	r4,r18,8
 4041678:	b8800215 	stw	r2,8(r23)
 404167c:	90c00117 	ldw	r3,4(r18)
 4041680:	008006c4 	movi	r2,27
 4041684:	b8c00315 	stw	r3,12(r23)
 4041688:	1180072e 	bgeu	r2,r6,40416a8 <_realloc_r+0x4d8>
 404168c:	90c00217 	ldw	r3,8(r18)
 4041690:	b9c00604 	addi	r7,r23,24
 4041694:	91000404 	addi	r4,r18,16
 4041698:	b8c00415 	stw	r3,16(r23)
 404169c:	90800317 	ldw	r2,12(r18)
 40416a0:	b8800515 	stw	r2,20(r23)
 40416a4:	31404026 	beq	r6,r5,40417a8 <_realloc_r+0x5d8>
 40416a8:	20800017 	ldw	r2,0(r4)
 40416ac:	38800015 	stw	r2,0(r7)
 40416b0:	20c00117 	ldw	r3,4(r4)
 40416b4:	38c00115 	stw	r3,4(r7)
 40416b8:	20800217 	ldw	r2,8(r4)
 40416bc:	38800215 	stw	r2,8(r7)
 40416c0:	d8c00117 	ldw	r3,4(sp)
 40416c4:	bf0b883a 	add	r5,r23,fp
 40416c8:	b009883a 	mov	r4,r22
 40416cc:	1f05c83a 	sub	r2,r3,fp
 40416d0:	10800054 	ori	r2,r2,1
 40416d4:	28800115 	stw	r2,4(r5)
 40416d8:	b8c00117 	ldw	r3,4(r23)
 40416dc:	00810174 	movhi	r2,1029
 40416e0:	10a0cd04 	addi	r2,r2,-31948
 40416e4:	11400215 	stw	r5,8(r2)
 40416e8:	18c0004c 	andi	r3,r3,1
 40416ec:	e0c6b03a 	or	r3,fp,r3
 40416f0:	b8c00115 	stw	r3,4(r23)
 40416f4:	404321c0 	call	404321c <__malloc_unlock>
 40416f8:	003eeb06 	br	40412a8 <_realloc_r+0xd8>
 40416fc:	20800117 	ldw	r2,4(r4)
 4041700:	00ffff04 	movi	r3,-4
 4041704:	800f883a 	mov	r7,r16
 4041708:	10c4703a 	and	r2,r2,r3
 404170c:	98a9883a 	add	r20,r19,r2
 4041710:	84000204 	addi	r16,r16,8
 4041714:	003ecf06 	br	4041254 <_realloc_r+0x84>
 4041718:	900b883a 	mov	r5,r18
 404171c:	8009883a 	mov	r4,r16
 4041720:	40410f00 	call	40410f0 <memmove>
 4041724:	dd000017 	ldw	r20,0(sp)
 4041728:	b80f883a 	mov	r7,r23
 404172c:	003ec906 	br	4041254 <_realloc_r+0x84>
 4041730:	900b883a 	mov	r5,r18
 4041734:	8009883a 	mov	r4,r16
 4041738:	40410f00 	call	40410f0 <memmove>
 404173c:	b80f883a 	mov	r7,r23
 4041740:	003ec406 	br	4041254 <_realloc_r+0x84>
 4041744:	90c00417 	ldw	r3,16(r18)
 4041748:	89400604 	addi	r5,r17,24
 404174c:	91000604 	addi	r4,r18,24
 4041750:	88c00415 	stw	r3,16(r17)
 4041754:	90800517 	ldw	r2,20(r18)
 4041758:	88800515 	stw	r2,20(r17)
 404175c:	003f6806 	br	4041500 <_realloc_r+0x330>
 4041760:	900b883a 	mov	r5,r18
 4041764:	8809883a 	mov	r4,r17
 4041768:	40410f00 	call	40410f0 <memmove>
 404176c:	003fd406 	br	40416c0 <_realloc_r+0x4f0>
 4041770:	90c00417 	ldw	r3,16(r18)
 4041774:	91000604 	addi	r4,r18,24
 4041778:	ba000804 	addi	r8,r23,32
 404177c:	b8c00615 	stw	r3,24(r23)
 4041780:	90800517 	ldw	r2,20(r18)
 4041784:	b8800715 	stw	r2,28(r23)
 4041788:	003f1206 	br	40413d4 <_realloc_r+0x204>
 404178c:	90c00417 	ldw	r3,16(r18)
 4041790:	91000604 	addi	r4,r18,24
 4041794:	ba000804 	addi	r8,r23,32
 4041798:	b8c00615 	stw	r3,24(r23)
 404179c:	90800517 	ldw	r2,20(r18)
 40417a0:	b8800715 	stw	r2,28(r23)
 40417a4:	003f3206 	br	4041470 <_realloc_r+0x2a0>
 40417a8:	90c00417 	ldw	r3,16(r18)
 40417ac:	91000604 	addi	r4,r18,24
 40417b0:	b9c00804 	addi	r7,r23,32
 40417b4:	b8c00615 	stw	r3,24(r23)
 40417b8:	90800517 	ldw	r2,20(r18)
 40417bc:	b8800715 	stw	r2,28(r23)
 40417c0:	003fb906 	br	40416a8 <_realloc_r+0x4d8>

040417c4 <_sbrk_r>:
 40417c4:	defffd04 	addi	sp,sp,-12
 40417c8:	dc000015 	stw	r16,0(sp)
 40417cc:	04010174 	movhi	r16,1029
 40417d0:	842d6404 	addi	r16,r16,-19056
 40417d4:	dc400115 	stw	r17,4(sp)
 40417d8:	80000015 	stw	zero,0(r16)
 40417dc:	2023883a 	mov	r17,r4
 40417e0:	2809883a 	mov	r4,r5
 40417e4:	dfc00215 	stw	ra,8(sp)
 40417e8:	404341c0 	call	404341c <sbrk>
 40417ec:	1007883a 	mov	r3,r2
 40417f0:	00bfffc4 	movi	r2,-1
 40417f4:	18800626 	beq	r3,r2,4041810 <_sbrk_r+0x4c>
 40417f8:	1805883a 	mov	r2,r3
 40417fc:	dfc00217 	ldw	ra,8(sp)
 4041800:	dc400117 	ldw	r17,4(sp)
 4041804:	dc000017 	ldw	r16,0(sp)
 4041808:	dec00304 	addi	sp,sp,12
 404180c:	f800283a 	ret
 4041810:	80800017 	ldw	r2,0(r16)
 4041814:	103ff826 	beq	r2,zero,40417f8 <_sbrk_r+0x34>
 4041818:	88800015 	stw	r2,0(r17)
 404181c:	1805883a 	mov	r2,r3
 4041820:	dfc00217 	ldw	ra,8(sp)
 4041824:	dc400117 	ldw	r17,4(sp)
 4041828:	dc000017 	ldw	r16,0(sp)
 404182c:	dec00304 	addi	sp,sp,12
 4041830:	f800283a 	ret

04041834 <__swsetup_r>:
 4041834:	00810174 	movhi	r2,1029
 4041838:	10a68704 	addi	r2,r2,-26084
 404183c:	10c00017 	ldw	r3,0(r2)
 4041840:	defffd04 	addi	sp,sp,-12
 4041844:	dc400115 	stw	r17,4(sp)
 4041848:	dc000015 	stw	r16,0(sp)
 404184c:	dfc00215 	stw	ra,8(sp)
 4041850:	2023883a 	mov	r17,r4
 4041854:	2821883a 	mov	r16,r5
 4041858:	18000226 	beq	r3,zero,4041864 <__swsetup_r+0x30>
 404185c:	18800e17 	ldw	r2,56(r3)
 4041860:	10001f26 	beq	r2,zero,40418e0 <__swsetup_r+0xac>
 4041864:	8100030b 	ldhu	r4,12(r16)
 4041868:	2080020c 	andi	r2,r4,8
 404186c:	10002826 	beq	r2,zero,4041910 <__swsetup_r+0xdc>
 4041870:	81400417 	ldw	r5,16(r16)
 4041874:	28001d26 	beq	r5,zero,40418ec <__swsetup_r+0xb8>
 4041878:	2080004c 	andi	r2,r4,1
 404187c:	1005003a 	cmpeq	r2,r2,zero
 4041880:	10000b26 	beq	r2,zero,40418b0 <__swsetup_r+0x7c>
 4041884:	2080008c 	andi	r2,r4,2
 4041888:	10001226 	beq	r2,zero,40418d4 <__swsetup_r+0xa0>
 404188c:	0005883a 	mov	r2,zero
 4041890:	80800215 	stw	r2,8(r16)
 4041894:	28000b26 	beq	r5,zero,40418c4 <__swsetup_r+0x90>
 4041898:	0005883a 	mov	r2,zero
 404189c:	dfc00217 	ldw	ra,8(sp)
 40418a0:	dc400117 	ldw	r17,4(sp)
 40418a4:	dc000017 	ldw	r16,0(sp)
 40418a8:	dec00304 	addi	sp,sp,12
 40418ac:	f800283a 	ret
 40418b0:	80800517 	ldw	r2,20(r16)
 40418b4:	80000215 	stw	zero,8(r16)
 40418b8:	0085c83a 	sub	r2,zero,r2
 40418bc:	80800615 	stw	r2,24(r16)
 40418c0:	283ff51e 	bne	r5,zero,4041898 <__swsetup_r+0x64>
 40418c4:	2080200c 	andi	r2,r4,128
 40418c8:	103ff326 	beq	r2,zero,4041898 <__swsetup_r+0x64>
 40418cc:	00bfffc4 	movi	r2,-1
 40418d0:	003ff206 	br	404189c <__swsetup_r+0x68>
 40418d4:	80800517 	ldw	r2,20(r16)
 40418d8:	80800215 	stw	r2,8(r16)
 40418dc:	003fed06 	br	4041894 <__swsetup_r+0x60>
 40418e0:	1809883a 	mov	r4,r3
 40418e4:	4041c080 	call	4041c08 <__sinit>
 40418e8:	003fde06 	br	4041864 <__swsetup_r+0x30>
 40418ec:	20c0a00c 	andi	r3,r4,640
 40418f0:	00808004 	movi	r2,512
 40418f4:	18bfe026 	beq	r3,r2,4041878 <__swsetup_r+0x44>
 40418f8:	8809883a 	mov	r4,r17
 40418fc:	800b883a 	mov	r5,r16
 4041900:	40424200 	call	4042420 <__smakebuf_r>
 4041904:	8100030b 	ldhu	r4,12(r16)
 4041908:	81400417 	ldw	r5,16(r16)
 404190c:	003fda06 	br	4041878 <__swsetup_r+0x44>
 4041910:	2080040c 	andi	r2,r4,16
 4041914:	103fed26 	beq	r2,zero,40418cc <__swsetup_r+0x98>
 4041918:	2080010c 	andi	r2,r4,4
 404191c:	10001226 	beq	r2,zero,4041968 <__swsetup_r+0x134>
 4041920:	81400c17 	ldw	r5,48(r16)
 4041924:	28000526 	beq	r5,zero,404193c <__swsetup_r+0x108>
 4041928:	80801004 	addi	r2,r16,64
 404192c:	28800226 	beq	r5,r2,4041938 <__swsetup_r+0x104>
 4041930:	8809883a 	mov	r4,r17
 4041934:	4041f8c0 	call	4041f8c <_free_r>
 4041938:	80000c15 	stw	zero,48(r16)
 404193c:	8080030b 	ldhu	r2,12(r16)
 4041940:	81400417 	ldw	r5,16(r16)
 4041944:	80000115 	stw	zero,4(r16)
 4041948:	10bff6cc 	andi	r2,r2,65499
 404194c:	8080030d 	sth	r2,12(r16)
 4041950:	81400015 	stw	r5,0(r16)
 4041954:	8080030b 	ldhu	r2,12(r16)
 4041958:	10800214 	ori	r2,r2,8
 404195c:	113fffcc 	andi	r4,r2,65535
 4041960:	8080030d 	sth	r2,12(r16)
 4041964:	003fc306 	br	4041874 <__swsetup_r+0x40>
 4041968:	81400417 	ldw	r5,16(r16)
 404196c:	003ff906 	br	4041954 <__swsetup_r+0x120>

04041970 <_fflush_r>:
 4041970:	defffb04 	addi	sp,sp,-20
 4041974:	dcc00315 	stw	r19,12(sp)
 4041978:	dc800215 	stw	r18,8(sp)
 404197c:	dfc00415 	stw	ra,16(sp)
 4041980:	dc400115 	stw	r17,4(sp)
 4041984:	dc000015 	stw	r16,0(sp)
 4041988:	2027883a 	mov	r19,r4
 404198c:	2825883a 	mov	r18,r5
 4041990:	20000226 	beq	r4,zero,404199c <_fflush_r+0x2c>
 4041994:	20800e17 	ldw	r2,56(r4)
 4041998:	10005626 	beq	r2,zero,4041af4 <_fflush_r+0x184>
 404199c:	9100030b 	ldhu	r4,12(r18)
 40419a0:	20ffffcc 	andi	r3,r4,65535
 40419a4:	18e0001c 	xori	r3,r3,32768
 40419a8:	18e00004 	addi	r3,r3,-32768
 40419ac:	1880020c 	andi	r2,r3,8
 40419b0:	1000261e 	bne	r2,zero,4041a4c <_fflush_r+0xdc>
 40419b4:	90c00117 	ldw	r3,4(r18)
 40419b8:	20820014 	ori	r2,r4,2048
 40419bc:	9080030d 	sth	r2,12(r18)
 40419c0:	1009883a 	mov	r4,r2
 40419c4:	00c0400e 	bge	zero,r3,4041ac8 <_fflush_r+0x158>
 40419c8:	92000a17 	ldw	r8,40(r18)
 40419cc:	40004026 	beq	r8,zero,4041ad0 <_fflush_r+0x160>
 40419d0:	2084000c 	andi	r2,r4,4096
 40419d4:	10005326 	beq	r2,zero,4041b24 <_fflush_r+0x1b4>
 40419d8:	94001417 	ldw	r16,80(r18)
 40419dc:	9080030b 	ldhu	r2,12(r18)
 40419e0:	1080010c 	andi	r2,r2,4
 40419e4:	1000481e 	bne	r2,zero,4041b08 <_fflush_r+0x198>
 40419e8:	91400717 	ldw	r5,28(r18)
 40419ec:	9809883a 	mov	r4,r19
 40419f0:	800d883a 	mov	r6,r16
 40419f4:	000f883a 	mov	r7,zero
 40419f8:	403ee83a 	callr	r8
 40419fc:	8080261e 	bne	r16,r2,4041a98 <_fflush_r+0x128>
 4041a00:	9080030b 	ldhu	r2,12(r18)
 4041a04:	91000417 	ldw	r4,16(r18)
 4041a08:	90000115 	stw	zero,4(r18)
 4041a0c:	10bdffcc 	andi	r2,r2,63487
 4041a10:	10ffffcc 	andi	r3,r2,65535
 4041a14:	18c4000c 	andi	r3,r3,4096
 4041a18:	9080030d 	sth	r2,12(r18)
 4041a1c:	91000015 	stw	r4,0(r18)
 4041a20:	18002b26 	beq	r3,zero,4041ad0 <_fflush_r+0x160>
 4041a24:	0007883a 	mov	r3,zero
 4041a28:	1805883a 	mov	r2,r3
 4041a2c:	94001415 	stw	r16,80(r18)
 4041a30:	dfc00417 	ldw	ra,16(sp)
 4041a34:	dcc00317 	ldw	r19,12(sp)
 4041a38:	dc800217 	ldw	r18,8(sp)
 4041a3c:	dc400117 	ldw	r17,4(sp)
 4041a40:	dc000017 	ldw	r16,0(sp)
 4041a44:	dec00504 	addi	sp,sp,20
 4041a48:	f800283a 	ret
 4041a4c:	94400417 	ldw	r17,16(r18)
 4041a50:	88001f26 	beq	r17,zero,4041ad0 <_fflush_r+0x160>
 4041a54:	90800017 	ldw	r2,0(r18)
 4041a58:	18c000cc 	andi	r3,r3,3
 4041a5c:	94400015 	stw	r17,0(r18)
 4041a60:	1461c83a 	sub	r16,r2,r17
 4041a64:	18002526 	beq	r3,zero,4041afc <_fflush_r+0x18c>
 4041a68:	0005883a 	mov	r2,zero
 4041a6c:	90800215 	stw	r2,8(r18)
 4041a70:	0400170e 	bge	zero,r16,4041ad0 <_fflush_r+0x160>
 4041a74:	90c00917 	ldw	r3,36(r18)
 4041a78:	91400717 	ldw	r5,28(r18)
 4041a7c:	880d883a 	mov	r6,r17
 4041a80:	800f883a 	mov	r7,r16
 4041a84:	9809883a 	mov	r4,r19
 4041a88:	183ee83a 	callr	r3
 4041a8c:	88a3883a 	add	r17,r17,r2
 4041a90:	80a1c83a 	sub	r16,r16,r2
 4041a94:	00bff616 	blt	zero,r2,4041a70 <_fflush_r+0x100>
 4041a98:	9080030b 	ldhu	r2,12(r18)
 4041a9c:	00ffffc4 	movi	r3,-1
 4041aa0:	10801014 	ori	r2,r2,64
 4041aa4:	9080030d 	sth	r2,12(r18)
 4041aa8:	1805883a 	mov	r2,r3
 4041aac:	dfc00417 	ldw	ra,16(sp)
 4041ab0:	dcc00317 	ldw	r19,12(sp)
 4041ab4:	dc800217 	ldw	r18,8(sp)
 4041ab8:	dc400117 	ldw	r17,4(sp)
 4041abc:	dc000017 	ldw	r16,0(sp)
 4041ac0:	dec00504 	addi	sp,sp,20
 4041ac4:	f800283a 	ret
 4041ac8:	90800f17 	ldw	r2,60(r18)
 4041acc:	00bfbe16 	blt	zero,r2,40419c8 <_fflush_r+0x58>
 4041ad0:	0007883a 	mov	r3,zero
 4041ad4:	1805883a 	mov	r2,r3
 4041ad8:	dfc00417 	ldw	ra,16(sp)
 4041adc:	dcc00317 	ldw	r19,12(sp)
 4041ae0:	dc800217 	ldw	r18,8(sp)
 4041ae4:	dc400117 	ldw	r17,4(sp)
 4041ae8:	dc000017 	ldw	r16,0(sp)
 4041aec:	dec00504 	addi	sp,sp,20
 4041af0:	f800283a 	ret
 4041af4:	4041c080 	call	4041c08 <__sinit>
 4041af8:	003fa806 	br	404199c <_fflush_r+0x2c>
 4041afc:	90800517 	ldw	r2,20(r18)
 4041b00:	90800215 	stw	r2,8(r18)
 4041b04:	003fda06 	br	4041a70 <_fflush_r+0x100>
 4041b08:	90800117 	ldw	r2,4(r18)
 4041b0c:	90c00c17 	ldw	r3,48(r18)
 4041b10:	80a1c83a 	sub	r16,r16,r2
 4041b14:	183fb426 	beq	r3,zero,40419e8 <_fflush_r+0x78>
 4041b18:	90800f17 	ldw	r2,60(r18)
 4041b1c:	80a1c83a 	sub	r16,r16,r2
 4041b20:	003fb106 	br	40419e8 <_fflush_r+0x78>
 4041b24:	91400717 	ldw	r5,28(r18)
 4041b28:	9809883a 	mov	r4,r19
 4041b2c:	000d883a 	mov	r6,zero
 4041b30:	01c00044 	movi	r7,1
 4041b34:	403ee83a 	callr	r8
 4041b38:	1021883a 	mov	r16,r2
 4041b3c:	00bfffc4 	movi	r2,-1
 4041b40:	80800226 	beq	r16,r2,4041b4c <_fflush_r+0x1dc>
 4041b44:	92000a17 	ldw	r8,40(r18)
 4041b48:	003fa406 	br	40419dc <_fflush_r+0x6c>
 4041b4c:	98c00017 	ldw	r3,0(r19)
 4041b50:	00800744 	movi	r2,29
 4041b54:	18bfde26 	beq	r3,r2,4041ad0 <_fflush_r+0x160>
 4041b58:	9080030b 	ldhu	r2,12(r18)
 4041b5c:	8007883a 	mov	r3,r16
 4041b60:	10801014 	ori	r2,r2,64
 4041b64:	9080030d 	sth	r2,12(r18)
 4041b68:	003fcf06 	br	4041aa8 <_fflush_r+0x138>

04041b6c <fflush>:
 4041b6c:	01410134 	movhi	r5,1028
 4041b70:	29465c04 	addi	r5,r5,6512
 4041b74:	2007883a 	mov	r3,r4
 4041b78:	20000526 	beq	r4,zero,4041b90 <fflush+0x24>
 4041b7c:	00810174 	movhi	r2,1029
 4041b80:	10a68704 	addi	r2,r2,-26084
 4041b84:	11000017 	ldw	r4,0(r2)
 4041b88:	180b883a 	mov	r5,r3
 4041b8c:	40419701 	jmpi	4041970 <_fflush_r>
 4041b90:	00810174 	movhi	r2,1029
 4041b94:	10a68804 	addi	r2,r2,-26080
 4041b98:	11000017 	ldw	r4,0(r2)
 4041b9c:	40422a01 	jmpi	40422a0 <_fwalk_reent>

04041ba0 <std>:
 4041ba0:	00810134 	movhi	r2,1028
 4041ba4:	10899304 	addi	r2,r2,9804
 4041ba8:	20800b15 	stw	r2,44(r4)
 4041bac:	00810134 	movhi	r2,1028
 4041bb0:	1089ce04 	addi	r2,r2,10040
 4041bb4:	20800815 	stw	r2,32(r4)
 4041bb8:	00c10134 	movhi	r3,1028
 4041bbc:	18c9af04 	addi	r3,r3,9916
 4041bc0:	00810134 	movhi	r2,1028
 4041bc4:	10899504 	addi	r2,r2,9812
 4041bc8:	2140030d 	sth	r5,12(r4)
 4041bcc:	2180038d 	sth	r6,14(r4)
 4041bd0:	20c00915 	stw	r3,36(r4)
 4041bd4:	20800a15 	stw	r2,40(r4)
 4041bd8:	20000015 	stw	zero,0(r4)
 4041bdc:	20000115 	stw	zero,4(r4)
 4041be0:	20000215 	stw	zero,8(r4)
 4041be4:	20000415 	stw	zero,16(r4)
 4041be8:	20000515 	stw	zero,20(r4)
 4041bec:	20000615 	stw	zero,24(r4)
 4041bf0:	21000715 	stw	r4,28(r4)
 4041bf4:	f800283a 	ret

04041bf8 <__sfp_lock_acquire>:
 4041bf8:	f800283a 	ret

04041bfc <__sfp_lock_release>:
 4041bfc:	f800283a 	ret

04041c00 <__sinit_lock_acquire>:
 4041c00:	f800283a 	ret

04041c04 <__sinit_lock_release>:
 4041c04:	f800283a 	ret

04041c08 <__sinit>:
 4041c08:	20800e17 	ldw	r2,56(r4)
 4041c0c:	defffd04 	addi	sp,sp,-12
 4041c10:	dc400115 	stw	r17,4(sp)
 4041c14:	dc000015 	stw	r16,0(sp)
 4041c18:	dfc00215 	stw	ra,8(sp)
 4041c1c:	04400044 	movi	r17,1
 4041c20:	01400104 	movi	r5,4
 4041c24:	000d883a 	mov	r6,zero
 4041c28:	2021883a 	mov	r16,r4
 4041c2c:	2200bb04 	addi	r8,r4,748
 4041c30:	200f883a 	mov	r7,r4
 4041c34:	10000526 	beq	r2,zero,4041c4c <__sinit+0x44>
 4041c38:	dfc00217 	ldw	ra,8(sp)
 4041c3c:	dc400117 	ldw	r17,4(sp)
 4041c40:	dc000017 	ldw	r16,0(sp)
 4041c44:	dec00304 	addi	sp,sp,12
 4041c48:	f800283a 	ret
 4041c4c:	21000117 	ldw	r4,4(r4)
 4041c50:	00810134 	movhi	r2,1028
 4041c54:	10873b04 	addi	r2,r2,7404
 4041c58:	00c000c4 	movi	r3,3
 4041c5c:	80800f15 	stw	r2,60(r16)
 4041c60:	80c0b915 	stw	r3,740(r16)
 4041c64:	8200ba15 	stw	r8,744(r16)
 4041c68:	84400e15 	stw	r17,56(r16)
 4041c6c:	8000b815 	stw	zero,736(r16)
 4041c70:	4041ba00 	call	4041ba0 <std>
 4041c74:	81000217 	ldw	r4,8(r16)
 4041c78:	880d883a 	mov	r6,r17
 4041c7c:	800f883a 	mov	r7,r16
 4041c80:	01400284 	movi	r5,10
 4041c84:	4041ba00 	call	4041ba0 <std>
 4041c88:	81000317 	ldw	r4,12(r16)
 4041c8c:	800f883a 	mov	r7,r16
 4041c90:	01400484 	movi	r5,18
 4041c94:	01800084 	movi	r6,2
 4041c98:	dfc00217 	ldw	ra,8(sp)
 4041c9c:	dc400117 	ldw	r17,4(sp)
 4041ca0:	dc000017 	ldw	r16,0(sp)
 4041ca4:	dec00304 	addi	sp,sp,12
 4041ca8:	4041ba01 	jmpi	4041ba0 <std>

04041cac <__fp_lock>:
 4041cac:	0005883a 	mov	r2,zero
 4041cb0:	f800283a 	ret

04041cb4 <__fp_unlock>:
 4041cb4:	0005883a 	mov	r2,zero
 4041cb8:	f800283a 	ret

04041cbc <__fp_unlock_all>:
 4041cbc:	00810174 	movhi	r2,1029
 4041cc0:	10a68704 	addi	r2,r2,-26084
 4041cc4:	11000017 	ldw	r4,0(r2)
 4041cc8:	01410134 	movhi	r5,1028
 4041ccc:	29472d04 	addi	r5,r5,7348
 4041cd0:	40423681 	jmpi	4042368 <_fwalk>

04041cd4 <__fp_lock_all>:
 4041cd4:	00810174 	movhi	r2,1029
 4041cd8:	10a68704 	addi	r2,r2,-26084
 4041cdc:	11000017 	ldw	r4,0(r2)
 4041ce0:	01410134 	movhi	r5,1028
 4041ce4:	29472b04 	addi	r5,r5,7340
 4041ce8:	40423681 	jmpi	4042368 <_fwalk>

04041cec <_cleanup_r>:
 4041cec:	01410134 	movhi	r5,1028
 4041cf0:	294a6404 	addi	r5,r5,10640
 4041cf4:	40423681 	jmpi	4042368 <_fwalk>

04041cf8 <_cleanup>:
 4041cf8:	00810174 	movhi	r2,1029
 4041cfc:	10a68804 	addi	r2,r2,-26080
 4041d00:	11000017 	ldw	r4,0(r2)
 4041d04:	4041cec1 	jmpi	4041cec <_cleanup_r>

04041d08 <__sfmoreglue>:
 4041d08:	defffc04 	addi	sp,sp,-16
 4041d0c:	dc400115 	stw	r17,4(sp)
 4041d10:	2c401724 	muli	r17,r5,92
 4041d14:	dc800215 	stw	r18,8(sp)
 4041d18:	2825883a 	mov	r18,r5
 4041d1c:	89400304 	addi	r5,r17,12
 4041d20:	dc000015 	stw	r16,0(sp)
 4041d24:	dfc00315 	stw	ra,12(sp)
 4041d28:	404082c0 	call	404082c <_malloc_r>
 4041d2c:	0021883a 	mov	r16,zero
 4041d30:	880d883a 	mov	r6,r17
 4041d34:	000b883a 	mov	r5,zero
 4041d38:	10000626 	beq	r2,zero,4041d54 <__sfmoreglue+0x4c>
 4041d3c:	11000304 	addi	r4,r2,12
 4041d40:	14800115 	stw	r18,4(r2)
 4041d44:	10000015 	stw	zero,0(r2)
 4041d48:	11000215 	stw	r4,8(r2)
 4041d4c:	1021883a 	mov	r16,r2
 4041d50:	40425b40 	call	40425b4 <memset>
 4041d54:	8005883a 	mov	r2,r16
 4041d58:	dfc00317 	ldw	ra,12(sp)
 4041d5c:	dc800217 	ldw	r18,8(sp)
 4041d60:	dc400117 	ldw	r17,4(sp)
 4041d64:	dc000017 	ldw	r16,0(sp)
 4041d68:	dec00404 	addi	sp,sp,16
 4041d6c:	f800283a 	ret

04041d70 <__sfp>:
 4041d70:	defffd04 	addi	sp,sp,-12
 4041d74:	00810174 	movhi	r2,1029
 4041d78:	10a68804 	addi	r2,r2,-26080
 4041d7c:	dc000015 	stw	r16,0(sp)
 4041d80:	14000017 	ldw	r16,0(r2)
 4041d84:	dc400115 	stw	r17,4(sp)
 4041d88:	dfc00215 	stw	ra,8(sp)
 4041d8c:	80800e17 	ldw	r2,56(r16)
 4041d90:	2023883a 	mov	r17,r4
 4041d94:	10002626 	beq	r2,zero,4041e30 <__sfp+0xc0>
 4041d98:	8400b804 	addi	r16,r16,736
 4041d9c:	80800117 	ldw	r2,4(r16)
 4041da0:	81000217 	ldw	r4,8(r16)
 4041da4:	10ffffc4 	addi	r3,r2,-1
 4041da8:	18000916 	blt	r3,zero,4041dd0 <__sfp+0x60>
 4041dac:	2080030f 	ldh	r2,12(r4)
 4041db0:	10000b26 	beq	r2,zero,4041de0 <__sfp+0x70>
 4041db4:	017fffc4 	movi	r5,-1
 4041db8:	00000206 	br	4041dc4 <__sfp+0x54>
 4041dbc:	2080030f 	ldh	r2,12(r4)
 4041dc0:	10000726 	beq	r2,zero,4041de0 <__sfp+0x70>
 4041dc4:	18ffffc4 	addi	r3,r3,-1
 4041dc8:	21001704 	addi	r4,r4,92
 4041dcc:	197ffb1e 	bne	r3,r5,4041dbc <__sfp+0x4c>
 4041dd0:	80800017 	ldw	r2,0(r16)
 4041dd4:	10001926 	beq	r2,zero,4041e3c <__sfp+0xcc>
 4041dd8:	1021883a 	mov	r16,r2
 4041ddc:	003fef06 	br	4041d9c <__sfp+0x2c>
 4041de0:	00bfffc4 	movi	r2,-1
 4041de4:	00c00044 	movi	r3,1
 4041de8:	2080038d 	sth	r2,14(r4)
 4041dec:	20c0030d 	sth	r3,12(r4)
 4041df0:	20000015 	stw	zero,0(r4)
 4041df4:	20000215 	stw	zero,8(r4)
 4041df8:	20000115 	stw	zero,4(r4)
 4041dfc:	20000415 	stw	zero,16(r4)
 4041e00:	20000515 	stw	zero,20(r4)
 4041e04:	20000615 	stw	zero,24(r4)
 4041e08:	20000c15 	stw	zero,48(r4)
 4041e0c:	20000d15 	stw	zero,52(r4)
 4041e10:	20001115 	stw	zero,68(r4)
 4041e14:	20001215 	stw	zero,72(r4)
 4041e18:	2005883a 	mov	r2,r4
 4041e1c:	dfc00217 	ldw	ra,8(sp)
 4041e20:	dc400117 	ldw	r17,4(sp)
 4041e24:	dc000017 	ldw	r16,0(sp)
 4041e28:	dec00304 	addi	sp,sp,12
 4041e2c:	f800283a 	ret
 4041e30:	8009883a 	mov	r4,r16
 4041e34:	4041c080 	call	4041c08 <__sinit>
 4041e38:	003fd706 	br	4041d98 <__sfp+0x28>
 4041e3c:	8809883a 	mov	r4,r17
 4041e40:	01400104 	movi	r5,4
 4041e44:	4041d080 	call	4041d08 <__sfmoreglue>
 4041e48:	80800015 	stw	r2,0(r16)
 4041e4c:	103fe21e 	bne	r2,zero,4041dd8 <__sfp+0x68>
 4041e50:	00800304 	movi	r2,12
 4041e54:	0009883a 	mov	r4,zero
 4041e58:	88800015 	stw	r2,0(r17)
 4041e5c:	003fee06 	br	4041e18 <__sfp+0xa8>

04041e60 <_malloc_trim_r>:
 4041e60:	defffb04 	addi	sp,sp,-20
 4041e64:	dcc00315 	stw	r19,12(sp)
 4041e68:	04c10174 	movhi	r19,1029
 4041e6c:	9ce0cd04 	addi	r19,r19,-31948
 4041e70:	dc800215 	stw	r18,8(sp)
 4041e74:	dc400115 	stw	r17,4(sp)
 4041e78:	dc000015 	stw	r16,0(sp)
 4041e7c:	2823883a 	mov	r17,r5
 4041e80:	2025883a 	mov	r18,r4
 4041e84:	dfc00415 	stw	ra,16(sp)
 4041e88:	40431fc0 	call	40431fc <__malloc_lock>
 4041e8c:	98800217 	ldw	r2,8(r19)
 4041e90:	9009883a 	mov	r4,r18
 4041e94:	000b883a 	mov	r5,zero
 4041e98:	10c00117 	ldw	r3,4(r2)
 4041e9c:	00bfff04 	movi	r2,-4
 4041ea0:	18a0703a 	and	r16,r3,r2
 4041ea4:	8463c83a 	sub	r17,r16,r17
 4041ea8:	8c43fbc4 	addi	r17,r17,4079
 4041eac:	8822d33a 	srli	r17,r17,12
 4041eb0:	0083ffc4 	movi	r2,4095
 4041eb4:	8c7fffc4 	addi	r17,r17,-1
 4041eb8:	8822933a 	slli	r17,r17,12
 4041ebc:	1440060e 	bge	r2,r17,4041ed8 <_malloc_trim_r+0x78>
 4041ec0:	40417c40 	call	40417c4 <_sbrk_r>
 4041ec4:	98c00217 	ldw	r3,8(r19)
 4041ec8:	9009883a 	mov	r4,r18
 4041ecc:	044bc83a 	sub	r5,zero,r17
 4041ed0:	80c7883a 	add	r3,r16,r3
 4041ed4:	10c00926 	beq	r2,r3,4041efc <_malloc_trim_r+0x9c>
 4041ed8:	404321c0 	call	404321c <__malloc_unlock>
 4041edc:	0005883a 	mov	r2,zero
 4041ee0:	dfc00417 	ldw	ra,16(sp)
 4041ee4:	dcc00317 	ldw	r19,12(sp)
 4041ee8:	dc800217 	ldw	r18,8(sp)
 4041eec:	dc400117 	ldw	r17,4(sp)
 4041ef0:	dc000017 	ldw	r16,0(sp)
 4041ef4:	dec00504 	addi	sp,sp,20
 4041ef8:	f800283a 	ret
 4041efc:	9009883a 	mov	r4,r18
 4041f00:	40417c40 	call	40417c4 <_sbrk_r>
 4041f04:	844dc83a 	sub	r6,r16,r17
 4041f08:	00ffffc4 	movi	r3,-1
 4041f0c:	9009883a 	mov	r4,r18
 4041f10:	000b883a 	mov	r5,zero
 4041f14:	01c10174 	movhi	r7,1029
 4041f18:	39ed6b04 	addi	r7,r7,-19028
 4041f1c:	31800054 	ori	r6,r6,1
 4041f20:	10c00926 	beq	r2,r3,4041f48 <_malloc_trim_r+0xe8>
 4041f24:	38800017 	ldw	r2,0(r7)
 4041f28:	98c00217 	ldw	r3,8(r19)
 4041f2c:	9009883a 	mov	r4,r18
 4041f30:	1445c83a 	sub	r2,r2,r17
 4041f34:	38800015 	stw	r2,0(r7)
 4041f38:	19800115 	stw	r6,4(r3)
 4041f3c:	404321c0 	call	404321c <__malloc_unlock>
 4041f40:	00800044 	movi	r2,1
 4041f44:	003fe606 	br	4041ee0 <_malloc_trim_r+0x80>
 4041f48:	40417c40 	call	40417c4 <_sbrk_r>
 4041f4c:	99800217 	ldw	r6,8(r19)
 4041f50:	100f883a 	mov	r7,r2
 4041f54:	9009883a 	mov	r4,r18
 4041f58:	1187c83a 	sub	r3,r2,r6
 4041f5c:	008003c4 	movi	r2,15
 4041f60:	19400054 	ori	r5,r3,1
 4041f64:	10ffdc0e 	bge	r2,r3,4041ed8 <_malloc_trim_r+0x78>
 4041f68:	00810174 	movhi	r2,1029
 4041f6c:	10a68a04 	addi	r2,r2,-26072
 4041f70:	10c00017 	ldw	r3,0(r2)
 4041f74:	00810174 	movhi	r2,1029
 4041f78:	10ad6b04 	addi	r2,r2,-19028
 4041f7c:	31400115 	stw	r5,4(r6)
 4041f80:	38c7c83a 	sub	r3,r7,r3
 4041f84:	10c00015 	stw	r3,0(r2)
 4041f88:	003fd306 	br	4041ed8 <_malloc_trim_r+0x78>

04041f8c <_free_r>:
 4041f8c:	defffd04 	addi	sp,sp,-12
 4041f90:	dc400115 	stw	r17,4(sp)
 4041f94:	dc000015 	stw	r16,0(sp)
 4041f98:	dfc00215 	stw	ra,8(sp)
 4041f9c:	2821883a 	mov	r16,r5
 4041fa0:	2023883a 	mov	r17,r4
 4041fa4:	28005a26 	beq	r5,zero,4042110 <_free_r+0x184>
 4041fa8:	40431fc0 	call	40431fc <__malloc_lock>
 4041fac:	823ffe04 	addi	r8,r16,-8
 4041fb0:	41400117 	ldw	r5,4(r8)
 4041fb4:	00bfff84 	movi	r2,-2
 4041fb8:	02810174 	movhi	r10,1029
 4041fbc:	52a0cd04 	addi	r10,r10,-31948
 4041fc0:	288e703a 	and	r7,r5,r2
 4041fc4:	41cd883a 	add	r6,r8,r7
 4041fc8:	30c00117 	ldw	r3,4(r6)
 4041fcc:	51000217 	ldw	r4,8(r10)
 4041fd0:	00bfff04 	movi	r2,-4
 4041fd4:	1892703a 	and	r9,r3,r2
 4041fd8:	5017883a 	mov	r11,r10
 4041fdc:	31006726 	beq	r6,r4,404217c <_free_r+0x1f0>
 4041fe0:	2880004c 	andi	r2,r5,1
 4041fe4:	1005003a 	cmpeq	r2,r2,zero
 4041fe8:	32400115 	stw	r9,4(r6)
 4041fec:	10001a1e 	bne	r2,zero,4042058 <_free_r+0xcc>
 4041ff0:	000b883a 	mov	r5,zero
 4041ff4:	3247883a 	add	r3,r6,r9
 4041ff8:	18800117 	ldw	r2,4(r3)
 4041ffc:	1080004c 	andi	r2,r2,1
 4042000:	1000231e 	bne	r2,zero,4042090 <_free_r+0x104>
 4042004:	280ac03a 	cmpne	r5,r5,zero
 4042008:	3a4f883a 	add	r7,r7,r9
 404200c:	2800451e 	bne	r5,zero,4042124 <_free_r+0x198>
 4042010:	31000217 	ldw	r4,8(r6)
 4042014:	00810174 	movhi	r2,1029
 4042018:	10a0cf04 	addi	r2,r2,-31940
 404201c:	20807b26 	beq	r4,r2,404220c <_free_r+0x280>
 4042020:	30800317 	ldw	r2,12(r6)
 4042024:	3a07883a 	add	r3,r7,r8
 4042028:	19c00015 	stw	r7,0(r3)
 404202c:	11000215 	stw	r4,8(r2)
 4042030:	20800315 	stw	r2,12(r4)
 4042034:	38800054 	ori	r2,r7,1
 4042038:	40800115 	stw	r2,4(r8)
 404203c:	28001a26 	beq	r5,zero,40420a8 <_free_r+0x11c>
 4042040:	8809883a 	mov	r4,r17
 4042044:	dfc00217 	ldw	ra,8(sp)
 4042048:	dc400117 	ldw	r17,4(sp)
 404204c:	dc000017 	ldw	r16,0(sp)
 4042050:	dec00304 	addi	sp,sp,12
 4042054:	404321c1 	jmpi	404321c <__malloc_unlock>
 4042058:	80bffe17 	ldw	r2,-8(r16)
 404205c:	50c00204 	addi	r3,r10,8
 4042060:	4091c83a 	sub	r8,r8,r2
 4042064:	41000217 	ldw	r4,8(r8)
 4042068:	388f883a 	add	r7,r7,r2
 404206c:	20c06126 	beq	r4,r3,40421f4 <_free_r+0x268>
 4042070:	40800317 	ldw	r2,12(r8)
 4042074:	3247883a 	add	r3,r6,r9
 4042078:	000b883a 	mov	r5,zero
 404207c:	11000215 	stw	r4,8(r2)
 4042080:	20800315 	stw	r2,12(r4)
 4042084:	18800117 	ldw	r2,4(r3)
 4042088:	1080004c 	andi	r2,r2,1
 404208c:	103fdd26 	beq	r2,zero,4042004 <_free_r+0x78>
 4042090:	38800054 	ori	r2,r7,1
 4042094:	3a07883a 	add	r3,r7,r8
 4042098:	280ac03a 	cmpne	r5,r5,zero
 404209c:	40800115 	stw	r2,4(r8)
 40420a0:	19c00015 	stw	r7,0(r3)
 40420a4:	283fe61e 	bne	r5,zero,4042040 <_free_r+0xb4>
 40420a8:	00807fc4 	movi	r2,511
 40420ac:	11c01f2e 	bgeu	r2,r7,404212c <_free_r+0x1a0>
 40420b0:	3806d27a 	srli	r3,r7,9
 40420b4:	1800481e 	bne	r3,zero,40421d8 <_free_r+0x24c>
 40420b8:	3804d0fa 	srli	r2,r7,3
 40420bc:	100690fa 	slli	r3,r2,3
 40420c0:	1acd883a 	add	r6,r3,r11
 40420c4:	31400217 	ldw	r5,8(r6)
 40420c8:	31405926 	beq	r6,r5,4042230 <_free_r+0x2a4>
 40420cc:	28800117 	ldw	r2,4(r5)
 40420d0:	00ffff04 	movi	r3,-4
 40420d4:	10c4703a 	and	r2,r2,r3
 40420d8:	3880022e 	bgeu	r7,r2,40420e4 <_free_r+0x158>
 40420dc:	29400217 	ldw	r5,8(r5)
 40420e0:	317ffa1e 	bne	r6,r5,40420cc <_free_r+0x140>
 40420e4:	29800317 	ldw	r6,12(r5)
 40420e8:	41800315 	stw	r6,12(r8)
 40420ec:	41400215 	stw	r5,8(r8)
 40420f0:	8809883a 	mov	r4,r17
 40420f4:	2a000315 	stw	r8,12(r5)
 40420f8:	32000215 	stw	r8,8(r6)
 40420fc:	dfc00217 	ldw	ra,8(sp)
 4042100:	dc400117 	ldw	r17,4(sp)
 4042104:	dc000017 	ldw	r16,0(sp)
 4042108:	dec00304 	addi	sp,sp,12
 404210c:	404321c1 	jmpi	404321c <__malloc_unlock>
 4042110:	dfc00217 	ldw	ra,8(sp)
 4042114:	dc400117 	ldw	r17,4(sp)
 4042118:	dc000017 	ldw	r16,0(sp)
 404211c:	dec00304 	addi	sp,sp,12
 4042120:	f800283a 	ret
 4042124:	31000217 	ldw	r4,8(r6)
 4042128:	003fbd06 	br	4042020 <_free_r+0x94>
 404212c:	3806d0fa 	srli	r3,r7,3
 4042130:	00800044 	movi	r2,1
 4042134:	51400117 	ldw	r5,4(r10)
 4042138:	180890fa 	slli	r4,r3,3
 404213c:	1807d0ba 	srai	r3,r3,2
 4042140:	22c9883a 	add	r4,r4,r11
 4042144:	21800217 	ldw	r6,8(r4)
 4042148:	10c4983a 	sll	r2,r2,r3
 404214c:	41000315 	stw	r4,12(r8)
 4042150:	41800215 	stw	r6,8(r8)
 4042154:	288ab03a 	or	r5,r5,r2
 4042158:	22000215 	stw	r8,8(r4)
 404215c:	8809883a 	mov	r4,r17
 4042160:	51400115 	stw	r5,4(r10)
 4042164:	32000315 	stw	r8,12(r6)
 4042168:	dfc00217 	ldw	ra,8(sp)
 404216c:	dc400117 	ldw	r17,4(sp)
 4042170:	dc000017 	ldw	r16,0(sp)
 4042174:	dec00304 	addi	sp,sp,12
 4042178:	404321c1 	jmpi	404321c <__malloc_unlock>
 404217c:	2880004c 	andi	r2,r5,1
 4042180:	3a4d883a 	add	r6,r7,r9
 4042184:	1000071e 	bne	r2,zero,40421a4 <_free_r+0x218>
 4042188:	80bffe17 	ldw	r2,-8(r16)
 404218c:	4091c83a 	sub	r8,r8,r2
 4042190:	41000317 	ldw	r4,12(r8)
 4042194:	40c00217 	ldw	r3,8(r8)
 4042198:	308d883a 	add	r6,r6,r2
 404219c:	20c00215 	stw	r3,8(r4)
 40421a0:	19000315 	stw	r4,12(r3)
 40421a4:	00810174 	movhi	r2,1029
 40421a8:	10a68904 	addi	r2,r2,-26076
 40421ac:	11000017 	ldw	r4,0(r2)
 40421b0:	30c00054 	ori	r3,r6,1
 40421b4:	52000215 	stw	r8,8(r10)
 40421b8:	40c00115 	stw	r3,4(r8)
 40421bc:	313fa036 	bltu	r6,r4,4042040 <_free_r+0xb4>
 40421c0:	00810174 	movhi	r2,1029
 40421c4:	10ad6104 	addi	r2,r2,-19068
 40421c8:	11400017 	ldw	r5,0(r2)
 40421cc:	8809883a 	mov	r4,r17
 40421d0:	4041e600 	call	4041e60 <_malloc_trim_r>
 40421d4:	003f9a06 	br	4042040 <_free_r+0xb4>
 40421d8:	00800104 	movi	r2,4
 40421dc:	10c0072e 	bgeu	r2,r3,40421fc <_free_r+0x270>
 40421e0:	00800504 	movi	r2,20
 40421e4:	10c01936 	bltu	r2,r3,404224c <_free_r+0x2c0>
 40421e8:	188016c4 	addi	r2,r3,91
 40421ec:	100690fa 	slli	r3,r2,3
 40421f0:	003fb306 	br	40420c0 <_free_r+0x134>
 40421f4:	01400044 	movi	r5,1
 40421f8:	003f7e06 	br	4041ff4 <_free_r+0x68>
 40421fc:	3804d1ba 	srli	r2,r7,6
 4042200:	10800e04 	addi	r2,r2,56
 4042204:	100690fa 	slli	r3,r2,3
 4042208:	003fad06 	br	40420c0 <_free_r+0x134>
 404220c:	22000315 	stw	r8,12(r4)
 4042210:	22000215 	stw	r8,8(r4)
 4042214:	3a05883a 	add	r2,r7,r8
 4042218:	38c00054 	ori	r3,r7,1
 404221c:	11c00015 	stw	r7,0(r2)
 4042220:	41000215 	stw	r4,8(r8)
 4042224:	40c00115 	stw	r3,4(r8)
 4042228:	41000315 	stw	r4,12(r8)
 404222c:	003f8406 	br	4042040 <_free_r+0xb4>
 4042230:	1005d0ba 	srai	r2,r2,2
 4042234:	00c00044 	movi	r3,1
 4042238:	51000117 	ldw	r4,4(r10)
 404223c:	1886983a 	sll	r3,r3,r2
 4042240:	20c8b03a 	or	r4,r4,r3
 4042244:	51000115 	stw	r4,4(r10)
 4042248:	003fa706 	br	40420e8 <_free_r+0x15c>
 404224c:	00801504 	movi	r2,84
 4042250:	10c00436 	bltu	r2,r3,4042264 <_free_r+0x2d8>
 4042254:	3804d33a 	srli	r2,r7,12
 4042258:	10801b84 	addi	r2,r2,110
 404225c:	100690fa 	slli	r3,r2,3
 4042260:	003f9706 	br	40420c0 <_free_r+0x134>
 4042264:	00805504 	movi	r2,340
 4042268:	10c00436 	bltu	r2,r3,404227c <_free_r+0x2f0>
 404226c:	3804d3fa 	srli	r2,r7,15
 4042270:	10801dc4 	addi	r2,r2,119
 4042274:	100690fa 	slli	r3,r2,3
 4042278:	003f9106 	br	40420c0 <_free_r+0x134>
 404227c:	00815504 	movi	r2,1364
 4042280:	10c0032e 	bgeu	r2,r3,4042290 <_free_r+0x304>
 4042284:	00801f84 	movi	r2,126
 4042288:	00c0fc04 	movi	r3,1008
 404228c:	003f8c06 	br	40420c0 <_free_r+0x134>
 4042290:	3804d4ba 	srli	r2,r7,18
 4042294:	10801f04 	addi	r2,r2,124
 4042298:	100690fa 	slli	r3,r2,3
 404229c:	003f8806 	br	40420c0 <_free_r+0x134>

040422a0 <_fwalk_reent>:
 40422a0:	defff704 	addi	sp,sp,-36
 40422a4:	dcc00315 	stw	r19,12(sp)
 40422a8:	24c0b804 	addi	r19,r4,736
 40422ac:	dd800615 	stw	r22,24(sp)
 40422b0:	dd400515 	stw	r21,20(sp)
 40422b4:	dfc00815 	stw	ra,32(sp)
 40422b8:	ddc00715 	stw	r23,28(sp)
 40422bc:	dd000415 	stw	r20,16(sp)
 40422c0:	dc800215 	stw	r18,8(sp)
 40422c4:	dc400115 	stw	r17,4(sp)
 40422c8:	dc000015 	stw	r16,0(sp)
 40422cc:	202b883a 	mov	r21,r4
 40422d0:	282d883a 	mov	r22,r5
 40422d4:	4041bf80 	call	4041bf8 <__sfp_lock_acquire>
 40422d8:	98002126 	beq	r19,zero,4042360 <_fwalk_reent+0xc0>
 40422dc:	002f883a 	mov	r23,zero
 40422e0:	9c800117 	ldw	r18,4(r19)
 40422e4:	9c000217 	ldw	r16,8(r19)
 40422e8:	90bfffc4 	addi	r2,r18,-1
 40422ec:	10000d16 	blt	r2,zero,4042324 <_fwalk_reent+0x84>
 40422f0:	0023883a 	mov	r17,zero
 40422f4:	053fffc4 	movi	r20,-1
 40422f8:	8080030f 	ldh	r2,12(r16)
 40422fc:	8c400044 	addi	r17,r17,1
 4042300:	10000626 	beq	r2,zero,404231c <_fwalk_reent+0x7c>
 4042304:	8080038f 	ldh	r2,14(r16)
 4042308:	800b883a 	mov	r5,r16
 404230c:	a809883a 	mov	r4,r21
 4042310:	15000226 	beq	r2,r20,404231c <_fwalk_reent+0x7c>
 4042314:	b03ee83a 	callr	r22
 4042318:	b8aeb03a 	or	r23,r23,r2
 404231c:	84001704 	addi	r16,r16,92
 4042320:	947ff51e 	bne	r18,r17,40422f8 <_fwalk_reent+0x58>
 4042324:	9cc00017 	ldw	r19,0(r19)
 4042328:	983fed1e 	bne	r19,zero,40422e0 <_fwalk_reent+0x40>
 404232c:	4041bfc0 	call	4041bfc <__sfp_lock_release>
 4042330:	b805883a 	mov	r2,r23
 4042334:	dfc00817 	ldw	ra,32(sp)
 4042338:	ddc00717 	ldw	r23,28(sp)
 404233c:	dd800617 	ldw	r22,24(sp)
 4042340:	dd400517 	ldw	r21,20(sp)
 4042344:	dd000417 	ldw	r20,16(sp)
 4042348:	dcc00317 	ldw	r19,12(sp)
 404234c:	dc800217 	ldw	r18,8(sp)
 4042350:	dc400117 	ldw	r17,4(sp)
 4042354:	dc000017 	ldw	r16,0(sp)
 4042358:	dec00904 	addi	sp,sp,36
 404235c:	f800283a 	ret
 4042360:	002f883a 	mov	r23,zero
 4042364:	003ff106 	br	404232c <_fwalk_reent+0x8c>

04042368 <_fwalk>:
 4042368:	defff804 	addi	sp,sp,-32
 404236c:	dcc00315 	stw	r19,12(sp)
 4042370:	24c0b804 	addi	r19,r4,736
 4042374:	dd400515 	stw	r21,20(sp)
 4042378:	dfc00715 	stw	ra,28(sp)
 404237c:	dd800615 	stw	r22,24(sp)
 4042380:	dd000415 	stw	r20,16(sp)
 4042384:	dc800215 	stw	r18,8(sp)
 4042388:	dc400115 	stw	r17,4(sp)
 404238c:	dc000015 	stw	r16,0(sp)
 4042390:	282b883a 	mov	r21,r5
 4042394:	4041bf80 	call	4041bf8 <__sfp_lock_acquire>
 4042398:	98001f26 	beq	r19,zero,4042418 <_fwalk+0xb0>
 404239c:	002d883a 	mov	r22,zero
 40423a0:	9c800117 	ldw	r18,4(r19)
 40423a4:	9c000217 	ldw	r16,8(r19)
 40423a8:	90bfffc4 	addi	r2,r18,-1
 40423ac:	10000c16 	blt	r2,zero,40423e0 <_fwalk+0x78>
 40423b0:	0023883a 	mov	r17,zero
 40423b4:	053fffc4 	movi	r20,-1
 40423b8:	8080030f 	ldh	r2,12(r16)
 40423bc:	8c400044 	addi	r17,r17,1
 40423c0:	10000526 	beq	r2,zero,40423d8 <_fwalk+0x70>
 40423c4:	8080038f 	ldh	r2,14(r16)
 40423c8:	8009883a 	mov	r4,r16
 40423cc:	15000226 	beq	r2,r20,40423d8 <_fwalk+0x70>
 40423d0:	a83ee83a 	callr	r21
 40423d4:	b0acb03a 	or	r22,r22,r2
 40423d8:	84001704 	addi	r16,r16,92
 40423dc:	947ff61e 	bne	r18,r17,40423b8 <_fwalk+0x50>
 40423e0:	9cc00017 	ldw	r19,0(r19)
 40423e4:	983fee1e 	bne	r19,zero,40423a0 <_fwalk+0x38>
 40423e8:	4041bfc0 	call	4041bfc <__sfp_lock_release>
 40423ec:	b005883a 	mov	r2,r22
 40423f0:	dfc00717 	ldw	ra,28(sp)
 40423f4:	dd800617 	ldw	r22,24(sp)
 40423f8:	dd400517 	ldw	r21,20(sp)
 40423fc:	dd000417 	ldw	r20,16(sp)
 4042400:	dcc00317 	ldw	r19,12(sp)
 4042404:	dc800217 	ldw	r18,8(sp)
 4042408:	dc400117 	ldw	r17,4(sp)
 404240c:	dc000017 	ldw	r16,0(sp)
 4042410:	dec00804 	addi	sp,sp,32
 4042414:	f800283a 	ret
 4042418:	002d883a 	mov	r22,zero
 404241c:	003ff206 	br	40423e8 <_fwalk+0x80>

04042420 <__smakebuf_r>:
 4042420:	2880030b 	ldhu	r2,12(r5)
 4042424:	deffed04 	addi	sp,sp,-76
 4042428:	dc401015 	stw	r17,64(sp)
 404242c:	1080008c 	andi	r2,r2,2
 4042430:	dc000f15 	stw	r16,60(sp)
 4042434:	dfc01215 	stw	ra,72(sp)
 4042438:	dc801115 	stw	r18,68(sp)
 404243c:	2821883a 	mov	r16,r5
 4042440:	2023883a 	mov	r17,r4
 4042444:	10000b26 	beq	r2,zero,4042474 <__smakebuf_r+0x54>
 4042448:	28c010c4 	addi	r3,r5,67
 404244c:	00800044 	movi	r2,1
 4042450:	28800515 	stw	r2,20(r5)
 4042454:	28c00415 	stw	r3,16(r5)
 4042458:	28c00015 	stw	r3,0(r5)
 404245c:	dfc01217 	ldw	ra,72(sp)
 4042460:	dc801117 	ldw	r18,68(sp)
 4042464:	dc401017 	ldw	r17,64(sp)
 4042468:	dc000f17 	ldw	r16,60(sp)
 404246c:	dec01304 	addi	sp,sp,76
 4042470:	f800283a 	ret
 4042474:	2940038f 	ldh	r5,14(r5)
 4042478:	28002116 	blt	r5,zero,4042500 <__smakebuf_r+0xe0>
 404247c:	d80d883a 	mov	r6,sp
 4042480:	40429a40 	call	40429a4 <_fstat_r>
 4042484:	10001e16 	blt	r2,zero,4042500 <__smakebuf_r+0xe0>
 4042488:	d8800117 	ldw	r2,4(sp)
 404248c:	00e00014 	movui	r3,32768
 4042490:	113c000c 	andi	r4,r2,61440
 4042494:	20c03126 	beq	r4,r3,404255c <__smakebuf_r+0x13c>
 4042498:	8080030b 	ldhu	r2,12(r16)
 404249c:	00c80004 	movi	r3,8192
 40424a0:	10820014 	ori	r2,r2,2048
 40424a4:	8080030d 	sth	r2,12(r16)
 40424a8:	20c01e26 	beq	r4,r3,4042524 <__smakebuf_r+0x104>
 40424ac:	04810004 	movi	r18,1024
 40424b0:	8809883a 	mov	r4,r17
 40424b4:	900b883a 	mov	r5,r18
 40424b8:	404082c0 	call	404082c <_malloc_r>
 40424bc:	1009883a 	mov	r4,r2
 40424c0:	10003126 	beq	r2,zero,4042588 <__smakebuf_r+0x168>
 40424c4:	80c0030b 	ldhu	r3,12(r16)
 40424c8:	00810134 	movhi	r2,1028
 40424cc:	10873b04 	addi	r2,r2,7404
 40424d0:	88800f15 	stw	r2,60(r17)
 40424d4:	18c02014 	ori	r3,r3,128
 40424d8:	84800515 	stw	r18,20(r16)
 40424dc:	80c0030d 	sth	r3,12(r16)
 40424e0:	81000415 	stw	r4,16(r16)
 40424e4:	81000015 	stw	r4,0(r16)
 40424e8:	dfc01217 	ldw	ra,72(sp)
 40424ec:	dc801117 	ldw	r18,68(sp)
 40424f0:	dc401017 	ldw	r17,64(sp)
 40424f4:	dc000f17 	ldw	r16,60(sp)
 40424f8:	dec01304 	addi	sp,sp,76
 40424fc:	f800283a 	ret
 4042500:	80c0030b 	ldhu	r3,12(r16)
 4042504:	1880200c 	andi	r2,r3,128
 4042508:	10000426 	beq	r2,zero,404251c <__smakebuf_r+0xfc>
 404250c:	04801004 	movi	r18,64
 4042510:	18820014 	ori	r2,r3,2048
 4042514:	8080030d 	sth	r2,12(r16)
 4042518:	003fe506 	br	40424b0 <__smakebuf_r+0x90>
 404251c:	04810004 	movi	r18,1024
 4042520:	003ffb06 	br	4042510 <__smakebuf_r+0xf0>
 4042524:	8140038f 	ldh	r5,14(r16)
 4042528:	8809883a 	mov	r4,r17
 404252c:	4042a180 	call	4042a18 <_isatty_r>
 4042530:	103fde26 	beq	r2,zero,40424ac <__smakebuf_r+0x8c>
 4042534:	8080030b 	ldhu	r2,12(r16)
 4042538:	80c010c4 	addi	r3,r16,67
 404253c:	04810004 	movi	r18,1024
 4042540:	10800054 	ori	r2,r2,1
 4042544:	8080030d 	sth	r2,12(r16)
 4042548:	00800044 	movi	r2,1
 404254c:	80c00415 	stw	r3,16(r16)
 4042550:	80800515 	stw	r2,20(r16)
 4042554:	80c00015 	stw	r3,0(r16)
 4042558:	003fd506 	br	40424b0 <__smakebuf_r+0x90>
 404255c:	80c00a17 	ldw	r3,40(r16)
 4042560:	00810134 	movhi	r2,1028
 4042564:	10899504 	addi	r2,r2,9812
 4042568:	18bfcb1e 	bne	r3,r2,4042498 <__smakebuf_r+0x78>
 404256c:	8080030b 	ldhu	r2,12(r16)
 4042570:	00c10004 	movi	r3,1024
 4042574:	1825883a 	mov	r18,r3
 4042578:	10c4b03a 	or	r2,r2,r3
 404257c:	8080030d 	sth	r2,12(r16)
 4042580:	80c01315 	stw	r3,76(r16)
 4042584:	003fca06 	br	40424b0 <__smakebuf_r+0x90>
 4042588:	8100030b 	ldhu	r4,12(r16)
 404258c:	2080800c 	andi	r2,r4,512
 4042590:	103fb21e 	bne	r2,zero,404245c <__smakebuf_r+0x3c>
 4042594:	80c010c4 	addi	r3,r16,67
 4042598:	21000094 	ori	r4,r4,2
 404259c:	00800044 	movi	r2,1
 40425a0:	80800515 	stw	r2,20(r16)
 40425a4:	8100030d 	sth	r4,12(r16)
 40425a8:	80c00415 	stw	r3,16(r16)
 40425ac:	80c00015 	stw	r3,0(r16)
 40425b0:	003faa06 	br	404245c <__smakebuf_r+0x3c>

040425b4 <memset>:
 40425b4:	008000c4 	movi	r2,3
 40425b8:	29403fcc 	andi	r5,r5,255
 40425bc:	2007883a 	mov	r3,r4
 40425c0:	1180022e 	bgeu	r2,r6,40425cc <memset+0x18>
 40425c4:	2084703a 	and	r2,r4,r2
 40425c8:	10000826 	beq	r2,zero,40425ec <memset+0x38>
 40425cc:	30000526 	beq	r6,zero,40425e4 <memset+0x30>
 40425d0:	2805883a 	mov	r2,r5
 40425d4:	30cd883a 	add	r6,r6,r3
 40425d8:	18800005 	stb	r2,0(r3)
 40425dc:	18c00044 	addi	r3,r3,1
 40425e0:	19bffd1e 	bne	r3,r6,40425d8 <memset+0x24>
 40425e4:	2005883a 	mov	r2,r4
 40425e8:	f800283a 	ret
 40425ec:	2804923a 	slli	r2,r5,8
 40425f0:	020003c4 	movi	r8,15
 40425f4:	200f883a 	mov	r7,r4
 40425f8:	2884b03a 	or	r2,r5,r2
 40425fc:	1006943a 	slli	r3,r2,16
 4042600:	10c6b03a 	or	r3,r2,r3
 4042604:	41800a2e 	bgeu	r8,r6,4042630 <memset+0x7c>
 4042608:	4005883a 	mov	r2,r8
 404260c:	31bffc04 	addi	r6,r6,-16
 4042610:	38c00015 	stw	r3,0(r7)
 4042614:	38c00115 	stw	r3,4(r7)
 4042618:	38c00215 	stw	r3,8(r7)
 404261c:	38c00315 	stw	r3,12(r7)
 4042620:	39c00404 	addi	r7,r7,16
 4042624:	11bff936 	bltu	r2,r6,404260c <memset+0x58>
 4042628:	008000c4 	movi	r2,3
 404262c:	1180052e 	bgeu	r2,r6,4042644 <memset+0x90>
 4042630:	31bfff04 	addi	r6,r6,-4
 4042634:	008000c4 	movi	r2,3
 4042638:	38c00015 	stw	r3,0(r7)
 404263c:	39c00104 	addi	r7,r7,4
 4042640:	11bffb36 	bltu	r2,r6,4042630 <memset+0x7c>
 4042644:	3807883a 	mov	r3,r7
 4042648:	003fe006 	br	40425cc <memset+0x18>

0404264c <__sclose>:
 404264c:	2940038f 	ldh	r5,14(r5)
 4042650:	40428101 	jmpi	4042810 <_close_r>

04042654 <__sseek>:
 4042654:	defffe04 	addi	sp,sp,-8
 4042658:	dc000015 	stw	r16,0(sp)
 404265c:	2821883a 	mov	r16,r5
 4042660:	2940038f 	ldh	r5,14(r5)
 4042664:	dfc00115 	stw	ra,4(sp)
 4042668:	4042a880 	call	4042a88 <_lseek_r>
 404266c:	1007883a 	mov	r3,r2
 4042670:	00bfffc4 	movi	r2,-1
 4042674:	18800926 	beq	r3,r2,404269c <__sseek+0x48>
 4042678:	8080030b 	ldhu	r2,12(r16)
 404267c:	80c01415 	stw	r3,80(r16)
 4042680:	10840014 	ori	r2,r2,4096
 4042684:	8080030d 	sth	r2,12(r16)
 4042688:	1805883a 	mov	r2,r3
 404268c:	dfc00117 	ldw	ra,4(sp)
 4042690:	dc000017 	ldw	r16,0(sp)
 4042694:	dec00204 	addi	sp,sp,8
 4042698:	f800283a 	ret
 404269c:	8080030b 	ldhu	r2,12(r16)
 40426a0:	10bbffcc 	andi	r2,r2,61439
 40426a4:	8080030d 	sth	r2,12(r16)
 40426a8:	1805883a 	mov	r2,r3
 40426ac:	dfc00117 	ldw	ra,4(sp)
 40426b0:	dc000017 	ldw	r16,0(sp)
 40426b4:	dec00204 	addi	sp,sp,8
 40426b8:	f800283a 	ret

040426bc <__swrite>:
 40426bc:	2880030b 	ldhu	r2,12(r5)
 40426c0:	defffb04 	addi	sp,sp,-20
 40426c4:	dcc00315 	stw	r19,12(sp)
 40426c8:	1080400c 	andi	r2,r2,256
 40426cc:	dc800215 	stw	r18,8(sp)
 40426d0:	dc400115 	stw	r17,4(sp)
 40426d4:	dc000015 	stw	r16,0(sp)
 40426d8:	3027883a 	mov	r19,r6
 40426dc:	3825883a 	mov	r18,r7
 40426e0:	dfc00415 	stw	ra,16(sp)
 40426e4:	2821883a 	mov	r16,r5
 40426e8:	000d883a 	mov	r6,zero
 40426ec:	01c00084 	movi	r7,2
 40426f0:	2023883a 	mov	r17,r4
 40426f4:	10000226 	beq	r2,zero,4042700 <__swrite+0x44>
 40426f8:	2940038f 	ldh	r5,14(r5)
 40426fc:	4042a880 	call	4042a88 <_lseek_r>
 4042700:	8080030b 	ldhu	r2,12(r16)
 4042704:	8140038f 	ldh	r5,14(r16)
 4042708:	8809883a 	mov	r4,r17
 404270c:	10bbffcc 	andi	r2,r2,61439
 4042710:	980d883a 	mov	r6,r19
 4042714:	900f883a 	mov	r7,r18
 4042718:	8080030d 	sth	r2,12(r16)
 404271c:	dfc00417 	ldw	ra,16(sp)
 4042720:	dcc00317 	ldw	r19,12(sp)
 4042724:	dc800217 	ldw	r18,8(sp)
 4042728:	dc400117 	ldw	r17,4(sp)
 404272c:	dc000017 	ldw	r16,0(sp)
 4042730:	dec00504 	addi	sp,sp,20
 4042734:	40427981 	jmpi	4042798 <_write_r>

04042738 <__sread>:
 4042738:	defffe04 	addi	sp,sp,-8
 404273c:	dc000015 	stw	r16,0(sp)
 4042740:	2821883a 	mov	r16,r5
 4042744:	2940038f 	ldh	r5,14(r5)
 4042748:	dfc00115 	stw	ra,4(sp)
 404274c:	4042b000 	call	4042b00 <_read_r>
 4042750:	1007883a 	mov	r3,r2
 4042754:	10000816 	blt	r2,zero,4042778 <__sread+0x40>
 4042758:	80801417 	ldw	r2,80(r16)
 404275c:	10c5883a 	add	r2,r2,r3
 4042760:	80801415 	stw	r2,80(r16)
 4042764:	1805883a 	mov	r2,r3
 4042768:	dfc00117 	ldw	ra,4(sp)
 404276c:	dc000017 	ldw	r16,0(sp)
 4042770:	dec00204 	addi	sp,sp,8
 4042774:	f800283a 	ret
 4042778:	8080030b 	ldhu	r2,12(r16)
 404277c:	10bbffcc 	andi	r2,r2,61439
 4042780:	8080030d 	sth	r2,12(r16)
 4042784:	1805883a 	mov	r2,r3
 4042788:	dfc00117 	ldw	ra,4(sp)
 404278c:	dc000017 	ldw	r16,0(sp)
 4042790:	dec00204 	addi	sp,sp,8
 4042794:	f800283a 	ret

04042798 <_write_r>:
 4042798:	defffd04 	addi	sp,sp,-12
 404279c:	dc000015 	stw	r16,0(sp)
 40427a0:	04010174 	movhi	r16,1029
 40427a4:	842d6404 	addi	r16,r16,-19056
 40427a8:	dc400115 	stw	r17,4(sp)
 40427ac:	80000015 	stw	zero,0(r16)
 40427b0:	2023883a 	mov	r17,r4
 40427b4:	2809883a 	mov	r4,r5
 40427b8:	300b883a 	mov	r5,r6
 40427bc:	380d883a 	mov	r6,r7
 40427c0:	dfc00215 	stw	ra,8(sp)
 40427c4:	40434d80 	call	40434d8 <write>
 40427c8:	1007883a 	mov	r3,r2
 40427cc:	00bfffc4 	movi	r2,-1
 40427d0:	18800626 	beq	r3,r2,40427ec <_write_r+0x54>
 40427d4:	1805883a 	mov	r2,r3
 40427d8:	dfc00217 	ldw	ra,8(sp)
 40427dc:	dc400117 	ldw	r17,4(sp)
 40427e0:	dc000017 	ldw	r16,0(sp)
 40427e4:	dec00304 	addi	sp,sp,12
 40427e8:	f800283a 	ret
 40427ec:	80800017 	ldw	r2,0(r16)
 40427f0:	103ff826 	beq	r2,zero,40427d4 <_write_r+0x3c>
 40427f4:	88800015 	stw	r2,0(r17)
 40427f8:	1805883a 	mov	r2,r3
 40427fc:	dfc00217 	ldw	ra,8(sp)
 4042800:	dc400117 	ldw	r17,4(sp)
 4042804:	dc000017 	ldw	r16,0(sp)
 4042808:	dec00304 	addi	sp,sp,12
 404280c:	f800283a 	ret

04042810 <_close_r>:
 4042810:	defffd04 	addi	sp,sp,-12
 4042814:	dc000015 	stw	r16,0(sp)
 4042818:	04010174 	movhi	r16,1029
 404281c:	842d6404 	addi	r16,r16,-19056
 4042820:	dc400115 	stw	r17,4(sp)
 4042824:	80000015 	stw	zero,0(r16)
 4042828:	2023883a 	mov	r17,r4
 404282c:	2809883a 	mov	r4,r5
 4042830:	dfc00215 	stw	ra,8(sp)
 4042834:	4042b780 	call	4042b78 <close>
 4042838:	1007883a 	mov	r3,r2
 404283c:	00bfffc4 	movi	r2,-1
 4042840:	18800626 	beq	r3,r2,404285c <_close_r+0x4c>
 4042844:	1805883a 	mov	r2,r3
 4042848:	dfc00217 	ldw	ra,8(sp)
 404284c:	dc400117 	ldw	r17,4(sp)
 4042850:	dc000017 	ldw	r16,0(sp)
 4042854:	dec00304 	addi	sp,sp,12
 4042858:	f800283a 	ret
 404285c:	80800017 	ldw	r2,0(r16)
 4042860:	103ff826 	beq	r2,zero,4042844 <_close_r+0x34>
 4042864:	88800015 	stw	r2,0(r17)
 4042868:	1805883a 	mov	r2,r3
 404286c:	dfc00217 	ldw	ra,8(sp)
 4042870:	dc400117 	ldw	r17,4(sp)
 4042874:	dc000017 	ldw	r16,0(sp)
 4042878:	dec00304 	addi	sp,sp,12
 404287c:	f800283a 	ret

04042880 <_fclose_r>:
 4042880:	defffc04 	addi	sp,sp,-16
 4042884:	dc400115 	stw	r17,4(sp)
 4042888:	dc000015 	stw	r16,0(sp)
 404288c:	dfc00315 	stw	ra,12(sp)
 4042890:	dc800215 	stw	r18,8(sp)
 4042894:	2821883a 	mov	r16,r5
 4042898:	2023883a 	mov	r17,r4
 404289c:	28002926 	beq	r5,zero,4042944 <_fclose_r+0xc4>
 40428a0:	4041bf80 	call	4041bf8 <__sfp_lock_acquire>
 40428a4:	88000226 	beq	r17,zero,40428b0 <_fclose_r+0x30>
 40428a8:	88800e17 	ldw	r2,56(r17)
 40428ac:	10002d26 	beq	r2,zero,4042964 <_fclose_r+0xe4>
 40428b0:	8080030f 	ldh	r2,12(r16)
 40428b4:	10002226 	beq	r2,zero,4042940 <_fclose_r+0xc0>
 40428b8:	8809883a 	mov	r4,r17
 40428bc:	800b883a 	mov	r5,r16
 40428c0:	40419700 	call	4041970 <_fflush_r>
 40428c4:	1025883a 	mov	r18,r2
 40428c8:	80800b17 	ldw	r2,44(r16)
 40428cc:	10000426 	beq	r2,zero,40428e0 <_fclose_r+0x60>
 40428d0:	81400717 	ldw	r5,28(r16)
 40428d4:	8809883a 	mov	r4,r17
 40428d8:	103ee83a 	callr	r2
 40428dc:	10002a16 	blt	r2,zero,4042988 <_fclose_r+0x108>
 40428e0:	8080030b 	ldhu	r2,12(r16)
 40428e4:	1080200c 	andi	r2,r2,128
 40428e8:	1000231e 	bne	r2,zero,4042978 <_fclose_r+0xf8>
 40428ec:	81400c17 	ldw	r5,48(r16)
 40428f0:	28000526 	beq	r5,zero,4042908 <_fclose_r+0x88>
 40428f4:	80801004 	addi	r2,r16,64
 40428f8:	28800226 	beq	r5,r2,4042904 <_fclose_r+0x84>
 40428fc:	8809883a 	mov	r4,r17
 4042900:	4041f8c0 	call	4041f8c <_free_r>
 4042904:	80000c15 	stw	zero,48(r16)
 4042908:	81401117 	ldw	r5,68(r16)
 404290c:	28000326 	beq	r5,zero,404291c <_fclose_r+0x9c>
 4042910:	8809883a 	mov	r4,r17
 4042914:	4041f8c0 	call	4041f8c <_free_r>
 4042918:	80001115 	stw	zero,68(r16)
 404291c:	8000030d 	sth	zero,12(r16)
 4042920:	4041bfc0 	call	4041bfc <__sfp_lock_release>
 4042924:	9005883a 	mov	r2,r18
 4042928:	dfc00317 	ldw	ra,12(sp)
 404292c:	dc800217 	ldw	r18,8(sp)
 4042930:	dc400117 	ldw	r17,4(sp)
 4042934:	dc000017 	ldw	r16,0(sp)
 4042938:	dec00404 	addi	sp,sp,16
 404293c:	f800283a 	ret
 4042940:	4041bfc0 	call	4041bfc <__sfp_lock_release>
 4042944:	0025883a 	mov	r18,zero
 4042948:	9005883a 	mov	r2,r18
 404294c:	dfc00317 	ldw	ra,12(sp)
 4042950:	dc800217 	ldw	r18,8(sp)
 4042954:	dc400117 	ldw	r17,4(sp)
 4042958:	dc000017 	ldw	r16,0(sp)
 404295c:	dec00404 	addi	sp,sp,16
 4042960:	f800283a 	ret
 4042964:	8809883a 	mov	r4,r17
 4042968:	4041c080 	call	4041c08 <__sinit>
 404296c:	8080030f 	ldh	r2,12(r16)
 4042970:	103fd11e 	bne	r2,zero,40428b8 <_fclose_r+0x38>
 4042974:	003ff206 	br	4042940 <_fclose_r+0xc0>
 4042978:	81400417 	ldw	r5,16(r16)
 404297c:	8809883a 	mov	r4,r17
 4042980:	4041f8c0 	call	4041f8c <_free_r>
 4042984:	003fd906 	br	40428ec <_fclose_r+0x6c>
 4042988:	04bfffc4 	movi	r18,-1
 404298c:	003fd406 	br	40428e0 <_fclose_r+0x60>

04042990 <fclose>:
 4042990:	00810174 	movhi	r2,1029
 4042994:	10a68704 	addi	r2,r2,-26084
 4042998:	200b883a 	mov	r5,r4
 404299c:	11000017 	ldw	r4,0(r2)
 40429a0:	40428801 	jmpi	4042880 <_fclose_r>

040429a4 <_fstat_r>:
 40429a4:	defffd04 	addi	sp,sp,-12
 40429a8:	dc000015 	stw	r16,0(sp)
 40429ac:	04010174 	movhi	r16,1029
 40429b0:	842d6404 	addi	r16,r16,-19056
 40429b4:	dc400115 	stw	r17,4(sp)
 40429b8:	80000015 	stw	zero,0(r16)
 40429bc:	2023883a 	mov	r17,r4
 40429c0:	2809883a 	mov	r4,r5
 40429c4:	300b883a 	mov	r5,r6
 40429c8:	dfc00215 	stw	ra,8(sp)
 40429cc:	4042d000 	call	4042d00 <fstat>
 40429d0:	1007883a 	mov	r3,r2
 40429d4:	00bfffc4 	movi	r2,-1
 40429d8:	18800626 	beq	r3,r2,40429f4 <_fstat_r+0x50>
 40429dc:	1805883a 	mov	r2,r3
 40429e0:	dfc00217 	ldw	ra,8(sp)
 40429e4:	dc400117 	ldw	r17,4(sp)
 40429e8:	dc000017 	ldw	r16,0(sp)
 40429ec:	dec00304 	addi	sp,sp,12
 40429f0:	f800283a 	ret
 40429f4:	80800017 	ldw	r2,0(r16)
 40429f8:	103ff826 	beq	r2,zero,40429dc <_fstat_r+0x38>
 40429fc:	88800015 	stw	r2,0(r17)
 4042a00:	1805883a 	mov	r2,r3
 4042a04:	dfc00217 	ldw	ra,8(sp)
 4042a08:	dc400117 	ldw	r17,4(sp)
 4042a0c:	dc000017 	ldw	r16,0(sp)
 4042a10:	dec00304 	addi	sp,sp,12
 4042a14:	f800283a 	ret

04042a18 <_isatty_r>:
 4042a18:	defffd04 	addi	sp,sp,-12
 4042a1c:	dc000015 	stw	r16,0(sp)
 4042a20:	04010174 	movhi	r16,1029
 4042a24:	842d6404 	addi	r16,r16,-19056
 4042a28:	dc400115 	stw	r17,4(sp)
 4042a2c:	80000015 	stw	zero,0(r16)
 4042a30:	2023883a 	mov	r17,r4
 4042a34:	2809883a 	mov	r4,r5
 4042a38:	dfc00215 	stw	ra,8(sp)
 4042a3c:	4042e340 	call	4042e34 <isatty>
 4042a40:	1007883a 	mov	r3,r2
 4042a44:	00bfffc4 	movi	r2,-1
 4042a48:	18800626 	beq	r3,r2,4042a64 <_isatty_r+0x4c>
 4042a4c:	1805883a 	mov	r2,r3
 4042a50:	dfc00217 	ldw	ra,8(sp)
 4042a54:	dc400117 	ldw	r17,4(sp)
 4042a58:	dc000017 	ldw	r16,0(sp)
 4042a5c:	dec00304 	addi	sp,sp,12
 4042a60:	f800283a 	ret
 4042a64:	80800017 	ldw	r2,0(r16)
 4042a68:	103ff826 	beq	r2,zero,4042a4c <_isatty_r+0x34>
 4042a6c:	88800015 	stw	r2,0(r17)
 4042a70:	1805883a 	mov	r2,r3
 4042a74:	dfc00217 	ldw	ra,8(sp)
 4042a78:	dc400117 	ldw	r17,4(sp)
 4042a7c:	dc000017 	ldw	r16,0(sp)
 4042a80:	dec00304 	addi	sp,sp,12
 4042a84:	f800283a 	ret

04042a88 <_lseek_r>:
 4042a88:	defffd04 	addi	sp,sp,-12
 4042a8c:	dc000015 	stw	r16,0(sp)
 4042a90:	04010174 	movhi	r16,1029
 4042a94:	842d6404 	addi	r16,r16,-19056
 4042a98:	dc400115 	stw	r17,4(sp)
 4042a9c:	80000015 	stw	zero,0(r16)
 4042aa0:	2023883a 	mov	r17,r4
 4042aa4:	2809883a 	mov	r4,r5
 4042aa8:	300b883a 	mov	r5,r6
 4042aac:	380d883a 	mov	r6,r7
 4042ab0:	dfc00215 	stw	ra,8(sp)
 4042ab4:	40430400 	call	4043040 <lseek>
 4042ab8:	1007883a 	mov	r3,r2
 4042abc:	00bfffc4 	movi	r2,-1
 4042ac0:	18800626 	beq	r3,r2,4042adc <_lseek_r+0x54>
 4042ac4:	1805883a 	mov	r2,r3
 4042ac8:	dfc00217 	ldw	ra,8(sp)
 4042acc:	dc400117 	ldw	r17,4(sp)
 4042ad0:	dc000017 	ldw	r16,0(sp)
 4042ad4:	dec00304 	addi	sp,sp,12
 4042ad8:	f800283a 	ret
 4042adc:	80800017 	ldw	r2,0(r16)
 4042ae0:	103ff826 	beq	r2,zero,4042ac4 <_lseek_r+0x3c>
 4042ae4:	88800015 	stw	r2,0(r17)
 4042ae8:	1805883a 	mov	r2,r3
 4042aec:	dfc00217 	ldw	ra,8(sp)
 4042af0:	dc400117 	ldw	r17,4(sp)
 4042af4:	dc000017 	ldw	r16,0(sp)
 4042af8:	dec00304 	addi	sp,sp,12
 4042afc:	f800283a 	ret

04042b00 <_read_r>:
 4042b00:	defffd04 	addi	sp,sp,-12
 4042b04:	dc000015 	stw	r16,0(sp)
 4042b08:	04010174 	movhi	r16,1029
 4042b0c:	842d6404 	addi	r16,r16,-19056
 4042b10:	dc400115 	stw	r17,4(sp)
 4042b14:	80000015 	stw	zero,0(r16)
 4042b18:	2023883a 	mov	r17,r4
 4042b1c:	2809883a 	mov	r4,r5
 4042b20:	300b883a 	mov	r5,r6
 4042b24:	380d883a 	mov	r6,r7
 4042b28:	dfc00215 	stw	ra,8(sp)
 4042b2c:	404323c0 	call	404323c <read>
 4042b30:	1007883a 	mov	r3,r2
 4042b34:	00bfffc4 	movi	r2,-1
 4042b38:	18800626 	beq	r3,r2,4042b54 <_read_r+0x54>
 4042b3c:	1805883a 	mov	r2,r3
 4042b40:	dfc00217 	ldw	ra,8(sp)
 4042b44:	dc400117 	ldw	r17,4(sp)
 4042b48:	dc000017 	ldw	r16,0(sp)
 4042b4c:	dec00304 	addi	sp,sp,12
 4042b50:	f800283a 	ret
 4042b54:	80800017 	ldw	r2,0(r16)
 4042b58:	103ff826 	beq	r2,zero,4042b3c <_read_r+0x3c>
 4042b5c:	88800015 	stw	r2,0(r17)
 4042b60:	1805883a 	mov	r2,r3
 4042b64:	dfc00217 	ldw	ra,8(sp)
 4042b68:	dc400117 	ldw	r17,4(sp)
 4042b6c:	dc000017 	ldw	r16,0(sp)
 4042b70:	dec00304 	addi	sp,sp,12
 4042b74:	f800283a 	ret

04042b78 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 4042b78:	defff804 	addi	sp,sp,-32
 4042b7c:	dfc00715 	stw	ra,28(sp)
 4042b80:	df000615 	stw	fp,24(sp)
 4042b84:	df000604 	addi	fp,sp,24
 4042b88:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 4042b8c:	e0bffc17 	ldw	r2,-16(fp)
 4042b90:	1004803a 	cmplt	r2,r2,zero
 4042b94:	1000081e 	bne	r2,zero,4042bb8 <close+0x40>
 4042b98:	e0bffc17 	ldw	r2,-16(fp)
 4042b9c:	10800324 	muli	r2,r2,12
 4042ba0:	1007883a 	mov	r3,r2
 4042ba4:	00810174 	movhi	r2,1029
 4042ba8:	10a1d904 	addi	r2,r2,-30876
 4042bac:	1887883a 	add	r3,r3,r2
 4042bb0:	e0ffff15 	stw	r3,-4(fp)
 4042bb4:	00000106 	br	4042bbc <close+0x44>
 4042bb8:	e03fff15 	stw	zero,-4(fp)
 4042bbc:	e0bfff17 	ldw	r2,-4(fp)
 4042bc0:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 4042bc4:	e0bffb17 	ldw	r2,-20(fp)
 4042bc8:	1005003a 	cmpeq	r2,r2,zero
 4042bcc:	10001d1e 	bne	r2,zero,4042c44 <close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 4042bd0:	e0bffb17 	ldw	r2,-20(fp)
 4042bd4:	10800017 	ldw	r2,0(r2)
 4042bd8:	10800417 	ldw	r2,16(r2)
 4042bdc:	1005003a 	cmpeq	r2,r2,zero
 4042be0:	1000071e 	bne	r2,zero,4042c00 <close+0x88>
 4042be4:	e0bffb17 	ldw	r2,-20(fp)
 4042be8:	10800017 	ldw	r2,0(r2)
 4042bec:	10800417 	ldw	r2,16(r2)
 4042bf0:	e13ffb17 	ldw	r4,-20(fp)
 4042bf4:	103ee83a 	callr	r2
 4042bf8:	e0bffe15 	stw	r2,-8(fp)
 4042bfc:	00000106 	br	4042c04 <close+0x8c>
 4042c00:	e03ffe15 	stw	zero,-8(fp)
 4042c04:	e0bffe17 	ldw	r2,-8(fp)
 4042c08:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 4042c0c:	e13ffc17 	ldw	r4,-16(fp)
 4042c10:	40433bc0 	call	40433bc <alt_release_fd>
    if (rval < 0)
 4042c14:	e0bffa17 	ldw	r2,-24(fp)
 4042c18:	1004403a 	cmpge	r2,r2,zero
 4042c1c:	1000071e 	bne	r2,zero,4042c3c <close+0xc4>
    {
      ALT_ERRNO = -rval;
 4042c20:	4042c740 	call	4042c74 <alt_get_errno>
 4042c24:	e0fffa17 	ldw	r3,-24(fp)
 4042c28:	00c7c83a 	sub	r3,zero,r3
 4042c2c:	10c00015 	stw	r3,0(r2)
      return -1;
 4042c30:	00bfffc4 	movi	r2,-1
 4042c34:	e0bffd15 	stw	r2,-12(fp)
 4042c38:	00000806 	br	4042c5c <close+0xe4>
    }
    return 0;
 4042c3c:	e03ffd15 	stw	zero,-12(fp)
 4042c40:	00000606 	br	4042c5c <close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 4042c44:	4042c740 	call	4042c74 <alt_get_errno>
 4042c48:	1007883a 	mov	r3,r2
 4042c4c:	00801444 	movi	r2,81
 4042c50:	18800015 	stw	r2,0(r3)
    return -1;
 4042c54:	00bfffc4 	movi	r2,-1
 4042c58:	e0bffd15 	stw	r2,-12(fp)
 4042c5c:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 4042c60:	e037883a 	mov	sp,fp
 4042c64:	dfc00117 	ldw	ra,4(sp)
 4042c68:	df000017 	ldw	fp,0(sp)
 4042c6c:	dec00204 	addi	sp,sp,8
 4042c70:	f800283a 	ret

04042c74 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4042c74:	defffd04 	addi	sp,sp,-12
 4042c78:	dfc00215 	stw	ra,8(sp)
 4042c7c:	df000115 	stw	fp,4(sp)
 4042c80:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 4042c84:	00810174 	movhi	r2,1029
 4042c88:	10a69004 	addi	r2,r2,-26048
 4042c8c:	10800017 	ldw	r2,0(r2)
 4042c90:	1005003a 	cmpeq	r2,r2,zero
 4042c94:	1000061e 	bne	r2,zero,4042cb0 <alt_get_errno+0x3c>
 4042c98:	00810174 	movhi	r2,1029
 4042c9c:	10a69004 	addi	r2,r2,-26048
 4042ca0:	10800017 	ldw	r2,0(r2)
 4042ca4:	103ee83a 	callr	r2
 4042ca8:	e0bfff15 	stw	r2,-4(fp)
 4042cac:	00000306 	br	4042cbc <alt_get_errno+0x48>
 4042cb0:	00810174 	movhi	r2,1029
 4042cb4:	10ad6404 	addi	r2,r2,-19056
 4042cb8:	e0bfff15 	stw	r2,-4(fp)
 4042cbc:	e0bfff17 	ldw	r2,-4(fp)
}
 4042cc0:	e037883a 	mov	sp,fp
 4042cc4:	dfc00117 	ldw	ra,4(sp)
 4042cc8:	df000017 	ldw	fp,0(sp)
 4042ccc:	dec00204 	addi	sp,sp,8
 4042cd0:	f800283a 	ret

04042cd4 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 4042cd4:	defffc04 	addi	sp,sp,-16
 4042cd8:	df000315 	stw	fp,12(sp)
 4042cdc:	df000304 	addi	fp,sp,12
 4042ce0:	e13ffd15 	stw	r4,-12(fp)
 4042ce4:	e17ffe15 	stw	r5,-8(fp)
 4042ce8:	e1bfff15 	stw	r6,-4(fp)
  return len;
 4042cec:	e0bfff17 	ldw	r2,-4(fp)
}
 4042cf0:	e037883a 	mov	sp,fp
 4042cf4:	df000017 	ldw	fp,0(sp)
 4042cf8:	dec00104 	addi	sp,sp,4
 4042cfc:	f800283a 	ret

04042d00 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 4042d00:	defff904 	addi	sp,sp,-28
 4042d04:	dfc00615 	stw	ra,24(sp)
 4042d08:	df000515 	stw	fp,20(sp)
 4042d0c:	df000504 	addi	fp,sp,20
 4042d10:	e13ffc15 	stw	r4,-16(fp)
 4042d14:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4042d18:	e0bffc17 	ldw	r2,-16(fp)
 4042d1c:	1004803a 	cmplt	r2,r2,zero
 4042d20:	1000081e 	bne	r2,zero,4042d44 <fstat+0x44>
 4042d24:	e0bffc17 	ldw	r2,-16(fp)
 4042d28:	10800324 	muli	r2,r2,12
 4042d2c:	1007883a 	mov	r3,r2
 4042d30:	00810174 	movhi	r2,1029
 4042d34:	10a1d904 	addi	r2,r2,-30876
 4042d38:	1887883a 	add	r3,r3,r2
 4042d3c:	e0ffff15 	stw	r3,-4(fp)
 4042d40:	00000106 	br	4042d48 <fstat+0x48>
 4042d44:	e03fff15 	stw	zero,-4(fp)
 4042d48:	e0bfff17 	ldw	r2,-4(fp)
 4042d4c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 4042d50:	e0bffb17 	ldw	r2,-20(fp)
 4042d54:	1005003a 	cmpeq	r2,r2,zero
 4042d58:	1000121e 	bne	r2,zero,4042da4 <fstat+0xa4>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 4042d5c:	e0bffb17 	ldw	r2,-20(fp)
 4042d60:	10800017 	ldw	r2,0(r2)
 4042d64:	10800817 	ldw	r2,32(r2)
 4042d68:	1005003a 	cmpeq	r2,r2,zero
 4042d6c:	1000081e 	bne	r2,zero,4042d90 <fstat+0x90>
    {
      return fd->dev->fstat(fd, st);
 4042d70:	e0bffb17 	ldw	r2,-20(fp)
 4042d74:	10800017 	ldw	r2,0(r2)
 4042d78:	10800817 	ldw	r2,32(r2)
 4042d7c:	e13ffb17 	ldw	r4,-20(fp)
 4042d80:	e17ffd17 	ldw	r5,-12(fp)
 4042d84:	103ee83a 	callr	r2
 4042d88:	e0bffe15 	stw	r2,-8(fp)
 4042d8c:	00000b06 	br	4042dbc <fstat+0xbc>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 4042d90:	e0fffd17 	ldw	r3,-12(fp)
 4042d94:	00880004 	movi	r2,8192
 4042d98:	18800115 	stw	r2,4(r3)
      return 0;
 4042d9c:	e03ffe15 	stw	zero,-8(fp)
 4042da0:	00000606 	br	4042dbc <fstat+0xbc>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 4042da4:	4042dd40 	call	4042dd4 <alt_get_errno>
 4042da8:	1007883a 	mov	r3,r2
 4042dac:	00801444 	movi	r2,81
 4042db0:	18800015 	stw	r2,0(r3)
    return -1;
 4042db4:	00bfffc4 	movi	r2,-1
 4042db8:	e0bffe15 	stw	r2,-8(fp)
 4042dbc:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 4042dc0:	e037883a 	mov	sp,fp
 4042dc4:	dfc00117 	ldw	ra,4(sp)
 4042dc8:	df000017 	ldw	fp,0(sp)
 4042dcc:	dec00204 	addi	sp,sp,8
 4042dd0:	f800283a 	ret

04042dd4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4042dd4:	defffd04 	addi	sp,sp,-12
 4042dd8:	dfc00215 	stw	ra,8(sp)
 4042ddc:	df000115 	stw	fp,4(sp)
 4042de0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 4042de4:	00810174 	movhi	r2,1029
 4042de8:	10a69004 	addi	r2,r2,-26048
 4042dec:	10800017 	ldw	r2,0(r2)
 4042df0:	1005003a 	cmpeq	r2,r2,zero
 4042df4:	1000061e 	bne	r2,zero,4042e10 <alt_get_errno+0x3c>
 4042df8:	00810174 	movhi	r2,1029
 4042dfc:	10a69004 	addi	r2,r2,-26048
 4042e00:	10800017 	ldw	r2,0(r2)
 4042e04:	103ee83a 	callr	r2
 4042e08:	e0bfff15 	stw	r2,-4(fp)
 4042e0c:	00000306 	br	4042e1c <alt_get_errno+0x48>
 4042e10:	00810174 	movhi	r2,1029
 4042e14:	10ad6404 	addi	r2,r2,-19056
 4042e18:	e0bfff15 	stw	r2,-4(fp)
 4042e1c:	e0bfff17 	ldw	r2,-4(fp)
}
 4042e20:	e037883a 	mov	sp,fp
 4042e24:	dfc00117 	ldw	ra,4(sp)
 4042e28:	df000017 	ldw	fp,0(sp)
 4042e2c:	dec00204 	addi	sp,sp,8
 4042e30:	f800283a 	ret

04042e34 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 4042e34:	deffeb04 	addi	sp,sp,-84
 4042e38:	dfc01415 	stw	ra,80(sp)
 4042e3c:	df001315 	stw	fp,76(sp)
 4042e40:	df001304 	addi	fp,sp,76
 4042e44:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4042e48:	e0bffd17 	ldw	r2,-12(fp)
 4042e4c:	1004803a 	cmplt	r2,r2,zero
 4042e50:	1000081e 	bne	r2,zero,4042e74 <isatty+0x40>
 4042e54:	e0bffd17 	ldw	r2,-12(fp)
 4042e58:	10800324 	muli	r2,r2,12
 4042e5c:	1007883a 	mov	r3,r2
 4042e60:	00810174 	movhi	r2,1029
 4042e64:	10a1d904 	addi	r2,r2,-30876
 4042e68:	1887883a 	add	r3,r3,r2
 4042e6c:	e0ffff15 	stw	r3,-4(fp)
 4042e70:	00000106 	br	4042e78 <isatty+0x44>
 4042e74:	e03fff15 	stw	zero,-4(fp)
 4042e78:	e0bfff17 	ldw	r2,-4(fp)
 4042e7c:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
 4042e80:	e0bfed17 	ldw	r2,-76(fp)
 4042e84:	1005003a 	cmpeq	r2,r2,zero
 4042e88:	10000f1e 	bne	r2,zero,4042ec8 <isatty+0x94>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 4042e8c:	e0bfed17 	ldw	r2,-76(fp)
 4042e90:	10800017 	ldw	r2,0(r2)
 4042e94:	10800817 	ldw	r2,32(r2)
 4042e98:	1004c03a 	cmpne	r2,r2,zero
 4042e9c:	1000031e 	bne	r2,zero,4042eac <isatty+0x78>
    {
      return 1;
 4042ea0:	00800044 	movi	r2,1
 4042ea4:	e0bffe15 	stw	r2,-8(fp)
 4042ea8:	00000c06 	br	4042edc <isatty+0xa8>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 4042eac:	e17fee04 	addi	r5,fp,-72
 4042eb0:	e13ffd17 	ldw	r4,-12(fp)
 4042eb4:	4042d000 	call	4042d00 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 4042eb8:	e0bfef17 	ldw	r2,-68(fp)
 4042ebc:	10880020 	cmpeqi	r2,r2,8192
 4042ec0:	e0bffe15 	stw	r2,-8(fp)
 4042ec4:	00000506 	br	4042edc <isatty+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 4042ec8:	4042ef40 	call	4042ef4 <alt_get_errno>
 4042ecc:	1007883a 	mov	r3,r2
 4042ed0:	00801444 	movi	r2,81
 4042ed4:	18800015 	stw	r2,0(r3)
    return 0;
 4042ed8:	e03ffe15 	stw	zero,-8(fp)
 4042edc:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 4042ee0:	e037883a 	mov	sp,fp
 4042ee4:	dfc00117 	ldw	ra,4(sp)
 4042ee8:	df000017 	ldw	fp,0(sp)
 4042eec:	dec00204 	addi	sp,sp,8
 4042ef0:	f800283a 	ret

04042ef4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4042ef4:	defffd04 	addi	sp,sp,-12
 4042ef8:	dfc00215 	stw	ra,8(sp)
 4042efc:	df000115 	stw	fp,4(sp)
 4042f00:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 4042f04:	00810174 	movhi	r2,1029
 4042f08:	10a69004 	addi	r2,r2,-26048
 4042f0c:	10800017 	ldw	r2,0(r2)
 4042f10:	1005003a 	cmpeq	r2,r2,zero
 4042f14:	1000061e 	bne	r2,zero,4042f30 <alt_get_errno+0x3c>
 4042f18:	00810174 	movhi	r2,1029
 4042f1c:	10a69004 	addi	r2,r2,-26048
 4042f20:	10800017 	ldw	r2,0(r2)
 4042f24:	103ee83a 	callr	r2
 4042f28:	e0bfff15 	stw	r2,-4(fp)
 4042f2c:	00000306 	br	4042f3c <alt_get_errno+0x48>
 4042f30:	00810174 	movhi	r2,1029
 4042f34:	10ad6404 	addi	r2,r2,-19056
 4042f38:	e0bfff15 	stw	r2,-4(fp)
 4042f3c:	e0bfff17 	ldw	r2,-4(fp)
}
 4042f40:	e037883a 	mov	sp,fp
 4042f44:	dfc00117 	ldw	ra,4(sp)
 4042f48:	df000017 	ldw	fp,0(sp)
 4042f4c:	dec00204 	addi	sp,sp,8
 4042f50:	f800283a 	ret

04042f54 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 4042f54:	defffe04 	addi	sp,sp,-8
 4042f58:	dfc00115 	stw	ra,4(sp)
 4042f5c:	df000015 	stw	fp,0(sp)
 4042f60:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 4042f64:	01010174 	movhi	r4,1029
 4042f68:	21269704 	addi	r4,r4,-26020
 4042f6c:	01410134 	movhi	r5,1028
 4042f70:	295fcd04 	addi	r5,r5,32564
 4042f74:	01810174 	movhi	r6,1029
 4042f78:	31a69704 	addi	r6,r6,-26020
 4042f7c:	4042fd40 	call	4042fd4 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 4042f80:	01010134 	movhi	r4,1028
 4042f84:	21000804 	addi	r4,r4,32
 4042f88:	01410134 	movhi	r5,1028
 4042f8c:	29400804 	addi	r5,r5,32
 4042f90:	01810134 	movhi	r6,1028
 4042f94:	31806d04 	addi	r6,r6,436
 4042f98:	4042fd40 	call	4042fd4 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 4042f9c:	01010134 	movhi	r4,1028
 4042fa0:	211fb704 	addi	r4,r4,32476
 4042fa4:	01410134 	movhi	r5,1028
 4042fa8:	295fb704 	addi	r5,r5,32476
 4042fac:	01810134 	movhi	r6,1028
 4042fb0:	319fcd04 	addi	r6,r6,32564
 4042fb4:	4042fd40 	call	4042fd4 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 4042fb8:	404609c0 	call	404609c <alt_dcache_flush_all>
  alt_icache_flush_all();
 4042fbc:	404638c0 	call	404638c <alt_icache_flush_all>
}
 4042fc0:	e037883a 	mov	sp,fp
 4042fc4:	dfc00117 	ldw	ra,4(sp)
 4042fc8:	df000017 	ldw	fp,0(sp)
 4042fcc:	dec00204 	addi	sp,sp,8
 4042fd0:	f800283a 	ret

04042fd4 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 4042fd4:	defffc04 	addi	sp,sp,-16
 4042fd8:	df000315 	stw	fp,12(sp)
 4042fdc:	df000304 	addi	fp,sp,12
 4042fe0:	e13ffd15 	stw	r4,-12(fp)
 4042fe4:	e17ffe15 	stw	r5,-8(fp)
 4042fe8:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 4042fec:	e0fffe17 	ldw	r3,-8(fp)
 4042ff0:	e0bffd17 	ldw	r2,-12(fp)
 4042ff4:	18800e26 	beq	r3,r2,4043030 <alt_load_section+0x5c>
  {
    while( to != end )
 4042ff8:	00000a06 	br	4043024 <alt_load_section+0x50>
    {
      *to++ = *from++;
 4042ffc:	e0bffd17 	ldw	r2,-12(fp)
 4043000:	10c00017 	ldw	r3,0(r2)
 4043004:	e0bffe17 	ldw	r2,-8(fp)
 4043008:	10c00015 	stw	r3,0(r2)
 404300c:	e0bffe17 	ldw	r2,-8(fp)
 4043010:	10800104 	addi	r2,r2,4
 4043014:	e0bffe15 	stw	r2,-8(fp)
 4043018:	e0bffd17 	ldw	r2,-12(fp)
 404301c:	10800104 	addi	r2,r2,4
 4043020:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 4043024:	e0fffe17 	ldw	r3,-8(fp)
 4043028:	e0bfff17 	ldw	r2,-4(fp)
 404302c:	18bff31e 	bne	r3,r2,4042ffc <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
 4043030:	e037883a 	mov	sp,fp
 4043034:	df000017 	ldw	fp,0(sp)
 4043038:	dec00104 	addi	sp,sp,4
 404303c:	f800283a 	ret

04043040 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 4043040:	defff804 	addi	sp,sp,-32
 4043044:	dfc00715 	stw	ra,28(sp)
 4043048:	df000615 	stw	fp,24(sp)
 404304c:	df000604 	addi	fp,sp,24
 4043050:	e13ffc15 	stw	r4,-16(fp)
 4043054:	e17ffd15 	stw	r5,-12(fp)
 4043058:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 404305c:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4043060:	e0bffc17 	ldw	r2,-16(fp)
 4043064:	1004803a 	cmplt	r2,r2,zero
 4043068:	1000081e 	bne	r2,zero,404308c <lseek+0x4c>
 404306c:	e0bffc17 	ldw	r2,-16(fp)
 4043070:	10800324 	muli	r2,r2,12
 4043074:	1007883a 	mov	r3,r2
 4043078:	00810174 	movhi	r2,1029
 404307c:	10a1d904 	addi	r2,r2,-30876
 4043080:	1887883a 	add	r3,r3,r2
 4043084:	e0ffff15 	stw	r3,-4(fp)
 4043088:	00000106 	br	4043090 <lseek+0x50>
 404308c:	e03fff15 	stw	zero,-4(fp)
 4043090:	e0bfff17 	ldw	r2,-4(fp)
 4043094:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
 4043098:	e0bffb17 	ldw	r2,-20(fp)
 404309c:	1005003a 	cmpeq	r2,r2,zero
 40430a0:	1000111e 	bne	r2,zero,40430e8 <lseek+0xa8>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 40430a4:	e0bffb17 	ldw	r2,-20(fp)
 40430a8:	10800017 	ldw	r2,0(r2)
 40430ac:	10800717 	ldw	r2,28(r2)
 40430b0:	1005003a 	cmpeq	r2,r2,zero
 40430b4:	1000091e 	bne	r2,zero,40430dc <lseek+0x9c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 40430b8:	e0bffb17 	ldw	r2,-20(fp)
 40430bc:	10800017 	ldw	r2,0(r2)
 40430c0:	10800717 	ldw	r2,28(r2)
 40430c4:	e13ffb17 	ldw	r4,-20(fp)
 40430c8:	e17ffd17 	ldw	r5,-12(fp)
 40430cc:	e1bffe17 	ldw	r6,-8(fp)
 40430d0:	103ee83a 	callr	r2
 40430d4:	e0bffa15 	stw	r2,-24(fp)
 40430d8:	00000506 	br	40430f0 <lseek+0xb0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 40430dc:	00bfde84 	movi	r2,-134
 40430e0:	e0bffa15 	stw	r2,-24(fp)
 40430e4:	00000206 	br	40430f0 <lseek+0xb0>
    }
  }
  else  
  {
    rc = -EBADFD;
 40430e8:	00bfebc4 	movi	r2,-81
 40430ec:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
 40430f0:	e0bffa17 	ldw	r2,-24(fp)
 40430f4:	1004403a 	cmpge	r2,r2,zero
 40430f8:	1000071e 	bne	r2,zero,4043118 <lseek+0xd8>
  {
    ALT_ERRNO = -rc;
 40430fc:	40431300 	call	4043130 <alt_get_errno>
 4043100:	1007883a 	mov	r3,r2
 4043104:	e0bffa17 	ldw	r2,-24(fp)
 4043108:	0085c83a 	sub	r2,zero,r2
 404310c:	18800015 	stw	r2,0(r3)
    rc = -1;
 4043110:	00bfffc4 	movi	r2,-1
 4043114:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
 4043118:	e0bffa17 	ldw	r2,-24(fp)
}
 404311c:	e037883a 	mov	sp,fp
 4043120:	dfc00117 	ldw	ra,4(sp)
 4043124:	df000017 	ldw	fp,0(sp)
 4043128:	dec00204 	addi	sp,sp,8
 404312c:	f800283a 	ret

04043130 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4043130:	defffd04 	addi	sp,sp,-12
 4043134:	dfc00215 	stw	ra,8(sp)
 4043138:	df000115 	stw	fp,4(sp)
 404313c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 4043140:	00810174 	movhi	r2,1029
 4043144:	10a69004 	addi	r2,r2,-26048
 4043148:	10800017 	ldw	r2,0(r2)
 404314c:	1005003a 	cmpeq	r2,r2,zero
 4043150:	1000061e 	bne	r2,zero,404316c <alt_get_errno+0x3c>
 4043154:	00810174 	movhi	r2,1029
 4043158:	10a69004 	addi	r2,r2,-26048
 404315c:	10800017 	ldw	r2,0(r2)
 4043160:	103ee83a 	callr	r2
 4043164:	e0bfff15 	stw	r2,-4(fp)
 4043168:	00000306 	br	4043178 <alt_get_errno+0x48>
 404316c:	00810174 	movhi	r2,1029
 4043170:	10ad6404 	addi	r2,r2,-19056
 4043174:	e0bfff15 	stw	r2,-4(fp)
 4043178:	e0bfff17 	ldw	r2,-4(fp)
}
 404317c:	e037883a 	mov	sp,fp
 4043180:	dfc00117 	ldw	ra,4(sp)
 4043184:	df000017 	ldw	fp,0(sp)
 4043188:	dec00204 	addi	sp,sp,8
 404318c:	f800283a 	ret

04043190 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 4043190:	defffd04 	addi	sp,sp,-12
 4043194:	dfc00215 	stw	ra,8(sp)
 4043198:	df000115 	stw	fp,4(sp)
 404319c:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 40431a0:	0009883a 	mov	r4,zero
 40431a4:	40436580 	call	4043658 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 40431a8:	404368c0 	call	404368c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 40431ac:	01010134 	movhi	r4,1028
 40431b0:	211fc104 	addi	r4,r4,32516
 40431b4:	01410134 	movhi	r5,1028
 40431b8:	295fc104 	addi	r5,r5,32516
 40431bc:	01810134 	movhi	r6,1028
 40431c0:	319fc104 	addi	r6,r6,32516
 40431c4:	404674c0 	call	404674c <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 40431c8:	40461f40 	call	40461f4 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 40431cc:	01010134 	movhi	r4,1028
 40431d0:	21189604 	addi	r4,r4,25176
 40431d4:	40479840 	call	4047984 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 40431d8:	d126de17 	ldw	r4,-25736(gp)
 40431dc:	d166df17 	ldw	r5,-25732(gp)
 40431e0:	d1a6e017 	ldw	r6,-25728(gp)
 40431e4:	40402000 	call	4040200 <main>
 40431e8:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 40431ec:	01000044 	movi	r4,1
 40431f0:	4042b780 	call	4042b78 <close>
  exit (result);
 40431f4:	e13fff17 	ldw	r4,-4(fp)
 40431f8:	40479980 	call	4047998 <exit>

040431fc <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 40431fc:	defffe04 	addi	sp,sp,-8
 4043200:	df000115 	stw	fp,4(sp)
 4043204:	df000104 	addi	fp,sp,4
 4043208:	e13fff15 	stw	r4,-4(fp)
}
 404320c:	e037883a 	mov	sp,fp
 4043210:	df000017 	ldw	fp,0(sp)
 4043214:	dec00104 	addi	sp,sp,4
 4043218:	f800283a 	ret

0404321c <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 404321c:	defffe04 	addi	sp,sp,-8
 4043220:	df000115 	stw	fp,4(sp)
 4043224:	df000104 	addi	fp,sp,4
 4043228:	e13fff15 	stw	r4,-4(fp)
}
 404322c:	e037883a 	mov	sp,fp
 4043230:	df000017 	ldw	fp,0(sp)
 4043234:	dec00104 	addi	sp,sp,4
 4043238:	f800283a 	ret

0404323c <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 404323c:	defff704 	addi	sp,sp,-36
 4043240:	dfc00815 	stw	ra,32(sp)
 4043244:	df000715 	stw	fp,28(sp)
 4043248:	df000704 	addi	fp,sp,28
 404324c:	e13ffb15 	stw	r4,-20(fp)
 4043250:	e17ffc15 	stw	r5,-16(fp)
 4043254:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4043258:	e0bffb17 	ldw	r2,-20(fp)
 404325c:	1004803a 	cmplt	r2,r2,zero
 4043260:	1000081e 	bne	r2,zero,4043284 <read+0x48>
 4043264:	e0bffb17 	ldw	r2,-20(fp)
 4043268:	10800324 	muli	r2,r2,12
 404326c:	1007883a 	mov	r3,r2
 4043270:	00810174 	movhi	r2,1029
 4043274:	10a1d904 	addi	r2,r2,-30876
 4043278:	1887883a 	add	r3,r3,r2
 404327c:	e0ffff15 	stw	r3,-4(fp)
 4043280:	00000106 	br	4043288 <read+0x4c>
 4043284:	e03fff15 	stw	zero,-4(fp)
 4043288:	e0bfff17 	ldw	r2,-4(fp)
 404328c:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 4043290:	e0bffa17 	ldw	r2,-24(fp)
 4043294:	1005003a 	cmpeq	r2,r2,zero
 4043298:	1000241e 	bne	r2,zero,404332c <read+0xf0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 404329c:	e0bffa17 	ldw	r2,-24(fp)
 40432a0:	10800217 	ldw	r2,8(r2)
 40432a4:	108000cc 	andi	r2,r2,3
 40432a8:	10800060 	cmpeqi	r2,r2,1
 40432ac:	10001a1e 	bne	r2,zero,4043318 <read+0xdc>
 40432b0:	e0bffa17 	ldw	r2,-24(fp)
 40432b4:	10800017 	ldw	r2,0(r2)
 40432b8:	10800517 	ldw	r2,20(r2)
 40432bc:	1005003a 	cmpeq	r2,r2,zero
 40432c0:	1000151e 	bne	r2,zero,4043318 <read+0xdc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 40432c4:	e0bffa17 	ldw	r2,-24(fp)
 40432c8:	10800017 	ldw	r2,0(r2)
 40432cc:	10800517 	ldw	r2,20(r2)
 40432d0:	e17ffc17 	ldw	r5,-16(fp)
 40432d4:	e1bffd17 	ldw	r6,-12(fp)
 40432d8:	e13ffa17 	ldw	r4,-24(fp)
 40432dc:	103ee83a 	callr	r2
 40432e0:	e0bff915 	stw	r2,-28(fp)
 40432e4:	e0bff917 	ldw	r2,-28(fp)
 40432e8:	1004403a 	cmpge	r2,r2,zero
 40432ec:	1000071e 	bne	r2,zero,404330c <read+0xd0>
        {
          ALT_ERRNO = -rval;
 40432f0:	404335c0 	call	404335c <alt_get_errno>
 40432f4:	e0fff917 	ldw	r3,-28(fp)
 40432f8:	00c7c83a 	sub	r3,zero,r3
 40432fc:	10c00015 	stw	r3,0(r2)
          return -1;
 4043300:	00bfffc4 	movi	r2,-1
 4043304:	e0bffe15 	stw	r2,-8(fp)
 4043308:	00000e06 	br	4043344 <read+0x108>
        }
        return rval;
 404330c:	e0bff917 	ldw	r2,-28(fp)
 4043310:	e0bffe15 	stw	r2,-8(fp)
 4043314:	00000b06 	br	4043344 <read+0x108>
      }
      else
      {
        ALT_ERRNO = EACCES;
 4043318:	404335c0 	call	404335c <alt_get_errno>
 404331c:	1007883a 	mov	r3,r2
 4043320:	00800344 	movi	r2,13
 4043324:	18800015 	stw	r2,0(r3)
 4043328:	00000406 	br	404333c <read+0x100>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 404332c:	404335c0 	call	404335c <alt_get_errno>
 4043330:	1007883a 	mov	r3,r2
 4043334:	00801444 	movi	r2,81
 4043338:	18800015 	stw	r2,0(r3)
  }
  return -1;
 404333c:	00bfffc4 	movi	r2,-1
 4043340:	e0bffe15 	stw	r2,-8(fp)
 4043344:	e0bffe17 	ldw	r2,-8(fp)
}
 4043348:	e037883a 	mov	sp,fp
 404334c:	dfc00117 	ldw	ra,4(sp)
 4043350:	df000017 	ldw	fp,0(sp)
 4043354:	dec00204 	addi	sp,sp,8
 4043358:	f800283a 	ret

0404335c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 404335c:	defffd04 	addi	sp,sp,-12
 4043360:	dfc00215 	stw	ra,8(sp)
 4043364:	df000115 	stw	fp,4(sp)
 4043368:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 404336c:	00810174 	movhi	r2,1029
 4043370:	10a69004 	addi	r2,r2,-26048
 4043374:	10800017 	ldw	r2,0(r2)
 4043378:	1005003a 	cmpeq	r2,r2,zero
 404337c:	1000061e 	bne	r2,zero,4043398 <alt_get_errno+0x3c>
 4043380:	00810174 	movhi	r2,1029
 4043384:	10a69004 	addi	r2,r2,-26048
 4043388:	10800017 	ldw	r2,0(r2)
 404338c:	103ee83a 	callr	r2
 4043390:	e0bfff15 	stw	r2,-4(fp)
 4043394:	00000306 	br	40433a4 <alt_get_errno+0x48>
 4043398:	00810174 	movhi	r2,1029
 404339c:	10ad6404 	addi	r2,r2,-19056
 40433a0:	e0bfff15 	stw	r2,-4(fp)
 40433a4:	e0bfff17 	ldw	r2,-4(fp)
}
 40433a8:	e037883a 	mov	sp,fp
 40433ac:	dfc00117 	ldw	ra,4(sp)
 40433b0:	df000017 	ldw	fp,0(sp)
 40433b4:	dec00204 	addi	sp,sp,8
 40433b8:	f800283a 	ret

040433bc <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 40433bc:	defffe04 	addi	sp,sp,-8
 40433c0:	df000115 	stw	fp,4(sp)
 40433c4:	df000104 	addi	fp,sp,4
 40433c8:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 40433cc:	e0bfff17 	ldw	r2,-4(fp)
 40433d0:	108000d0 	cmplti	r2,r2,3
 40433d4:	10000d1e 	bne	r2,zero,404340c <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 40433d8:	e0bfff17 	ldw	r2,-4(fp)
 40433dc:	00c10174 	movhi	r3,1029
 40433e0:	18e1d904 	addi	r3,r3,-30876
 40433e4:	10800324 	muli	r2,r2,12
 40433e8:	10c5883a 	add	r2,r2,r3
 40433ec:	10800204 	addi	r2,r2,8
 40433f0:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 40433f4:	e0bfff17 	ldw	r2,-4(fp)
 40433f8:	00c10174 	movhi	r3,1029
 40433fc:	18e1d904 	addi	r3,r3,-30876
 4043400:	10800324 	muli	r2,r2,12
 4043404:	10c5883a 	add	r2,r2,r3
 4043408:	10000015 	stw	zero,0(r2)
  }
}
 404340c:	e037883a 	mov	sp,fp
 4043410:	df000017 	ldw	fp,0(sp)
 4043414:	dec00104 	addi	sp,sp,4
 4043418:	f800283a 	ret

0404341c <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 404341c:	defff804 	addi	sp,sp,-32
 4043420:	df000715 	stw	fp,28(sp)
 4043424:	df000704 	addi	fp,sp,28
 4043428:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 404342c:	0005303a 	rdctl	r2,status
 4043430:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4043434:	e0fffb17 	ldw	r3,-20(fp)
 4043438:	00bfff84 	movi	r2,-2
 404343c:	1884703a 	and	r2,r3,r2
 4043440:	1001703a 	wrctl	status,r2
  
  return context;
 4043444:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 4043448:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 404344c:	d0a00a17 	ldw	r2,-32728(gp)
 4043450:	10c000c4 	addi	r3,r2,3
 4043454:	00bfff04 	movi	r2,-4
 4043458:	1884703a 	and	r2,r3,r2
 404345c:	d0a00a15 	stw	r2,-32728(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 4043460:	d0e00a17 	ldw	r3,-32728(gp)
 4043464:	e0bffe17 	ldw	r2,-8(fp)
 4043468:	1887883a 	add	r3,r3,r2
 404346c:	008101f4 	movhi	r2,1031
 4043470:	10880004 	addi	r2,r2,8192
 4043474:	10c0072e 	bgeu	r2,r3,4043494 <sbrk+0x78>
 4043478:	e0bffd17 	ldw	r2,-12(fp)
 404347c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4043480:	e0bffa17 	ldw	r2,-24(fp)
 4043484:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 4043488:	00bfffc4 	movi	r2,-1
 404348c:	e0bfff15 	stw	r2,-4(fp)
 4043490:	00000c06 	br	40434c4 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 4043494:	d0a00a17 	ldw	r2,-32728(gp)
 4043498:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
 404349c:	d0e00a17 	ldw	r3,-32728(gp)
 40434a0:	e0bffe17 	ldw	r2,-8(fp)
 40434a4:	1885883a 	add	r2,r3,r2
 40434a8:	d0a00a15 	stw	r2,-32728(gp)
 40434ac:	e0bffd17 	ldw	r2,-12(fp)
 40434b0:	e0bff915 	stw	r2,-28(fp)
 40434b4:	e0bff917 	ldw	r2,-28(fp)
 40434b8:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 40434bc:	e0bffc17 	ldw	r2,-16(fp)
 40434c0:	e0bfff15 	stw	r2,-4(fp)
 40434c4:	e0bfff17 	ldw	r2,-4(fp)
} 
 40434c8:	e037883a 	mov	sp,fp
 40434cc:	df000017 	ldw	fp,0(sp)
 40434d0:	dec00104 	addi	sp,sp,4
 40434d4:	f800283a 	ret

040434d8 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 40434d8:	defff704 	addi	sp,sp,-36
 40434dc:	dfc00815 	stw	ra,32(sp)
 40434e0:	df000715 	stw	fp,28(sp)
 40434e4:	df000704 	addi	fp,sp,28
 40434e8:	e13ffb15 	stw	r4,-20(fp)
 40434ec:	e17ffc15 	stw	r5,-16(fp)
 40434f0:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 40434f4:	e0bffb17 	ldw	r2,-20(fp)
 40434f8:	1004803a 	cmplt	r2,r2,zero
 40434fc:	1000081e 	bne	r2,zero,4043520 <write+0x48>
 4043500:	e0bffb17 	ldw	r2,-20(fp)
 4043504:	10800324 	muli	r2,r2,12
 4043508:	1007883a 	mov	r3,r2
 404350c:	00810174 	movhi	r2,1029
 4043510:	10a1d904 	addi	r2,r2,-30876
 4043514:	1887883a 	add	r3,r3,r2
 4043518:	e0ffff15 	stw	r3,-4(fp)
 404351c:	00000106 	br	4043524 <write+0x4c>
 4043520:	e03fff15 	stw	zero,-4(fp)
 4043524:	e0bfff17 	ldw	r2,-4(fp)
 4043528:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 404352c:	e0bffa17 	ldw	r2,-24(fp)
 4043530:	1005003a 	cmpeq	r2,r2,zero
 4043534:	1000241e 	bne	r2,zero,40435c8 <write+0xf0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 4043538:	e0bffa17 	ldw	r2,-24(fp)
 404353c:	10800217 	ldw	r2,8(r2)
 4043540:	108000cc 	andi	r2,r2,3
 4043544:	1005003a 	cmpeq	r2,r2,zero
 4043548:	10001a1e 	bne	r2,zero,40435b4 <write+0xdc>
 404354c:	e0bffa17 	ldw	r2,-24(fp)
 4043550:	10800017 	ldw	r2,0(r2)
 4043554:	10800617 	ldw	r2,24(r2)
 4043558:	1005003a 	cmpeq	r2,r2,zero
 404355c:	1000151e 	bne	r2,zero,40435b4 <write+0xdc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 4043560:	e0bffa17 	ldw	r2,-24(fp)
 4043564:	10800017 	ldw	r2,0(r2)
 4043568:	10800617 	ldw	r2,24(r2)
 404356c:	e17ffc17 	ldw	r5,-16(fp)
 4043570:	e1bffd17 	ldw	r6,-12(fp)
 4043574:	e13ffa17 	ldw	r4,-24(fp)
 4043578:	103ee83a 	callr	r2
 404357c:	e0bff915 	stw	r2,-28(fp)
 4043580:	e0bff917 	ldw	r2,-28(fp)
 4043584:	1004403a 	cmpge	r2,r2,zero
 4043588:	1000071e 	bne	r2,zero,40435a8 <write+0xd0>
      {
        ALT_ERRNO = -rval;
 404358c:	40435f80 	call	40435f8 <alt_get_errno>
 4043590:	e0fff917 	ldw	r3,-28(fp)
 4043594:	00c7c83a 	sub	r3,zero,r3
 4043598:	10c00015 	stw	r3,0(r2)
        return -1;
 404359c:	00bfffc4 	movi	r2,-1
 40435a0:	e0bffe15 	stw	r2,-8(fp)
 40435a4:	00000e06 	br	40435e0 <write+0x108>
      }
      return rval;
 40435a8:	e0bff917 	ldw	r2,-28(fp)
 40435ac:	e0bffe15 	stw	r2,-8(fp)
 40435b0:	00000b06 	br	40435e0 <write+0x108>
    }
    else
    {
      ALT_ERRNO = EACCES;
 40435b4:	40435f80 	call	40435f8 <alt_get_errno>
 40435b8:	1007883a 	mov	r3,r2
 40435bc:	00800344 	movi	r2,13
 40435c0:	18800015 	stw	r2,0(r3)
 40435c4:	00000406 	br	40435d8 <write+0x100>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 40435c8:	40435f80 	call	40435f8 <alt_get_errno>
 40435cc:	1007883a 	mov	r3,r2
 40435d0:	00801444 	movi	r2,81
 40435d4:	18800015 	stw	r2,0(r3)
  }
  return -1;
 40435d8:	00bfffc4 	movi	r2,-1
 40435dc:	e0bffe15 	stw	r2,-8(fp)
 40435e0:	e0bffe17 	ldw	r2,-8(fp)
}
 40435e4:	e037883a 	mov	sp,fp
 40435e8:	dfc00117 	ldw	ra,4(sp)
 40435ec:	df000017 	ldw	fp,0(sp)
 40435f0:	dec00204 	addi	sp,sp,8
 40435f4:	f800283a 	ret

040435f8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 40435f8:	defffd04 	addi	sp,sp,-12
 40435fc:	dfc00215 	stw	ra,8(sp)
 4043600:	df000115 	stw	fp,4(sp)
 4043604:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 4043608:	00810174 	movhi	r2,1029
 404360c:	10a69004 	addi	r2,r2,-26048
 4043610:	10800017 	ldw	r2,0(r2)
 4043614:	1005003a 	cmpeq	r2,r2,zero
 4043618:	1000061e 	bne	r2,zero,4043634 <alt_get_errno+0x3c>
 404361c:	00810174 	movhi	r2,1029
 4043620:	10a69004 	addi	r2,r2,-26048
 4043624:	10800017 	ldw	r2,0(r2)
 4043628:	103ee83a 	callr	r2
 404362c:	e0bfff15 	stw	r2,-4(fp)
 4043630:	00000306 	br	4043640 <alt_get_errno+0x48>
 4043634:	00810174 	movhi	r2,1029
 4043638:	10ad6404 	addi	r2,r2,-19056
 404363c:	e0bfff15 	stw	r2,-4(fp)
 4043640:	e0bfff17 	ldw	r2,-4(fp)
}
 4043644:	e037883a 	mov	sp,fp
 4043648:	dfc00117 	ldw	ra,4(sp)
 404364c:	df000017 	ldw	fp,0(sp)
 4043650:	dec00204 	addi	sp,sp,8
 4043654:	f800283a 	ret

04043658 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 4043658:	defffd04 	addi	sp,sp,-12
 404365c:	dfc00215 	stw	ra,8(sp)
 4043660:	df000115 	stw	fp,4(sp)
 4043664:	df000104 	addi	fp,sp,4
 4043668:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2_QSYS, nios2_qsys);
 404366c:	4046c2c0 	call	4046c2c <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 4043670:	00800044 	movi	r2,1
 4043674:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 4043678:	e037883a 	mov	sp,fp
 404367c:	dfc00117 	ldw	ra,4(sp)
 4043680:	df000017 	ldw	fp,0(sp)
 4043684:	dec00204 	addi	sp,sp,8
 4043688:	f800283a 	ret

0404368c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 404368c:	defffe04 	addi	sp,sp,-8
 4043690:	dfc00115 	stw	ra,4(sp)
 4043694:	df000015 	stw	fp,0(sp)
 4043698:	d839883a 	mov	fp,sp
    ALTERA_AVALON_CFI_FLASH_INIT ( CFI_FLASH, cfi_flash);
 404369c:	01010174 	movhi	r4,1029
 40436a0:	21223904 	addi	r4,r4,-30492
 40436a4:	40437140 	call	4043714 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 40436a8:	01010174 	movhi	r4,1029
 40436ac:	21227904 	addi	r4,r4,-30236
 40436b0:	000b883a 	mov	r5,zero
 40436b4:	000d883a 	mov	r6,zero
 40436b8:	404556c0 	call	404556c <altera_avalon_jtag_uart_init>
 40436bc:	01010174 	movhi	r4,1029
 40436c0:	21226f04 	addi	r4,r4,-30276
 40436c4:	40436dc0 	call	40436dc <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
}
 40436c8:	e037883a 	mov	sp,fp
 40436cc:	dfc00117 	ldw	ra,4(sp)
 40436d0:	df000017 	ldw	fp,0(sp)
 40436d4:	dec00204 	addi	sp,sp,8
 40436d8:	f800283a 	ret

040436dc <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 40436dc:	defffd04 	addi	sp,sp,-12
 40436e0:	dfc00215 	stw	ra,8(sp)
 40436e4:	df000115 	stw	fp,4(sp)
 40436e8:	df000104 	addi	fp,sp,4
 40436ec:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 40436f0:	e13fff17 	ldw	r4,-4(fp)
 40436f4:	01410174 	movhi	r5,1029
 40436f8:	29668d04 	addi	r5,r5,-26060
 40436fc:	40460e00 	call	40460e0 <alt_dev_llist_insert>
}
 4043700:	e037883a 	mov	sp,fp
 4043704:	dfc00117 	ldw	ra,4(sp)
 4043708:	df000017 	ldw	fp,0(sp)
 404370c:	dec00204 	addi	sp,sp,8
 4043710:	f800283a 	ret

04043714 <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
 4043714:	defffc04 	addi	sp,sp,-16
 4043718:	dfc00315 	stw	ra,12(sp)
 404371c:	df000215 	stw	fp,8(sp)
 4043720:	df000204 	addi	fp,sp,8
 4043724:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 4043728:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
 404372c:	e13fff17 	ldw	r4,-4(fp)
 4043730:	4044b9c0 	call	4044b9c <alt_read_cfi_width>
 4043734:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 4043738:	e0bffe17 	ldw	r2,-8(fp)
 404373c:	1004c03a 	cmpne	r2,r2,zero
 4043740:	1000031e 	bne	r2,zero,4043750 <alt_flash_cfi_init+0x3c>
    ret_code = alt_set_flash_width_func( flash );
 4043744:	e13fff17 	ldw	r4,-4(fp)
 4043748:	40443140 	call	4044314 <alt_set_flash_width_func>
 404374c:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 4043750:	e0bffe17 	ldw	r2,-8(fp)
 4043754:	1004c03a 	cmpne	r2,r2,zero
 4043758:	1000031e 	bne	r2,zero,4043768 <alt_flash_cfi_init+0x54>
    ret_code = alt_read_cfi_table( flash );
 404375c:	e13fff17 	ldw	r4,-4(fp)
 4043760:	404461c0 	call	404461c <alt_read_cfi_table>
 4043764:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
 4043768:	e0bffe17 	ldw	r2,-8(fp)
 404376c:	1004c03a 	cmpne	r2,r2,zero
 4043770:	1000031e 	bne	r2,zero,4043780 <alt_flash_cfi_init+0x6c>
    ret_code = alt_set_flash_algorithm_func( flash);
 4043774:	e13fff17 	ldw	r4,-4(fp)
 4043778:	40444f40 	call	40444f4 <alt_set_flash_algorithm_func>
 404377c:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
 4043780:	e0bffe17 	ldw	r2,-8(fp)
 4043784:	1004c03a 	cmpne	r2,r2,zero
 4043788:	1000031e 	bne	r2,zero,4043798 <alt_flash_cfi_init+0x84>
    ret_code = alt_flash_device_register(&(flash->dev));
 404378c:	e13fff17 	ldw	r4,-4(fp)
 4043790:	40437b00 	call	40437b0 <alt_flash_device_register>
 4043794:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
 4043798:	e0bffe17 	ldw	r2,-8(fp)
}
 404379c:	e037883a 	mov	sp,fp
 40437a0:	dfc00117 	ldw	ra,4(sp)
 40437a4:	df000017 	ldw	fp,0(sp)
 40437a8:	dec00204 	addi	sp,sp,8
 40437ac:	f800283a 	ret

040437b0 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 40437b0:	defffd04 	addi	sp,sp,-12
 40437b4:	dfc00215 	stw	ra,8(sp)
 40437b8:	df000115 	stw	fp,4(sp)
 40437bc:	df000104 	addi	fp,sp,4
 40437c0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 40437c4:	e13fff17 	ldw	r4,-4(fp)
 40437c8:	01410174 	movhi	r5,1029
 40437cc:	29669204 	addi	r5,r5,-26040
 40437d0:	40460e00 	call	40460e0 <alt_dev_llist_insert>
}
 40437d4:	e037883a 	mov	sp,fp
 40437d8:	dfc00117 	ldw	ra,4(sp)
 40437dc:	df000017 	ldw	fp,0(sp)
 40437e0:	dec00204 	addi	sp,sp,8
 40437e4:	f800283a 	ret

040437e8 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
 40437e8:	deffef04 	addi	sp,sp,-68
 40437ec:	dfc01015 	stw	ra,64(sp)
 40437f0:	df000f15 	stw	fp,60(sp)
 40437f4:	df000f04 	addi	fp,sp,60
 40437f8:	e13ffa15 	stw	r4,-24(fp)
 40437fc:	e17ffb15 	stw	r5,-20(fp)
 4043800:	e1bffc15 	stw	r6,-16(fp)
 4043804:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 4043808:	e03ff915 	stw	zero,-28(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
 404380c:	e0bffd17 	ldw	r2,-12(fp)
 4043810:	e0bff515 	stw	r2,-44(fp)
  int         current_offset;
  int         start_offset = offset;
 4043814:	e0bffb17 	ldw	r2,-20(fp)
 4043818:	e0bff315 	stw	r2,-52(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 404381c:	e0bffa17 	ldw	r2,-24(fp)
 4043820:	e0bff215 	stw	r2,-56(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 4043824:	e03ff815 	stw	zero,-32(fp)
 4043828:	00008e06 	br	4043a64 <alt_flash_cfi_write+0x27c>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 404382c:	e0bff817 	ldw	r2,-32(fp)
 4043830:	e0fff217 	ldw	r3,-56(fp)
 4043834:	1004913a 	slli	r2,r2,4
 4043838:	10c5883a 	add	r2,r2,r3
 404383c:	10800d04 	addi	r2,r2,52
 4043840:	10c00017 	ldw	r3,0(r2)
 4043844:	e0bffb17 	ldw	r2,-20(fp)
 4043848:	10c08316 	blt	r2,r3,4043a58 <alt_flash_cfi_write+0x270>
 404384c:	e0bff817 	ldw	r2,-32(fp)
 4043850:	e0fff217 	ldw	r3,-56(fp)
 4043854:	1004913a 	slli	r2,r2,4
 4043858:	10c5883a 	add	r2,r2,r3
 404385c:	10800d04 	addi	r2,r2,52
 4043860:	11000017 	ldw	r4,0(r2)
 4043864:	e0bff817 	ldw	r2,-32(fp)
 4043868:	e0fff217 	ldw	r3,-56(fp)
 404386c:	1004913a 	slli	r2,r2,4
 4043870:	10c5883a 	add	r2,r2,r3
 4043874:	10800e04 	addi	r2,r2,56
 4043878:	10800017 	ldw	r2,0(r2)
 404387c:	2087883a 	add	r3,r4,r2
 4043880:	e0bffb17 	ldw	r2,-20(fp)
 4043884:	10c0740e 	bge	r2,r3,4043a58 <alt_flash_cfi_write+0x270>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
 4043888:	e0bff817 	ldw	r2,-32(fp)
 404388c:	e0fff217 	ldw	r3,-56(fp)
 4043890:	1004913a 	slli	r2,r2,4
 4043894:	10c5883a 	add	r2,r2,r3
 4043898:	10800d04 	addi	r2,r2,52
 404389c:	10800017 	ldw	r2,0(r2)
 40438a0:	e0bff415 	stw	r2,-48(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 40438a4:	e03ff715 	stw	zero,-36(fp)
 40438a8:	00006306 	br	4043a38 <alt_flash_cfi_write+0x250>
      {
        if ((offset >= current_offset ) && 
 40438ac:	e0fffb17 	ldw	r3,-20(fp)
 40438b0:	e0bff417 	ldw	r2,-48(fp)
 40438b4:	18805416 	blt	r3,r2,4043a08 <alt_flash_cfi_write+0x220>
 40438b8:	e0bff817 	ldw	r2,-32(fp)
 40438bc:	e0fff217 	ldw	r3,-56(fp)
 40438c0:	1004913a 	slli	r2,r2,4
 40438c4:	10c5883a 	add	r2,r2,r3
 40438c8:	10801004 	addi	r2,r2,64
 40438cc:	10c00017 	ldw	r3,0(r2)
 40438d0:	e0bff417 	ldw	r2,-48(fp)
 40438d4:	1887883a 	add	r3,r3,r2
 40438d8:	e0bffb17 	ldw	r2,-20(fp)
 40438dc:	10c04a0e 	bge	r2,r3,4043a08 <alt_flash_cfi_write+0x220>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
 40438e0:	e0bff817 	ldw	r2,-32(fp)
 40438e4:	e0fff217 	ldw	r3,-56(fp)
 40438e8:	1004913a 	slli	r2,r2,4
 40438ec:	10c5883a 	add	r2,r2,r3
 40438f0:	10801004 	addi	r2,r2,64
 40438f4:	10c00017 	ldw	r3,0(r2)
 40438f8:	e0bff417 	ldw	r2,-48(fp)
 40438fc:	1887883a 	add	r3,r3,r2
 4043900:	e0bffb17 	ldw	r2,-20(fp)
 4043904:	1885c83a 	sub	r2,r3,r2
 4043908:	e0bff615 	stw	r2,-40(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
 404390c:	e0bff617 	ldw	r2,-40(fp)
 4043910:	e0bfff15 	stw	r2,-4(fp)
 4043914:	e0fffd17 	ldw	r3,-12(fp)
 4043918:	e0fffe15 	stw	r3,-8(fp)
 404391c:	e0bfff17 	ldw	r2,-4(fp)
 4043920:	e0fffe17 	ldw	r3,-8(fp)
 4043924:	10c0020e 	bge	r2,r3,4043930 <alt_flash_cfi_write+0x148>
 4043928:	e0bfff17 	ldw	r2,-4(fp)
 404392c:	e0bffe15 	stw	r2,-8(fp)
 4043930:	e0fffe17 	ldw	r3,-8(fp)
 4043934:	e0fff615 	stw	r3,-40(fp)
          if(memcmp(src_addr, 
 4043938:	e0bff217 	ldw	r2,-56(fp)
 404393c:	10800a17 	ldw	r2,40(r2)
 4043940:	1007883a 	mov	r3,r2
 4043944:	e0bffb17 	ldw	r2,-20(fp)
 4043948:	188b883a 	add	r5,r3,r2
 404394c:	e1bff617 	ldw	r6,-40(fp)
 4043950:	e13ffc17 	ldw	r4,-16(fp)
 4043954:	40479d00 	call	40479d0 <memcmp>
 4043958:	1005003a 	cmpeq	r2,r2,zero
 404395c:	1000131e 	bne	r2,zero,40439ac <alt_flash_cfi_write+0x1c4>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
 4043960:	e0bff217 	ldw	r2,-56(fp)
 4043964:	10800817 	ldw	r2,32(r2)
 4043968:	e13ff217 	ldw	r4,-56(fp)
 404396c:	e17ff417 	ldw	r5,-48(fp)
 4043970:	103ee83a 	callr	r2
 4043974:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 4043978:	e0bff917 	ldw	r2,-28(fp)
 404397c:	1004c03a 	cmpne	r2,r2,zero
 4043980:	10000a1e 	bne	r2,zero,40439ac <alt_flash_cfi_write+0x1c4>
            {
              ret_code = (*flash->dev.write_block)( 
 4043984:	e0bff217 	ldw	r2,-56(fp)
 4043988:	10c00917 	ldw	r3,36(r2)
 404398c:	e13ff217 	ldw	r4,-56(fp)
 4043990:	e0bff617 	ldw	r2,-40(fp)
 4043994:	d8800015 	stw	r2,0(sp)
 4043998:	e17ff417 	ldw	r5,-48(fp)
 404399c:	e1bffb17 	ldw	r6,-20(fp)
 40439a0:	e1fffc17 	ldw	r7,-16(fp)
 40439a4:	183ee83a 	callr	r3
 40439a8:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
 40439ac:	e0fffd17 	ldw	r3,-12(fp)
 40439b0:	e0bff617 	ldw	r2,-40(fp)
 40439b4:	18802f26 	beq	r3,r2,4043a74 <alt_flash_cfi_write+0x28c>
 40439b8:	e0bff917 	ldw	r2,-28(fp)
 40439bc:	1004c03a 	cmpne	r2,r2,zero
 40439c0:	10002c1e 	bne	r2,zero,4043a74 <alt_flash_cfi_write+0x28c>
          {
            goto finished;
          }
          
          length -= data_to_write;
 40439c4:	e0fffd17 	ldw	r3,-12(fp)
 40439c8:	e0bff617 	ldw	r2,-40(fp)
 40439cc:	1885c83a 	sub	r2,r3,r2
 40439d0:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
 40439d4:	e0bff817 	ldw	r2,-32(fp)
 40439d8:	e0fff217 	ldw	r3,-56(fp)
 40439dc:	1004913a 	slli	r2,r2,4
 40439e0:	10c5883a 	add	r2,r2,r3
 40439e4:	10801004 	addi	r2,r2,64
 40439e8:	10c00017 	ldw	r3,0(r2)
 40439ec:	e0bff417 	ldw	r2,-48(fp)
 40439f0:	1885883a 	add	r2,r3,r2
 40439f4:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 40439f8:	e0fffc17 	ldw	r3,-16(fp)
 40439fc:	e0bff617 	ldw	r2,-40(fp)
 4043a00:	1885883a 	add	r2,r3,r2
 4043a04:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
 4043a08:	e0bff817 	ldw	r2,-32(fp)
 4043a0c:	e0fff217 	ldw	r3,-56(fp)
 4043a10:	1004913a 	slli	r2,r2,4
 4043a14:	10c5883a 	add	r2,r2,r3
 4043a18:	10801004 	addi	r2,r2,64
 4043a1c:	10c00017 	ldw	r3,0(r2)
 4043a20:	e0bff417 	ldw	r2,-48(fp)
 4043a24:	10c5883a 	add	r2,r2,r3
 4043a28:	e0bff415 	stw	r2,-48(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 4043a2c:	e0bff717 	ldw	r2,-36(fp)
 4043a30:	10800044 	addi	r2,r2,1
 4043a34:	e0bff715 	stw	r2,-36(fp)
 4043a38:	e0bff817 	ldw	r2,-32(fp)
 4043a3c:	e0fff217 	ldw	r3,-56(fp)
 4043a40:	1004913a 	slli	r2,r2,4
 4043a44:	10c5883a 	add	r2,r2,r3
 4043a48:	10800f04 	addi	r2,r2,60
 4043a4c:	10c00017 	ldw	r3,0(r2)
 4043a50:	e0bff717 	ldw	r2,-36(fp)
 4043a54:	10ff9516 	blt	r2,r3,40438ac <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 4043a58:	e0bff817 	ldw	r2,-32(fp)
 4043a5c:	10800044 	addi	r2,r2,1
 4043a60:	e0bff815 	stw	r2,-32(fp)
 4043a64:	e0bff217 	ldw	r2,-56(fp)
 4043a68:	10c00c17 	ldw	r3,48(r2)
 4043a6c:	e0bff817 	ldw	r2,-32(fp)
 4043a70:	10ff6e16 	blt	r2,r3,404382c <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 4043a74:	e0bff217 	ldw	r2,-56(fp)
 4043a78:	10800a17 	ldw	r2,40(r2)
 4043a7c:	1007883a 	mov	r3,r2
 4043a80:	e0bff317 	ldw	r2,-52(fp)
 4043a84:	1889883a 	add	r4,r3,r2
 4043a88:	e17ff517 	ldw	r5,-44(fp)
 4043a8c:	40460240 	call	4046024 <alt_dcache_flush>
  return ret_code;
 4043a90:	e0bff917 	ldw	r2,-28(fp)
}
 4043a94:	e037883a 	mov	sp,fp
 4043a98:	dfc00117 	ldw	ra,4(sp)
 4043a9c:	df000017 	ldw	fp,0(sp)
 4043aa0:	dec00204 	addi	sp,sp,8
 4043aa4:	f800283a 	ret

04043aa8 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
 4043aa8:	defffa04 	addi	sp,sp,-24
 4043aac:	df000515 	stw	fp,20(sp)
 4043ab0:	df000504 	addi	fp,sp,20
 4043ab4:	e13ffd15 	stw	r4,-12(fp)
 4043ab8:	e17ffe15 	stw	r5,-8(fp)
 4043abc:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 4043ac0:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
 4043ac4:	e0bffd17 	ldw	r2,-12(fp)
 4043ac8:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 4043acc:	e0bffb17 	ldw	r2,-20(fp)
 4043ad0:	10c00c17 	ldw	r3,48(r2)
 4043ad4:	e0bfff17 	ldw	r2,-4(fp)
 4043ad8:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 4043adc:	e0bffb17 	ldw	r2,-20(fp)
 4043ae0:	10800c17 	ldw	r2,48(r2)
 4043ae4:	1004c03a 	cmpne	r2,r2,zero
 4043ae8:	1000031e 	bne	r2,zero,4043af8 <alt_flash_cfi_get_info+0x50>
  {
    ret_code = -EIO;
 4043aec:	00bffec4 	movi	r2,-5
 4043af0:	e0bffc15 	stw	r2,-16(fp)
 4043af4:	00000b06 	br	4043b24 <alt_flash_cfi_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 4043af8:	e0bffb17 	ldw	r2,-20(fp)
 4043afc:	10800c17 	ldw	r2,48(r2)
 4043b00:	10800250 	cmplti	r2,r2,9
 4043b04:	1000031e 	bne	r2,zero,4043b14 <alt_flash_cfi_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 4043b08:	00bffd04 	movi	r2,-12
 4043b0c:	e0bffc15 	stw	r2,-16(fp)
 4043b10:	00000406 	br	4043b24 <alt_flash_cfi_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 4043b14:	e0bffb17 	ldw	r2,-20(fp)
 4043b18:	10c00d04 	addi	r3,r2,52
 4043b1c:	e0bffe17 	ldw	r2,-8(fp)
 4043b20:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 4043b24:	e0bffc17 	ldw	r2,-16(fp)
}
 4043b28:	e037883a 	mov	sp,fp
 4043b2c:	df000017 	ldw	fp,0(sp)
 4043b30:	dec00104 	addi	sp,sp,4
 4043b34:	f800283a 	ret

04043b38 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
 4043b38:	defff904 	addi	sp,sp,-28
 4043b3c:	dfc00615 	stw	ra,24(sp)
 4043b40:	df000515 	stw	fp,20(sp)
 4043b44:	df000504 	addi	fp,sp,20
 4043b48:	e13ffc15 	stw	r4,-16(fp)
 4043b4c:	e17ffd15 	stw	r5,-12(fp)
 4043b50:	e1bffe15 	stw	r6,-8(fp)
 4043b54:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 4043b58:	e0bffc17 	ldw	r2,-16(fp)
 4043b5c:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 4043b60:	e0bffb17 	ldw	r2,-20(fp)
 4043b64:	10800a17 	ldw	r2,40(r2)
 4043b68:	1007883a 	mov	r3,r2
 4043b6c:	e0bffd17 	ldw	r2,-12(fp)
 4043b70:	1887883a 	add	r3,r3,r2
 4043b74:	e1bfff17 	ldw	r6,-4(fp)
 4043b78:	e0bffe17 	ldw	r2,-8(fp)
 4043b7c:	1009883a 	mov	r4,r2
 4043b80:	180b883a 	mov	r5,r3
 4043b84:	40410500 	call	4041050 <memcpy>
  return 0;
 4043b88:	0005883a 	mov	r2,zero
}
 4043b8c:	e037883a 	mov	sp,fp
 4043b90:	dfc00117 	ldw	ra,4(sp)
 4043b94:	df000017 	ldw	fp,0(sp)
 4043b98:	dec00204 	addi	sp,sp,8
 4043b9c:	f800283a 	ret

04043ba0 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
 4043ba0:	defffa04 	addi	sp,sp,-24
 4043ba4:	df000515 	stw	fp,20(sp)
 4043ba8:	df000504 	addi	fp,sp,20
 4043bac:	e13ffd15 	stw	r4,-12(fp)
 4043bb0:	e17ffe15 	stw	r5,-8(fp)
 4043bb4:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
 4043bb8:	e0bffd17 	ldw	r2,-12(fp)
 4043bbc:	10802e17 	ldw	r2,184(r2)
 4043bc0:	10800058 	cmpnei	r2,r2,1
 4043bc4:	10000b1e 	bne	r2,zero,4043bf4 <alt_write_value_to_flash+0x54>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
 4043bc8:	e0bffd17 	ldw	r2,-12(fp)
 4043bcc:	10800a17 	ldw	r2,40(r2)
 4043bd0:	1007883a 	mov	r3,r2
 4043bd4:	e0bffe17 	ldw	r2,-8(fp)
 4043bd8:	1889883a 	add	r4,r3,r2
 4043bdc:	e0bfff17 	ldw	r2,-4(fp)
 4043be0:	10800003 	ldbu	r2,0(r2)
 4043be4:	10c03fcc 	andi	r3,r2,255
 4043be8:	2005883a 	mov	r2,r4
 4043bec:	10c00025 	stbio	r3,0(r2)
 4043bf0:	00004006 	br	4043cf4 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 2)
 4043bf4:	e0bffd17 	ldw	r2,-12(fp)
 4043bf8:	10802e17 	ldw	r2,184(r2)
 4043bfc:	10800098 	cmpnei	r2,r2,2
 4043c00:	1000151e 	bne	r2,zero,4043c58 <alt_write_value_to_flash+0xb8>
  {
    half_word_value = (alt_u16)(*src_addr);
 4043c04:	e0bfff17 	ldw	r2,-4(fp)
 4043c08:	10800003 	ldbu	r2,0(r2)
 4043c0c:	10803fcc 	andi	r2,r2,255
 4043c10:	e0bffc0d 	sth	r2,-16(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
 4043c14:	e0bfff17 	ldw	r2,-4(fp)
 4043c18:	10800044 	addi	r2,r2,1
 4043c1c:	10800003 	ldbu	r2,0(r2)
 4043c20:	10803fcc 	andi	r2,r2,255
 4043c24:	1004923a 	slli	r2,r2,8
 4043c28:	1007883a 	mov	r3,r2
 4043c2c:	e0bffc0b 	ldhu	r2,-16(fp)
 4043c30:	1884b03a 	or	r2,r3,r2
 4043c34:	e0bffc0d 	sth	r2,-16(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
 4043c38:	e0bffd17 	ldw	r2,-12(fp)
 4043c3c:	10800a17 	ldw	r2,40(r2)
 4043c40:	1007883a 	mov	r3,r2
 4043c44:	e0bffe17 	ldw	r2,-8(fp)
 4043c48:	1885883a 	add	r2,r3,r2
 4043c4c:	e0fffc0b 	ldhu	r3,-16(fp)
 4043c50:	10c0002d 	sthio	r3,0(r2)
 4043c54:	00002706 	br	4043cf4 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 4)
 4043c58:	e0bffd17 	ldw	r2,-12(fp)
 4043c5c:	10802e17 	ldw	r2,184(r2)
 4043c60:	10800118 	cmpnei	r2,r2,4
 4043c64:	1000231e 	bne	r2,zero,4043cf4 <alt_write_value_to_flash+0x154>
  {
    word_value = (alt_u32)(*src_addr);
 4043c68:	e0bfff17 	ldw	r2,-4(fp)
 4043c6c:	10800003 	ldbu	r2,0(r2)
 4043c70:	10803fcc 	andi	r2,r2,255
 4043c74:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
 4043c78:	e0bfff17 	ldw	r2,-4(fp)
 4043c7c:	10800044 	addi	r2,r2,1
 4043c80:	10800003 	ldbu	r2,0(r2)
 4043c84:	10803fcc 	andi	r2,r2,255
 4043c88:	1006923a 	slli	r3,r2,8
 4043c8c:	e0bffb17 	ldw	r2,-20(fp)
 4043c90:	10c4b03a 	or	r2,r2,r3
 4043c94:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
 4043c98:	e0bfff17 	ldw	r2,-4(fp)
 4043c9c:	10800084 	addi	r2,r2,2
 4043ca0:	10800003 	ldbu	r2,0(r2)
 4043ca4:	10803fcc 	andi	r2,r2,255
 4043ca8:	1006943a 	slli	r3,r2,16
 4043cac:	e0bffb17 	ldw	r2,-20(fp)
 4043cb0:	10c4b03a 	or	r2,r2,r3
 4043cb4:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
 4043cb8:	e0bfff17 	ldw	r2,-4(fp)
 4043cbc:	108000c4 	addi	r2,r2,3
 4043cc0:	10800003 	ldbu	r2,0(r2)
 4043cc4:	10803fcc 	andi	r2,r2,255
 4043cc8:	1006963a 	slli	r3,r2,24
 4043ccc:	e0bffb17 	ldw	r2,-20(fp)
 4043cd0:	10c4b03a 	or	r2,r2,r3
 4043cd4:	e0bffb15 	stw	r2,-20(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
 4043cd8:	e0bffd17 	ldw	r2,-12(fp)
 4043cdc:	10800a17 	ldw	r2,40(r2)
 4043ce0:	1007883a 	mov	r3,r2
 4043ce4:	e0bffe17 	ldw	r2,-8(fp)
 4043ce8:	1885883a 	add	r2,r3,r2
 4043cec:	e0fffb17 	ldw	r3,-20(fp)
 4043cf0:	10c00035 	stwio	r3,0(r2)
  }

  return;
}
 4043cf4:	e037883a 	mov	sp,fp
 4043cf8:	df000017 	ldw	fp,0(sp)
 4043cfc:	dec00104 	addi	sp,sp,4
 4043d00:	f800283a 	ret

04043d04 <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
 4043d04:	defff304 	addi	sp,sp,-52
 4043d08:	dfc00c15 	stw	ra,48(sp)
 4043d0c:	df000b15 	stw	fp,44(sp)
 4043d10:	df000b04 	addi	fp,sp,44
 4043d14:	e13ffc15 	stw	r4,-16(fp)
 4043d18:	e17ffd15 	stw	r5,-12(fp)
 4043d1c:	e1bffe15 	stw	r6,-8(fp)
 4043d20:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
 4043d24:	e03ffa15 	stw	zero,-24(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 4043d28:	e0bffc17 	ldw	r2,-16(fp)
 4043d2c:	10800a17 	ldw	r2,40(r2)
 4043d30:	1007883a 	mov	r3,r2
 4043d34:	e0bffd17 	ldw	r2,-12(fp)
 4043d38:	1885883a 	add	r2,r3,r2
 4043d3c:	1009883a 	mov	r4,r2
 4043d40:	e0bffc17 	ldw	r2,-16(fp)
 4043d44:	11402e17 	ldw	r5,184(r2)
 4043d48:	4047e080 	call	4047e08 <__modsi3>
 4043d4c:	e0bff915 	stw	r2,-28(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
 4043d50:	e0bff917 	ldw	r2,-28(fp)
 4043d54:	1005003a 	cmpeq	r2,r2,zero
 4043d58:	10003a1e 	bne	r2,zero,4043e44 <alt_flash_program_block+0x140>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
 4043d5c:	e0bffc17 	ldw	r2,-16(fp)
 4043d60:	10c02e17 	ldw	r3,184(r2)
 4043d64:	e0bff917 	ldw	r2,-28(fp)
 4043d68:	1885c83a 	sub	r2,r3,r2
 4043d6c:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 4043d70:	e03ff615 	stw	zero,-40(fp)
 4043d74:	00001206 	br	4043dc0 <alt_flash_program_block+0xbc>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
 4043d78:	e17ff617 	ldw	r5,-40(fp)
 4043d7c:	e0bffc17 	ldw	r2,-16(fp)
 4043d80:	10800a17 	ldw	r2,40(r2)
 4043d84:	1009883a 	mov	r4,r2
 4043d88:	e0fffd17 	ldw	r3,-12(fp)
 4043d8c:	e0bff917 	ldw	r2,-28(fp)
 4043d90:	1887c83a 	sub	r3,r3,r2
 4043d94:	e0bff617 	ldw	r2,-40(fp)
 4043d98:	1885883a 	add	r2,r3,r2
 4043d9c:	2085883a 	add	r2,r4,r2
 4043da0:	10800023 	ldbuio	r2,0(r2)
 4043da4:	1007883a 	mov	r3,r2
 4043da8:	e0bffb04 	addi	r2,fp,-20
 4043dac:	1145883a 	add	r2,r2,r5
 4043db0:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 4043db4:	e0bff617 	ldw	r2,-40(fp)
 4043db8:	10800044 	addi	r2,r2,1
 4043dbc:	e0bff615 	stw	r2,-40(fp)
 4043dc0:	e0fff617 	ldw	r3,-40(fp)
 4043dc4:	e0bff917 	ldw	r2,-28(fp)
 4043dc8:	18bfeb16 	blt	r3,r2,4043d78 <alt_flash_program_block+0x74>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 4043dcc:	e03ff615 	stw	zero,-40(fp)
 4043dd0:	00000e06 	br	4043e0c <alt_flash_program_block+0x108>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
 4043dd4:	e0fff917 	ldw	r3,-28(fp)
 4043dd8:	e0bff617 	ldw	r2,-40(fp)
 4043ddc:	1889883a 	add	r4,r3,r2
 4043de0:	e0bff617 	ldw	r2,-40(fp)
 4043de4:	1007883a 	mov	r3,r2
 4043de8:	e0bffe17 	ldw	r2,-8(fp)
 4043dec:	1885883a 	add	r2,r3,r2
 4043df0:	10c00003 	ldbu	r3,0(r2)
 4043df4:	e0bffb04 	addi	r2,fp,-20
 4043df8:	1105883a 	add	r2,r2,r4
 4043dfc:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 4043e00:	e0bff617 	ldw	r2,-40(fp)
 4043e04:	10800044 	addi	r2,r2,1
 4043e08:	e0bff615 	stw	r2,-40(fp)
 4043e0c:	e0fff617 	ldw	r3,-40(fp)
 4043e10:	e0bff817 	ldw	r2,-32(fp)
 4043e14:	18bfef16 	blt	r3,r2,4043dd4 <alt_flash_program_block+0xd0>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
 4043e18:	e0fffd17 	ldw	r3,-12(fp)
 4043e1c:	e0bff917 	ldw	r2,-28(fp)
 4043e20:	188bc83a 	sub	r5,r3,r2
 4043e24:	e1bffb04 	addi	r6,fp,-20
 4043e28:	e0800217 	ldw	r2,8(fp)
 4043e2c:	e13ffc17 	ldw	r4,-16(fp)
 4043e30:	103ee83a 	callr	r2
 4043e34:	e0bffa15 	stw	r2,-24(fp)
    i = unaligned_bytes;
 4043e38:	e0bff817 	ldw	r2,-32(fp)
 4043e3c:	e0bff615 	stw	r2,-40(fp)
 4043e40:	00000106 	br	4043e48 <alt_flash_program_block+0x144>
  }
  else
  {
    i = 0;
 4043e44:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
 4043e48:	e0fffd17 	ldw	r3,-12(fp)
 4043e4c:	e0bfff17 	ldw	r2,-4(fp)
 4043e50:	1889883a 	add	r4,r3,r2
 4043e54:	e0bffc17 	ldw	r2,-16(fp)
 4043e58:	11402e17 	ldw	r5,184(r2)
 4043e5c:	4047e080 	call	4047e08 <__modsi3>
 4043e60:	e0bff715 	stw	r2,-36(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 4043e64:	00001006 	br	4043ea8 <alt_flash_program_block+0x1a4>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
 4043e68:	e0fffd17 	ldw	r3,-12(fp)
 4043e6c:	e0bff617 	ldw	r2,-40(fp)
 4043e70:	188b883a 	add	r5,r3,r2
 4043e74:	e0bff617 	ldw	r2,-40(fp)
 4043e78:	1007883a 	mov	r3,r2
 4043e7c:	e0bffe17 	ldw	r2,-8(fp)
 4043e80:	188d883a 	add	r6,r3,r2
 4043e84:	e0800217 	ldw	r2,8(fp)
 4043e88:	e13ffc17 	ldw	r4,-16(fp)
 4043e8c:	103ee83a 	callr	r2
 4043e90:	e0bffa15 	stw	r2,-24(fp)
    i += flash->mode_width;     
 4043e94:	e0bffc17 	ldw	r2,-16(fp)
 4043e98:	10c02e17 	ldw	r3,184(r2)
 4043e9c:	e0bff617 	ldw	r2,-40(fp)
 4043ea0:	10c5883a 	add	r2,r2,r3
 4043ea4:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 4043ea8:	e0bffa17 	ldw	r2,-24(fp)
 4043eac:	1004c03a 	cmpne	r2,r2,zero
 4043eb0:	1000051e 	bne	r2,zero,4043ec8 <alt_flash_program_block+0x1c4>
 4043eb4:	e0ffff17 	ldw	r3,-4(fp)
 4043eb8:	e0bff717 	ldw	r2,-36(fp)
 4043ebc:	1887c83a 	sub	r3,r3,r2
 4043ec0:	e0bff617 	ldw	r2,-40(fp)
 4043ec4:	10ffe816 	blt	r2,r3,4043e68 <alt_flash_program_block+0x164>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
 4043ec8:	e0bff717 	ldw	r2,-36(fp)
 4043ecc:	1005003a 	cmpeq	r2,r2,zero
 4043ed0:	10003c1e 	bne	r2,zero,4043fc4 <alt_flash_program_block+0x2c0>
 4043ed4:	e0bffa17 	ldw	r2,-24(fp)
 4043ed8:	1004c03a 	cmpne	r2,r2,zero
 4043edc:	1000391e 	bne	r2,zero,4043fc4 <alt_flash_program_block+0x2c0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
 4043ee0:	e0bffc17 	ldw	r2,-16(fp)
 4043ee4:	10c02e17 	ldw	r3,184(r2)
 4043ee8:	e0bff717 	ldw	r2,-36(fp)
 4043eec:	1885c83a 	sub	r2,r3,r2
 4043ef0:	e0bff915 	stw	r2,-28(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
 4043ef4:	e03ff515 	stw	zero,-44(fp)
 4043ef8:	00000e06 	br	4043f34 <alt_flash_program_block+0x230>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
 4043efc:	e13ff517 	ldw	r4,-44(fp)
 4043f00:	e0bff617 	ldw	r2,-40(fp)
 4043f04:	1007883a 	mov	r3,r2
 4043f08:	e0bffe17 	ldw	r2,-8(fp)
 4043f0c:	1887883a 	add	r3,r3,r2
 4043f10:	e0bff517 	ldw	r2,-44(fp)
 4043f14:	1885883a 	add	r2,r3,r2
 4043f18:	10c00003 	ldbu	r3,0(r2)
 4043f1c:	e0bffb04 	addi	r2,fp,-20
 4043f20:	1105883a 	add	r2,r2,r4
 4043f24:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
 4043f28:	e0bff517 	ldw	r2,-44(fp)
 4043f2c:	10800044 	addi	r2,r2,1
 4043f30:	e0bff515 	stw	r2,-44(fp)
 4043f34:	e0fff517 	ldw	r3,-44(fp)
 4043f38:	e0bff717 	ldw	r2,-36(fp)
 4043f3c:	18bfef16 	blt	r3,r2,4043efc <alt_flash_program_block+0x1f8>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 4043f40:	e03ff515 	stw	zero,-44(fp)
 4043f44:	00001406 	br	4043f98 <alt_flash_program_block+0x294>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
 4043f48:	e0fff717 	ldw	r3,-36(fp)
 4043f4c:	e0bff517 	ldw	r2,-44(fp)
 4043f50:	188b883a 	add	r5,r3,r2
 4043f54:	e0bffc17 	ldw	r2,-16(fp)
 4043f58:	10800a17 	ldw	r2,40(r2)
 4043f5c:	1009883a 	mov	r4,r2
 4043f60:	e0fffd17 	ldw	r3,-12(fp)
 4043f64:	e0bfff17 	ldw	r2,-4(fp)
 4043f68:	1887883a 	add	r3,r3,r2
 4043f6c:	e0bff517 	ldw	r2,-44(fp)
 4043f70:	1885883a 	add	r2,r3,r2
 4043f74:	2085883a 	add	r2,r4,r2
 4043f78:	10800023 	ldbuio	r2,0(r2)
 4043f7c:	1007883a 	mov	r3,r2
 4043f80:	e0bffb04 	addi	r2,fp,-20
 4043f84:	1145883a 	add	r2,r2,r5
 4043f88:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 4043f8c:	e0bff517 	ldw	r2,-44(fp)
 4043f90:	10800044 	addi	r2,r2,1
 4043f94:	e0bff515 	stw	r2,-44(fp)
 4043f98:	e0fff517 	ldw	r3,-44(fp)
 4043f9c:	e0bff917 	ldw	r2,-28(fp)
 4043fa0:	18bfe916 	blt	r3,r2,4043f48 <alt_flash_program_block+0x244>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
 4043fa4:	e0fffd17 	ldw	r3,-12(fp)
 4043fa8:	e0bff617 	ldw	r2,-40(fp)
 4043fac:	188b883a 	add	r5,r3,r2
 4043fb0:	e1bffb04 	addi	r6,fp,-20
 4043fb4:	e0800217 	ldw	r2,8(fp)
 4043fb8:	e13ffc17 	ldw	r4,-16(fp)
 4043fbc:	103ee83a 	callr	r2
 4043fc0:	e0bffa15 	stw	r2,-24(fp)
  }

  return ret_code;
 4043fc4:	e0bffa17 	ldw	r2,-24(fp)
}
 4043fc8:	e037883a 	mov	sp,fp
 4043fcc:	dfc00117 	ldw	ra,4(sp)
 4043fd0:	df000017 	ldw	fp,0(sp)
 4043fd4:	dec00204 	addi	sp,sp,8
 4043fd8:	f800283a 	ret

04043fdc <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
 4043fdc:	defffd04 	addi	sp,sp,-12
 4043fe0:	df000215 	stw	fp,8(sp)
 4043fe4:	df000204 	addi	fp,sp,8
 4043fe8:	e13ffe15 	stw	r4,-8(fp)
 4043fec:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
 4043ff0:	e0bffe17 	ldw	r2,-8(fp)
 4043ff4:	10800a17 	ldw	r2,40(r2)
 4043ff8:	1007883a 	mov	r3,r2
 4043ffc:	e0bfff17 	ldw	r2,-4(fp)
 4044000:	1885883a 	add	r2,r3,r2
 4044004:	10800023 	ldbuio	r2,0(r2)
 4044008:	10803fcc 	andi	r2,r2,255
}
 404400c:	e037883a 	mov	sp,fp
 4044010:	df000017 	ldw	fp,0(sp)
 4044014:	dec00104 	addi	sp,sp,4
 4044018:	f800283a 	ret

0404401c <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
 404401c:	defffd04 	addi	sp,sp,-12
 4044020:	df000215 	stw	fp,8(sp)
 4044024:	df000204 	addi	fp,sp,8
 4044028:	e13ffe15 	stw	r4,-8(fp)
 404402c:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
 4044030:	e0bffe17 	ldw	r2,-8(fp)
 4044034:	10800a17 	ldw	r2,40(r2)
 4044038:	1007883a 	mov	r3,r2
 404403c:	e0bfff17 	ldw	r2,-4(fp)
 4044040:	1085883a 	add	r2,r2,r2
 4044044:	1885883a 	add	r2,r3,r2
 4044048:	1080002b 	ldhuio	r2,0(r2)
 404404c:	10803fcc 	andi	r2,r2,255
}
 4044050:	e037883a 	mov	sp,fp
 4044054:	df000017 	ldw	fp,0(sp)
 4044058:	dec00104 	addi	sp,sp,4
 404405c:	f800283a 	ret

04044060 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
 4044060:	defffd04 	addi	sp,sp,-12
 4044064:	df000215 	stw	fp,8(sp)
 4044068:	df000204 	addi	fp,sp,8
 404406c:	e13ffe15 	stw	r4,-8(fp)
 4044070:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
 4044074:	e0bffe17 	ldw	r2,-8(fp)
 4044078:	10800a17 	ldw	r2,40(r2)
 404407c:	1007883a 	mov	r3,r2
 4044080:	e0bfff17 	ldw	r2,-4(fp)
 4044084:	1085883a 	add	r2,r2,r2
 4044088:	1085883a 	add	r2,r2,r2
 404408c:	1885883a 	add	r2,r3,r2
 4044090:	10800037 	ldwio	r2,0(r2)
 4044094:	10803fcc 	andi	r2,r2,255
}
 4044098:	e037883a 	mov	sp,fp
 404409c:	df000017 	ldw	fp,0(sp)
 40440a0:	dec00104 	addi	sp,sp,4
 40440a4:	f800283a 	ret

040440a8 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 40440a8:	defffc04 	addi	sp,sp,-16
 40440ac:	df000315 	stw	fp,12(sp)
 40440b0:	df000304 	addi	fp,sp,12
 40440b4:	e13ffd15 	stw	r4,-12(fp)
 40440b8:	e17ffe15 	stw	r5,-8(fp)
 40440bc:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
 40440c0:	e0fffd17 	ldw	r3,-12(fp)
 40440c4:	e0bffe17 	ldw	r2,-8(fp)
 40440c8:	1885883a 	add	r2,r3,r2
 40440cc:	e0ffff03 	ldbu	r3,-4(fp)
 40440d0:	10c00025 	stbio	r3,0(r2)
  return;
}
 40440d4:	e037883a 	mov	sp,fp
 40440d8:	df000017 	ldw	fp,0(sp)
 40440dc:	dec00104 	addi	sp,sp,4
 40440e0:	f800283a 	ret

040440e4 <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 40440e4:	defffc04 	addi	sp,sp,-16
 40440e8:	df000315 	stw	fp,12(sp)
 40440ec:	df000304 	addi	fp,sp,12
 40440f0:	e13ffd15 	stw	r4,-12(fp)
 40440f4:	e17ffe15 	stw	r5,-8(fp)
 40440f8:	e1bfff05 	stb	r6,-4(fp)
  if (offset % 2)
 40440fc:	e0bffe17 	ldw	r2,-8(fp)
 4044100:	1080004c 	andi	r2,r2,1
 4044104:	10803fcc 	andi	r2,r2,255
 4044108:	1005003a 	cmpeq	r2,r2,zero
 404410c:	1000081e 	bne	r2,zero,4044130 <alt_write_flash_command_16bit_device_8bit_mode+0x4c>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
 4044110:	e0bffe17 	ldw	r2,-8(fp)
 4044114:	1085883a 	add	r2,r2,r2
 4044118:	1007883a 	mov	r3,r2
 404411c:	e0bffd17 	ldw	r2,-12(fp)
 4044120:	1885883a 	add	r2,r3,r2
 4044124:	e0ffff03 	ldbu	r3,-4(fp)
 4044128:	10c00025 	stbio	r3,0(r2)
 404412c:	00000806 	br	4044150 <alt_write_flash_command_16bit_device_8bit_mode+0x6c>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
 4044130:	e0bffe17 	ldw	r2,-8(fp)
 4044134:	1085883a 	add	r2,r2,r2
 4044138:	1007883a 	mov	r3,r2
 404413c:	e0bffd17 	ldw	r2,-12(fp)
 4044140:	1885883a 	add	r2,r3,r2
 4044144:	10800044 	addi	r2,r2,1
 4044148:	e0ffff03 	ldbu	r3,-4(fp)
 404414c:	10c00025 	stbio	r3,0(r2)
  }
  return;
}
 4044150:	e037883a 	mov	sp,fp
 4044154:	df000017 	ldw	fp,0(sp)
 4044158:	dec00104 	addi	sp,sp,4
 404415c:	f800283a 	ret

04044160 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 4044160:	defffc04 	addi	sp,sp,-16
 4044164:	df000315 	stw	fp,12(sp)
 4044168:	df000304 	addi	fp,sp,12
 404416c:	e13ffd15 	stw	r4,-12(fp)
 4044170:	e17ffe15 	stw	r5,-8(fp)
 4044174:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
 4044178:	e0bffe17 	ldw	r2,-8(fp)
 404417c:	1085883a 	add	r2,r2,r2
 4044180:	1085883a 	add	r2,r2,r2
 4044184:	1007883a 	mov	r3,r2
 4044188:	e0bffd17 	ldw	r2,-12(fp)
 404418c:	1885883a 	add	r2,r3,r2
 4044190:	e0ffff03 	ldbu	r3,-4(fp)
 4044194:	10c00025 	stbio	r3,0(r2)
  return;
}
 4044198:	e037883a 	mov	sp,fp
 404419c:	df000017 	ldw	fp,0(sp)
 40441a0:	dec00104 	addi	sp,sp,4
 40441a4:	f800283a 	ret

040441a8 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 40441a8:	defffc04 	addi	sp,sp,-16
 40441ac:	df000315 	stw	fp,12(sp)
 40441b0:	df000304 	addi	fp,sp,12
 40441b4:	e13ffd15 	stw	r4,-12(fp)
 40441b8:	e17ffe15 	stw	r5,-8(fp)
 40441bc:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
 40441c0:	e0bffe17 	ldw	r2,-8(fp)
 40441c4:	1085883a 	add	r2,r2,r2
 40441c8:	1007883a 	mov	r3,r2
 40441cc:	e0bffd17 	ldw	r2,-12(fp)
 40441d0:	1885883a 	add	r2,r3,r2
 40441d4:	e0ffff03 	ldbu	r3,-4(fp)
 40441d8:	10c0002d 	sthio	r3,0(r2)
  return;
}
 40441dc:	e037883a 	mov	sp,fp
 40441e0:	df000017 	ldw	fp,0(sp)
 40441e4:	dec00104 	addi	sp,sp,4
 40441e8:	f800283a 	ret

040441ec <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 40441ec:	defffc04 	addi	sp,sp,-16
 40441f0:	df000315 	stw	fp,12(sp)
 40441f4:	df000304 	addi	fp,sp,12
 40441f8:	e13ffd15 	stw	r4,-12(fp)
 40441fc:	e17ffe15 	stw	r5,-8(fp)
 4044200:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
 4044204:	e0bffe17 	ldw	r2,-8(fp)
 4044208:	1085883a 	add	r2,r2,r2
 404420c:	1085883a 	add	r2,r2,r2
 4044210:	1007883a 	mov	r3,r2
 4044214:	e0bffd17 	ldw	r2,-12(fp)
 4044218:	1885883a 	add	r2,r3,r2
 404421c:	e0ffff03 	ldbu	r3,-4(fp)
 4044220:	10c0002d 	sthio	r3,0(r2)
  return;
}
 4044224:	e037883a 	mov	sp,fp
 4044228:	df000017 	ldw	fp,0(sp)
 404422c:	dec00104 	addi	sp,sp,4
 4044230:	f800283a 	ret

04044234 <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
 4044234:	defffc04 	addi	sp,sp,-16
 4044238:	df000315 	stw	fp,12(sp)
 404423c:	df000304 	addi	fp,sp,12
 4044240:	e13ffd15 	stw	r4,-12(fp)
 4044244:	e17ffe15 	stw	r5,-8(fp)
 4044248:	e1bfff05 	stb	r6,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
 404424c:	e0bffe17 	ldw	r2,-8(fp)
 4044250:	1085883a 	add	r2,r2,r2
 4044254:	1085883a 	add	r2,r2,r2
 4044258:	1007883a 	mov	r3,r2
 404425c:	e0bffd17 	ldw	r2,-12(fp)
 4044260:	1885883a 	add	r2,r3,r2
 4044264:	e0ffff03 	ldbu	r3,-4(fp)
 4044268:	10c00035 	stwio	r3,0(r2)
  return;
}
 404426c:	e037883a 	mov	sp,fp
 4044270:	df000017 	ldw	fp,0(sp)
 4044274:	dec00104 	addi	sp,sp,4
 4044278:	f800283a 	ret

0404427c <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
 404427c:	defffd04 	addi	sp,sp,-12
 4044280:	df000215 	stw	fp,8(sp)
 4044284:	df000204 	addi	fp,sp,8
 4044288:	e13ffe15 	stw	r4,-8(fp)
 404428c:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
 4044290:	e0bfff17 	ldw	r2,-4(fp)
 4044294:	10c03fcc 	andi	r3,r2,255
 4044298:	e0bffe17 	ldw	r2,-8(fp)
 404429c:	10c00025 	stbio	r3,0(r2)
  return;
}
 40442a0:	e037883a 	mov	sp,fp
 40442a4:	df000017 	ldw	fp,0(sp)
 40442a8:	dec00104 	addi	sp,sp,4
 40442ac:	f800283a 	ret

040442b0 <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
 40442b0:	defffd04 	addi	sp,sp,-12
 40442b4:	df000215 	stw	fp,8(sp)
 40442b8:	df000204 	addi	fp,sp,8
 40442bc:	e13ffe15 	stw	r4,-8(fp)
 40442c0:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
 40442c4:	e0bfff17 	ldw	r2,-4(fp)
 40442c8:	10ffffcc 	andi	r3,r2,65535
 40442cc:	e0bffe17 	ldw	r2,-8(fp)
 40442d0:	10c0002d 	sthio	r3,0(r2)
  return;
}
 40442d4:	e037883a 	mov	sp,fp
 40442d8:	df000017 	ldw	fp,0(sp)
 40442dc:	dec00104 	addi	sp,sp,4
 40442e0:	f800283a 	ret

040442e4 <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
 40442e4:	defffd04 	addi	sp,sp,-12
 40442e8:	df000215 	stw	fp,8(sp)
 40442ec:	df000204 	addi	fp,sp,8
 40442f0:	e13ffe15 	stw	r4,-8(fp)
 40442f4:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
 40442f8:	e0ffff17 	ldw	r3,-4(fp)
 40442fc:	e0bffe17 	ldw	r2,-8(fp)
 4044300:	10c00035 	stwio	r3,0(r2)
  return;
}
 4044304:	e037883a 	mov	sp,fp
 4044308:	df000017 	ldw	fp,0(sp)
 404430c:	dec00104 	addi	sp,sp,4
 4044310:	f800283a 	ret

04044314 <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
 4044314:	defffb04 	addi	sp,sp,-20
 4044318:	df000415 	stw	fp,16(sp)
 404431c:	df000404 	addi	fp,sp,16
 4044320:	e13ffd15 	stw	r4,-12(fp)
  int ret_code = 0;
 4044324:	e03ffc15 	stw	zero,-16(fp)
  
  switch(flash->mode_width)
 4044328:	e0bffd17 	ldw	r2,-12(fp)
 404432c:	10802e17 	ldw	r2,184(r2)
 4044330:	e0bfff15 	stw	r2,-4(fp)
 4044334:	e0ffff17 	ldw	r3,-4(fp)
 4044338:	188000a0 	cmpeqi	r2,r3,2
 404433c:	1000261e 	bne	r2,zero,40443d8 <alt_set_flash_width_func+0xc4>
 4044340:	e0ffff17 	ldw	r3,-4(fp)
 4044344:	18800120 	cmpeqi	r2,r3,4
 4044348:	1000391e 	bne	r2,zero,4044430 <alt_set_flash_width_func+0x11c>
 404434c:	e0ffff17 	ldw	r3,-4(fp)
 4044350:	18800060 	cmpeqi	r2,r3,1
 4044354:	1000011e 	bne	r2,zero,404435c <alt_set_flash_width_func+0x48>
 4044358:	00003e06 	br	4044454 <alt_set_flash_width_func+0x140>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
 404435c:	e0fffd17 	ldw	r3,-12(fp)
 4044360:	00810134 	movhi	r2,1028
 4044364:	10909f04 	addi	r2,r2,17020
 4044368:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 1)
 404436c:	e0bffd17 	ldw	r2,-12(fp)
 4044370:	10802f17 	ldw	r2,188(r2)
 4044374:	10800058 	cmpnei	r2,r2,1
 4044378:	1000051e 	bne	r2,zero,4044390 <alt_set_flash_width_func+0x7c>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
 404437c:	e0fffd17 	ldw	r3,-12(fp)
 4044380:	00810134 	movhi	r2,1028
 4044384:	10902a04 	addi	r2,r2,16552
 4044388:	18803315 	stw	r2,204(r3)
 404438c:	00003306 	br	404445c <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 2)
 4044390:	e0bffd17 	ldw	r2,-12(fp)
 4044394:	10802f17 	ldw	r2,188(r2)
 4044398:	10800098 	cmpnei	r2,r2,2
 404439c:	1000051e 	bne	r2,zero,40443b4 <alt_set_flash_width_func+0xa0>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
 40443a0:	e0fffd17 	ldw	r3,-12(fp)
 40443a4:	00810134 	movhi	r2,1028
 40443a8:	10903904 	addi	r2,r2,16612
 40443ac:	18803315 	stw	r2,204(r3)
 40443b0:	00002a06 	br	404445c <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 40443b4:	e0bffd17 	ldw	r2,-12(fp)
 40443b8:	10802f17 	ldw	r2,188(r2)
 40443bc:	10800118 	cmpnei	r2,r2,4
 40443c0:	1000261e 	bne	r2,zero,404445c <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
 40443c4:	e0fffd17 	ldw	r3,-12(fp)
 40443c8:	00810134 	movhi	r2,1028
 40443cc:	10905804 	addi	r2,r2,16736
 40443d0:	18803315 	stw	r2,204(r3)
      }
      break;
 40443d4:	00002106 	br	404445c <alt_set_flash_width_func+0x148>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
 40443d8:	e0fffd17 	ldw	r3,-12(fp)
 40443dc:	00810134 	movhi	r2,1028
 40443e0:	1090ac04 	addi	r2,r2,17072
 40443e4:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 2)
 40443e8:	e0bffd17 	ldw	r2,-12(fp)
 40443ec:	10802f17 	ldw	r2,188(r2)
 40443f0:	10800098 	cmpnei	r2,r2,2
 40443f4:	1000051e 	bne	r2,zero,404440c <alt_set_flash_width_func+0xf8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
 40443f8:	e0fffd17 	ldw	r3,-12(fp)
 40443fc:	00810134 	movhi	r2,1028
 4044400:	10906a04 	addi	r2,r2,16808
 4044404:	18803315 	stw	r2,204(r3)
 4044408:	00001406 	br	404445c <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 404440c:	e0bffd17 	ldw	r2,-12(fp)
 4044410:	10802f17 	ldw	r2,188(r2)
 4044414:	10800118 	cmpnei	r2,r2,4
 4044418:	1000101e 	bne	r2,zero,404445c <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
 404441c:	e0fffd17 	ldw	r3,-12(fp)
 4044420:	00810134 	movhi	r2,1028
 4044424:	10907b04 	addi	r2,r2,16876
 4044428:	18803315 	stw	r2,204(r3)
      }

      break;
 404442c:	00000b06 	br	404445c <alt_set_flash_width_func+0x148>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
 4044430:	e0fffd17 	ldw	r3,-12(fp)
 4044434:	00810134 	movhi	r2,1028
 4044438:	1090b904 	addi	r2,r2,17124
 404443c:	18803515 	stw	r2,212(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
 4044440:	e0fffd17 	ldw	r3,-12(fp)
 4044444:	00810134 	movhi	r2,1028
 4044448:	10908d04 	addi	r2,r2,16948
 404444c:	18803315 	stw	r2,204(r3)
      break;
 4044450:	00000206 	br	404445c <alt_set_flash_width_func+0x148>
    }
    default:
    {
      ret_code = -EACCES;
 4044454:	00bffcc4 	movi	r2,-13
 4044458:	e0bffc15 	stw	r2,-16(fp)
    }
  }

  if (!ret_code)
 404445c:	e0bffc17 	ldw	r2,-16(fp)
 4044460:	1004c03a 	cmpne	r2,r2,zero
 4044464:	10001e1e 	bne	r2,zero,40444e0 <alt_set_flash_width_func+0x1cc>
  {
    switch(flash->device_width)
 4044468:	e0bffd17 	ldw	r2,-12(fp)
 404446c:	10802f17 	ldw	r2,188(r2)
 4044470:	e0bffe15 	stw	r2,-8(fp)
 4044474:	e0fffe17 	ldw	r3,-8(fp)
 4044478:	188000a0 	cmpeqi	r2,r3,2
 404447c:	10000c1e 	bne	r2,zero,40444b0 <alt_set_flash_width_func+0x19c>
 4044480:	e0fffe17 	ldw	r3,-8(fp)
 4044484:	18800120 	cmpeqi	r2,r3,4
 4044488:	10000e1e 	bne	r2,zero,40444c4 <alt_set_flash_width_func+0x1b0>
 404448c:	e0fffe17 	ldw	r3,-8(fp)
 4044490:	18800060 	cmpeqi	r2,r3,1
 4044494:	1000011e 	bne	r2,zero,404449c <alt_set_flash_width_func+0x188>
 4044498:	00000f06 	br	40444d8 <alt_set_flash_width_func+0x1c4>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
 404449c:	e0fffd17 	ldw	r3,-12(fp)
 40444a0:	00810134 	movhi	r2,1028
 40444a4:	108ff704 	addi	r2,r2,16348
 40444a8:	18803415 	stw	r2,208(r3)
        break;
 40444ac:	00000c06 	br	40444e0 <alt_set_flash_width_func+0x1cc>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
 40444b0:	e0fffd17 	ldw	r3,-12(fp)
 40444b4:	00810134 	movhi	r2,1028
 40444b8:	10900704 	addi	r2,r2,16412
 40444bc:	18803415 	stw	r2,208(r3)
        break;
 40444c0:	00000706 	br	40444e0 <alt_set_flash_width_func+0x1cc>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
 40444c4:	e0fffd17 	ldw	r3,-12(fp)
 40444c8:	00810134 	movhi	r2,1028
 40444cc:	10901804 	addi	r2,r2,16480
 40444d0:	18803415 	stw	r2,208(r3)
        break;
 40444d4:	00000206 	br	40444e0 <alt_set_flash_width_func+0x1cc>
      }
      default:
      {
        ret_code = -EACCES;
 40444d8:	00bffcc4 	movi	r2,-13
 40444dc:	e0bffc15 	stw	r2,-16(fp)
      }
    }
  }

  return ret_code;
 40444e0:	e0bffc17 	ldw	r2,-16(fp)
}
 40444e4:	e037883a 	mov	sp,fp
 40444e8:	df000017 	ldw	fp,0(sp)
 40444ec:	dec00104 	addi	sp,sp,4
 40444f0:	f800283a 	ret

040444f4 <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
 40444f4:	defffc04 	addi	sp,sp,-16
 40444f8:	df000315 	stw	fp,12(sp)
 40444fc:	df000304 	addi	fp,sp,12
 4044500:	e13ffe15 	stw	r4,-8(fp)
  int ret_code = 0;
 4044504:	e03ffd15 	stw	zero,-12(fp)
 
  switch(flash->algorithm)
 4044508:	e0bffe17 	ldw	r2,-8(fp)
 404450c:	10802d17 	ldw	r2,180(r2)
 4044510:	e0bfff15 	stw	r2,-4(fp)
 4044514:	e0ffff17 	ldw	r3,-4(fp)
 4044518:	188000a0 	cmpeqi	r2,r3,2
 404451c:	1000071e 	bne	r2,zero,404453c <alt_set_flash_algorithm_func+0x48>
 4044520:	e0ffff17 	ldw	r3,-4(fp)
 4044524:	188000e0 	cmpeqi	r2,r3,3
 4044528:	10000d1e 	bne	r2,zero,4044560 <alt_set_flash_algorithm_func+0x6c>
 404452c:	e0ffff17 	ldw	r3,-4(fp)
 4044530:	18800060 	cmpeqi	r2,r3,1
 4044534:	10000a1e 	bne	r2,zero,4044560 <alt_set_flash_algorithm_func+0x6c>
 4044538:	00001206 	br	4044584 <alt_set_flash_algorithm_func+0x90>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
 404453c:	e0fffe17 	ldw	r3,-8(fp)
 4044540:	00810134 	movhi	r2,1028
 4044544:	109b2d04 	addi	r2,r2,27828
 4044548:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
 404454c:	e0fffe17 	ldw	r3,-8(fp)
 4044550:	00810134 	movhi	r2,1028
 4044554:	109b1304 	addi	r2,r2,27724
 4044558:	18800915 	stw	r2,36(r3)
      break;
 404455c:	00000b06 	br	404458c <alt_set_flash_algorithm_func+0x98>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
 4044560:	e0fffe17 	ldw	r3,-8(fp)
 4044564:	00810134 	movhi	r2,1028
 4044568:	109c4c04 	addi	r2,r2,28976
 404456c:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
 4044570:	e0fffe17 	ldw	r3,-8(fp)
 4044574:	00810134 	movhi	r2,1028
 4044578:	109c2b04 	addi	r2,r2,28844
 404457c:	18800915 	stw	r2,36(r3)
      break;
 4044580:	00000206 	br	404458c <alt_set_flash_algorithm_func+0x98>
    }
    default:
    {
      ret_code = -EIO;
 4044584:	00bffec4 	movi	r2,-5
 4044588:	e0bffd15 	stw	r2,-12(fp)
    }
  } 
  return ret_code;  
 404458c:	e0bffd17 	ldw	r2,-12(fp)
}
 4044590:	e037883a 	mov	sp,fp
 4044594:	df000017 	ldw	fp,0(sp)
 4044598:	dec00104 	addi	sp,sp,4
 404459c:	f800283a 	ret

040445a0 <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
 40445a0:	defffb04 	addi	sp,sp,-20
 40445a4:	dfc00415 	stw	ra,16(sp)
 40445a8:	df000315 	stw	fp,12(sp)
 40445ac:	df000304 	addi	fp,sp,12
 40445b0:	e13ffe15 	stw	r4,-8(fp)
 40445b4:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
 40445b8:	e0bffe17 	ldw	r2,-8(fp)
 40445bc:	10803417 	ldw	r2,208(r2)
 40445c0:	e13ffe17 	ldw	r4,-8(fp)
 40445c4:	e17fff17 	ldw	r5,-4(fp)
 40445c8:	103ee83a 	callr	r2
 40445cc:	10803fcc 	andi	r2,r2,255
 40445d0:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
 40445d4:	e0bffe17 	ldw	r2,-8(fp)
 40445d8:	10c03417 	ldw	r3,208(r2)
 40445dc:	e0bfff17 	ldw	r2,-4(fp)
 40445e0:	11400044 	addi	r5,r2,1
 40445e4:	e13ffe17 	ldw	r4,-8(fp)
 40445e8:	183ee83a 	callr	r3
 40445ec:	10803fcc 	andi	r2,r2,255
 40445f0:	1004923a 	slli	r2,r2,8
 40445f4:	1007883a 	mov	r3,r2
 40445f8:	e0bffd0b 	ldhu	r2,-12(fp)
 40445fc:	1884b03a 	or	r2,r3,r2
 4044600:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
 4044604:	e0bffd0b 	ldhu	r2,-12(fp)
}
 4044608:	e037883a 	mov	sp,fp
 404460c:	dfc00117 	ldw	ra,4(sp)
 4044610:	df000017 	ldw	fp,0(sp)
 4044614:	dec00204 	addi	sp,sp,8
 4044618:	f800283a 	ret

0404461c <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
 404461c:	defff204 	addi	sp,sp,-56
 4044620:	dfc00d15 	stw	ra,52(sp)
 4044624:	df000c15 	stw	fp,48(sp)
 4044628:	dc000b15 	stw	r16,44(sp)
 404462c:	df000b04 	addi	fp,sp,44
 4044630:	e13fff15 	stw	r4,-4(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
 4044634:	e03ffb15 	stw	zero,-20(fp)
  int   size = 0;
 4044638:	e03ffa15 	stw	zero,-24(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
 404463c:	e03ff615 	stw	zero,-40(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
 4044640:	e13fff17 	ldw	r4,-4(fp)
 4044644:	40453480 	call	4045348 <alt_check_primary_table>
 4044648:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 404464c:	e0bffb17 	ldw	r2,-20(fp)
 4044650:	1004c03a 	cmpne	r2,r2,zero
 4044654:	10014a1e 	bne	r2,zero,4044b80 <alt_read_cfi_table+0x564>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
 4044658:	e0bfff17 	ldw	r2,-4(fp)
 404465c:	10803417 	ldw	r2,208(r2)
 4044660:	e13fff17 	ldw	r4,-4(fp)
 4044664:	014004c4 	movi	r5,19
 4044668:	103ee83a 	callr	r2
 404466c:	10c03fcc 	andi	r3,r2,255
 4044670:	e0bfff17 	ldw	r2,-4(fp)
 4044674:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
 4044678:	e0bfff17 	ldw	r2,-4(fp)
 404467c:	10803417 	ldw	r2,208(r2)
 4044680:	e13fff17 	ldw	r4,-4(fp)
 4044684:	014007c4 	movi	r5,31
 4044688:	103ee83a 	callr	r2
 404468c:	10803fcc 	andi	r2,r2,255
 4044690:	e0bff815 	stw	r2,-32(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
 4044694:	e0bfff17 	ldw	r2,-4(fp)
 4044698:	10803417 	ldw	r2,208(r2)
 404469c:	e13fff17 	ldw	r4,-4(fp)
 40446a0:	014008c4 	movi	r5,35
 40446a4:	103ee83a 	callr	r2
 40446a8:	10803fcc 	andi	r2,r2,255
 40446ac:	e0bff715 	stw	r2,-36(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 40446b0:	e0bff817 	ldw	r2,-32(fp)
 40446b4:	1005003a 	cmpeq	r2,r2,zero
 40446b8:	1000031e 	bne	r2,zero,40446c8 <alt_read_cfi_table+0xac>
 40446bc:	e0bff717 	ldw	r2,-36(fp)
 40446c0:	1004c03a 	cmpne	r2,r2,zero
 40446c4:	1000041e 	bne	r2,zero,40446d8 <alt_read_cfi_table+0xbc>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
 40446c8:	e0ffff17 	ldw	r3,-4(fp)
 40446cc:	0080fa04 	movi	r2,1000
 40446d0:	18803015 	stw	r2,192(r3)
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
    max_timeout = (*flash->read_query)( flash, 0x23);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 40446d4:	00000706 	br	40446f4 <alt_read_cfi_table+0xd8>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
 40446d8:	00c00044 	movi	r3,1
 40446dc:	e0bff817 	ldw	r2,-32(fp)
 40446e0:	1886983a 	sll	r3,r3,r2
 40446e4:	e0bff717 	ldw	r2,-36(fp)
 40446e8:	1886983a 	sll	r3,r3,r2
 40446ec:	e0bfff17 	ldw	r2,-4(fp)
 40446f0:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
 40446f4:	e0bfff17 	ldw	r2,-4(fp)
 40446f8:	10803417 	ldw	r2,208(r2)
 40446fc:	e13fff17 	ldw	r4,-4(fp)
 4044700:	01400844 	movi	r5,33
 4044704:	103ee83a 	callr	r2
 4044708:	10803fcc 	andi	r2,r2,255
 404470c:	e0bff815 	stw	r2,-32(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
 4044710:	e0bfff17 	ldw	r2,-4(fp)
 4044714:	10803417 	ldw	r2,208(r2)
 4044718:	e13fff17 	ldw	r4,-4(fp)
 404471c:	01400944 	movi	r5,37
 4044720:	103ee83a 	callr	r2
 4044724:	10803fcc 	andi	r2,r2,255
 4044728:	e0bff715 	stw	r2,-36(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 404472c:	e0bff817 	ldw	r2,-32(fp)
 4044730:	1005003a 	cmpeq	r2,r2,zero
 4044734:	1000031e 	bne	r2,zero,4044744 <alt_read_cfi_table+0x128>
 4044738:	e0bff717 	ldw	r2,-36(fp)
 404473c:	1004c03a 	cmpne	r2,r2,zero
 4044740:	1000051e 	bne	r2,zero,4044758 <alt_read_cfi_table+0x13c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
 4044744:	e0ffff17 	ldw	r3,-4(fp)
 4044748:	00804c74 	movhi	r2,305
 404474c:	108b4004 	addi	r2,r2,11520
 4044750:	18803115 	stw	r2,196(r3)
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
    max_timeout = (*flash->read_query)( flash, 0x25);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 4044754:	00000806 	br	4044778 <alt_read_cfi_table+0x15c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
 4044758:	00c00044 	movi	r3,1
 404475c:	e0bff817 	ldw	r2,-32(fp)
 4044760:	1886983a 	sll	r3,r3,r2
 4044764:	e0bff717 	ldw	r2,-36(fp)
 4044768:	1884983a 	sll	r2,r3,r2
 404476c:	10c0fa24 	muli	r3,r2,1000
 4044770:	e0bfff17 	ldw	r2,-4(fp)
 4044774:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
 4044778:	e0bfff17 	ldw	r2,-4(fp)
 404477c:	10803417 	ldw	r2,208(r2)
 4044780:	e13fff17 	ldw	r4,-4(fp)
 4044784:	014009c4 	movi	r5,39
 4044788:	103ee83a 	callr	r2
 404478c:	10c03fcc 	andi	r3,r2,255
 4044790:	00800044 	movi	r2,1
 4044794:	10c4983a 	sll	r2,r2,r3
 4044798:	e0bffc15 	stw	r2,-16(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
 404479c:	e0bfff17 	ldw	r2,-4(fp)
 40447a0:	10803417 	ldw	r2,208(r2)
 40447a4:	e13fff17 	ldw	r4,-4(fp)
 40447a8:	01400b04 	movi	r5,44
 40447ac:	103ee83a 	callr	r2
 40447b0:	10c03fcc 	andi	r3,r2,255
 40447b4:	e0bfff17 	ldw	r2,-4(fp)
 40447b8:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 40447bc:	e0bfff17 	ldw	r2,-4(fp)
 40447c0:	10800c17 	ldw	r2,48(r2)
 40447c4:	10800250 	cmplti	r2,r2,9
 40447c8:	1000031e 	bne	r2,zero,40447d8 <alt_read_cfi_table+0x1bc>
    {
      ret_code = -ENOMEM;
 40447cc:	00bffd04 	movi	r2,-12
 40447d0:	e0bffb15 	stw	r2,-20(fp)
 40447d4:	00005e06 	br	4044950 <alt_read_cfi_table+0x334>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 40447d8:	e03ffe15 	stw	zero,-8(fp)
 40447dc:	00005306 	br	404492c <alt_read_cfi_table+0x310>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
 40447e0:	e43ffe17 	ldw	r16,-8(fp)
 40447e4:	e0bffe17 	ldw	r2,-8(fp)
 40447e8:	1085883a 	add	r2,r2,r2
 40447ec:	1085883a 	add	r2,r2,r2
 40447f0:	11400b44 	addi	r5,r2,45
 40447f4:	e13fff17 	ldw	r4,-4(fp)
 40447f8:	40445a00 	call	40445a0 <alt_read_16bit_query_entry>
 40447fc:	113fffcc 	andi	r4,r2,65535
 4044800:	e0ffff17 	ldw	r3,-4(fp)
 4044804:	8004913a 	slli	r2,r16,4
 4044808:	10c5883a 	add	r2,r2,r3
 404480c:	10800f04 	addi	r2,r2,60
 4044810:	11000015 	stw	r4,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
 4044814:	e17ffe17 	ldw	r5,-8(fp)
 4044818:	e0bffe17 	ldw	r2,-8(fp)
 404481c:	e0ffff17 	ldw	r3,-4(fp)
 4044820:	1004913a 	slli	r2,r2,4
 4044824:	10c5883a 	add	r2,r2,r3
 4044828:	10800f04 	addi	r2,r2,60
 404482c:	10800017 	ldw	r2,0(r2)
 4044830:	11000044 	addi	r4,r2,1
 4044834:	e0ffff17 	ldw	r3,-4(fp)
 4044838:	2804913a 	slli	r2,r5,4
 404483c:	10c5883a 	add	r2,r2,r3
 4044840:	10800f04 	addi	r2,r2,60
 4044844:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
 4044848:	e43ffe17 	ldw	r16,-8(fp)
 404484c:	e0bffe17 	ldw	r2,-8(fp)
 4044850:	1085883a 	add	r2,r2,r2
 4044854:	1085883a 	add	r2,r2,r2
 4044858:	11400bc4 	addi	r5,r2,47
 404485c:	e13fff17 	ldw	r4,-4(fp)
 4044860:	40445a00 	call	40445a0 <alt_read_16bit_query_entry>
 4044864:	113fffcc 	andi	r4,r2,65535
 4044868:	e0ffff17 	ldw	r3,-4(fp)
 404486c:	8004913a 	slli	r2,r16,4
 4044870:	10c5883a 	add	r2,r2,r3
 4044874:	10801004 	addi	r2,r2,64
 4044878:	11000015 	stw	r4,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
 404487c:	e17ffe17 	ldw	r5,-8(fp)
 4044880:	e0bffe17 	ldw	r2,-8(fp)
 4044884:	e0ffff17 	ldw	r3,-4(fp)
 4044888:	1004913a 	slli	r2,r2,4
 404488c:	10c5883a 	add	r2,r2,r3
 4044890:	10801004 	addi	r2,r2,64
 4044894:	10800017 	ldw	r2,0(r2)
 4044898:	1008923a 	slli	r4,r2,8
 404489c:	e0ffff17 	ldw	r3,-4(fp)
 40448a0:	2804913a 	slli	r2,r5,4
 40448a4:	10c5883a 	add	r2,r2,r3
 40448a8:	10801004 	addi	r2,r2,64
 40448ac:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].region_size = 
 40448b0:	e17ffe17 	ldw	r5,-8(fp)
 40448b4:	e0bffe17 	ldw	r2,-8(fp)
 40448b8:	e0ffff17 	ldw	r3,-4(fp)
 40448bc:	1004913a 	slli	r2,r2,4
 40448c0:	10c5883a 	add	r2,r2,r3
 40448c4:	10800f04 	addi	r2,r2,60
 40448c8:	11000017 	ldw	r4,0(r2)
 40448cc:	e0bffe17 	ldw	r2,-8(fp)
 40448d0:	e0ffff17 	ldw	r3,-4(fp)
 40448d4:	1004913a 	slli	r2,r2,4
 40448d8:	10c5883a 	add	r2,r2,r3
 40448dc:	10801004 	addi	r2,r2,64
 40448e0:	10800017 	ldw	r2,0(r2)
 40448e4:	2089383a 	mul	r4,r4,r2
 40448e8:	e0ffff17 	ldw	r3,-4(fp)
 40448ec:	2804913a 	slli	r2,r5,4
 40448f0:	10c5883a 	add	r2,r2,r3
 40448f4:	10800e04 	addi	r2,r2,56
 40448f8:	11000015 	stw	r4,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
 40448fc:	e0bffe17 	ldw	r2,-8(fp)
 4044900:	e0ffff17 	ldw	r3,-4(fp)
 4044904:	1004913a 	slli	r2,r2,4
 4044908:	10c5883a 	add	r2,r2,r3
 404490c:	10800e04 	addi	r2,r2,56
 4044910:	10c00017 	ldw	r3,0(r2)
 4044914:	e0bffa17 	ldw	r2,-24(fp)
 4044918:	10c5883a 	add	r2,r2,r3
 404491c:	e0bffa15 	stw	r2,-24(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 4044920:	e0bffe17 	ldw	r2,-8(fp)
 4044924:	10800044 	addi	r2,r2,1
 4044928:	e0bffe15 	stw	r2,-8(fp)
 404492c:	e0bfff17 	ldw	r2,-4(fp)
 4044930:	10c00c17 	ldw	r3,48(r2)
 4044934:	e0bffe17 	ldw	r2,-8(fp)
 4044938:	10ffa916 	blt	r2,r3,40447e0 <alt_read_cfi_table+0x1c4>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
 404493c:	e0fffa17 	ldw	r3,-24(fp)
 4044940:	e0bffc17 	ldw	r2,-16(fp)
 4044944:	18800226 	beq	r3,r2,4044950 <alt_read_cfi_table+0x334>
      {
        ret_code = -ENODEV;
 4044948:	00bffb44 	movi	r2,-19
 404494c:	e0bffb15 	stw	r2,-20(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
 4044950:	e0bfff17 	ldw	r2,-4(fp)
 4044954:	10c03417 	ldw	r3,208(r2)
 4044958:	e0bfff17 	ldw	r2,-4(fp)
 404495c:	10803217 	ldw	r2,200(r2)
 4044960:	114003c4 	addi	r5,r2,15
 4044964:	e13fff17 	ldw	r4,-4(fp)
 4044968:	183ee83a 	callr	r3
 404496c:	e0bff505 	stb	r2,-44(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
 4044970:	e0bfff17 	ldw	r2,-4(fp)
 4044974:	10802d17 	ldw	r2,180(r2)
 4044978:	10800098 	cmpnei	r2,r2,2
 404497c:	1000601e 	bne	r2,zero,4044b00 <alt_read_cfi_table+0x4e4>
 4044980:	e0bff503 	ldbu	r2,-44(fp)
 4044984:	108000d8 	cmpnei	r2,r2,3
 4044988:	10005d1e 	bne	r2,zero,4044b00 <alt_read_cfi_table+0x4e4>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 404498c:	e0bfff17 	ldw	r2,-4(fp)
 4044990:	10800c17 	ldw	r2,48(r2)
 4044994:	10bfffc4 	addi	r2,r2,-1
 4044998:	e0bffe15 	stw	r2,-8(fp)
 404499c:	e03ffd15 	stw	zero,-12(fp)
          j<=i;i--,j++)
 40449a0:	00005406 	br	4044af4 <alt_read_cfi_table+0x4d8>
      {
        swap = flash->dev.region_info[i].region_size;
 40449a4:	e0bffe17 	ldw	r2,-8(fp)
 40449a8:	e0ffff17 	ldw	r3,-4(fp)
 40449ac:	1004913a 	slli	r2,r2,4
 40449b0:	10c5883a 	add	r2,r2,r3
 40449b4:	10800e04 	addi	r2,r2,56
 40449b8:	10800017 	ldw	r2,0(r2)
 40449bc:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].region_size =  
 40449c0:	e17ffe17 	ldw	r5,-8(fp)
 40449c4:	e0bffd17 	ldw	r2,-12(fp)
 40449c8:	e0ffff17 	ldw	r3,-4(fp)
 40449cc:	1004913a 	slli	r2,r2,4
 40449d0:	10c5883a 	add	r2,r2,r3
 40449d4:	10800e04 	addi	r2,r2,56
 40449d8:	11000017 	ldw	r4,0(r2)
 40449dc:	e0ffff17 	ldw	r3,-4(fp)
 40449e0:	2804913a 	slli	r2,r5,4
 40449e4:	10c5883a 	add	r2,r2,r3
 40449e8:	10800e04 	addi	r2,r2,56
 40449ec:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
 40449f0:	e0bffd17 	ldw	r2,-12(fp)
 40449f4:	e0ffff17 	ldw	r3,-4(fp)
 40449f8:	1004913a 	slli	r2,r2,4
 40449fc:	10c5883a 	add	r2,r2,r3
 4044a00:	10c00e04 	addi	r3,r2,56
 4044a04:	e0bff917 	ldw	r2,-28(fp)
 4044a08:	18800015 	stw	r2,0(r3)

        swap = flash->dev.region_info[i].block_size;
 4044a0c:	e0bffe17 	ldw	r2,-8(fp)
 4044a10:	e0ffff17 	ldw	r3,-4(fp)
 4044a14:	1004913a 	slli	r2,r2,4
 4044a18:	10c5883a 	add	r2,r2,r3
 4044a1c:	10801004 	addi	r2,r2,64
 4044a20:	10800017 	ldw	r2,0(r2)
 4044a24:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].block_size =  
 4044a28:	e17ffe17 	ldw	r5,-8(fp)
 4044a2c:	e0bffd17 	ldw	r2,-12(fp)
 4044a30:	e0ffff17 	ldw	r3,-4(fp)
 4044a34:	1004913a 	slli	r2,r2,4
 4044a38:	10c5883a 	add	r2,r2,r3
 4044a3c:	10801004 	addi	r2,r2,64
 4044a40:	11000017 	ldw	r4,0(r2)
 4044a44:	e0ffff17 	ldw	r3,-4(fp)
 4044a48:	2804913a 	slli	r2,r5,4
 4044a4c:	10c5883a 	add	r2,r2,r3
 4044a50:	10801004 	addi	r2,r2,64
 4044a54:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 4044a58:	e0bffd17 	ldw	r2,-12(fp)
 4044a5c:	e0ffff17 	ldw	r3,-4(fp)
 4044a60:	1004913a 	slli	r2,r2,4
 4044a64:	10c5883a 	add	r2,r2,r3
 4044a68:	10c01004 	addi	r3,r2,64
 4044a6c:	e0bff917 	ldw	r2,-28(fp)
 4044a70:	18800015 	stw	r2,0(r3)
 
        swap = flash->dev.region_info[i].number_of_blocks;
 4044a74:	e0bffe17 	ldw	r2,-8(fp)
 4044a78:	e0ffff17 	ldw	r3,-4(fp)
 4044a7c:	1004913a 	slli	r2,r2,4
 4044a80:	10c5883a 	add	r2,r2,r3
 4044a84:	10800f04 	addi	r2,r2,60
 4044a88:	10800017 	ldw	r2,0(r2)
 4044a8c:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].number_of_blocks =  
 4044a90:	e17ffe17 	ldw	r5,-8(fp)
 4044a94:	e0bffd17 	ldw	r2,-12(fp)
 4044a98:	e0ffff17 	ldw	r3,-4(fp)
 4044a9c:	1004913a 	slli	r2,r2,4
 4044aa0:	10c5883a 	add	r2,r2,r3
 4044aa4:	10800f04 	addi	r2,r2,60
 4044aa8:	11000017 	ldw	r4,0(r2)
 4044aac:	e0ffff17 	ldw	r3,-4(fp)
 4044ab0:	2804913a 	slli	r2,r5,4
 4044ab4:	10c5883a 	add	r2,r2,r3
 4044ab8:	10800f04 	addi	r2,r2,60
 4044abc:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
 4044ac0:	e0bffd17 	ldw	r2,-12(fp)
 4044ac4:	e0ffff17 	ldw	r3,-4(fp)
 4044ac8:	1004913a 	slli	r2,r2,4
 4044acc:	10c5883a 	add	r2,r2,r3
 4044ad0:	10c00f04 	addi	r3,r2,60
 4044ad4:	e0bff917 	ldw	r2,-28(fp)
 4044ad8:	18800015 	stw	r2,0(r3)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
 4044adc:	e0bffe17 	ldw	r2,-8(fp)
 4044ae0:	10bfffc4 	addi	r2,r2,-1
 4044ae4:	e0bffe15 	stw	r2,-8(fp)
 4044ae8:	e0bffd17 	ldw	r2,-12(fp)
 4044aec:	10800044 	addi	r2,r2,1
 4044af0:	e0bffd15 	stw	r2,-12(fp)
 4044af4:	e0fffd17 	ldw	r3,-12(fp)
 4044af8:	e0bffe17 	ldw	r2,-8(fp)
 4044afc:	10ffa90e 	bge	r2,r3,40449a4 <alt_read_cfi_table+0x388>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 4044b00:	e03ffe15 	stw	zero,-8(fp)
 4044b04:	00001306 	br	4044b54 <alt_read_cfi_table+0x538>
    {
      flash->dev.region_info[i].offset = offset;
 4044b08:	e0bffe17 	ldw	r2,-8(fp)
 4044b0c:	e0ffff17 	ldw	r3,-4(fp)
 4044b10:	1004913a 	slli	r2,r2,4
 4044b14:	10c5883a 	add	r2,r2,r3
 4044b18:	10c00d04 	addi	r3,r2,52
 4044b1c:	e0bff617 	ldw	r2,-40(fp)
 4044b20:	18800015 	stw	r2,0(r3)
      offset += flash->dev.region_info[i].region_size;
 4044b24:	e0bffe17 	ldw	r2,-8(fp)
 4044b28:	e0ffff17 	ldw	r3,-4(fp)
 4044b2c:	1004913a 	slli	r2,r2,4
 4044b30:	10c5883a 	add	r2,r2,r3
 4044b34:	10800e04 	addi	r2,r2,56
 4044b38:	10c00017 	ldw	r3,0(r2)
 4044b3c:	e0bff617 	ldw	r2,-40(fp)
 4044b40:	10c5883a 	add	r2,r2,r3
 4044b44:	e0bff615 	stw	r2,-40(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 4044b48:	e0bffe17 	ldw	r2,-8(fp)
 4044b4c:	10800044 	addi	r2,r2,1
 4044b50:	e0bffe15 	stw	r2,-8(fp)
 4044b54:	e0bfff17 	ldw	r2,-4(fp)
 4044b58:	10c00c17 	ldw	r3,48(r2)
 4044b5c:	e0bffe17 	ldw	r2,-8(fp)
 4044b60:	10ffe916 	blt	r2,r3,4044b08 <alt_read_cfi_table+0x4ec>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }
    
    (*flash->write_command)(flash->dev.base_addr, 
 4044b64:	e0bfff17 	ldw	r2,-4(fp)
 4044b68:	10c03317 	ldw	r3,204(r2)
 4044b6c:	e0bfff17 	ldw	r2,-4(fp)
 4044b70:	11000a17 	ldw	r4,40(r2)
 4044b74:	01401544 	movi	r5,85
 4044b78:	01803c04 	movi	r6,240
 4044b7c:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_MODE);
  }  

  return ret_code;
 4044b80:	e0bffb17 	ldw	r2,-20(fp)
}
 4044b84:	e037883a 	mov	sp,fp
 4044b88:	dfc00217 	ldw	ra,8(sp)
 4044b8c:	df000117 	ldw	fp,4(sp)
 4044b90:	dc000017 	ldw	r16,0(sp)
 4044b94:	dec00304 	addi	sp,sp,12
 4044b98:	f800283a 	ret

04044b9c <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
 4044b9c:	defff704 	addi	sp,sp,-36
 4044ba0:	dfc00815 	stw	ra,32(sp)
 4044ba4:	df000715 	stw	fp,28(sp)
 4044ba8:	df000704 	addi	fp,sp,28
 4044bac:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
 4044bb0:	e03ff915 	stw	zero,-28(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 4044bb4:	e0bfff17 	ldw	r2,-4(fp)
 4044bb8:	11000a17 	ldw	r4,40(r2)
 4044bbc:	01401544 	movi	r5,85
 4044bc0:	01802604 	movi	r6,152
 4044bc4:	40440a80 	call	40440a8 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
 4044bc8:	e03ffb15 	stw	zero,-20(fp)
 4044bcc:	00000f06 	br	4044c0c <alt_read_cfi_width+0x70>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
 4044bd0:	e13ffb17 	ldw	r4,-20(fp)
 4044bd4:	e0bfff17 	ldw	r2,-4(fp)
 4044bd8:	10800a17 	ldw	r2,40(r2)
 4044bdc:	1007883a 	mov	r3,r2
 4044be0:	e0bffb17 	ldw	r2,-20(fp)
 4044be4:	1885883a 	add	r2,r3,r2
 4044be8:	10800404 	addi	r2,r2,16
 4044bec:	10800023 	ldbuio	r2,0(r2)
 4044bf0:	1007883a 	mov	r3,r2
 4044bf4:	e0bffc04 	addi	r2,fp,-16
 4044bf8:	1105883a 	add	r2,r2,r4
 4044bfc:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
 4044c00:	e0bffb17 	ldw	r2,-20(fp)
 4044c04:	10800044 	addi	r2,r2,1
 4044c08:	e0bffb15 	stw	r2,-20(fp)
 4044c0c:	e0bffb17 	ldw	r2,-20(fp)
 4044c10:	108000d0 	cmplti	r2,r2,3
 4044c14:	103fee1e 	bne	r2,zero,4044bd0 <alt_read_cfi_width+0x34>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 4044c18:	e0bffc03 	ldbu	r2,-16(fp)
 4044c1c:	10803fcc 	andi	r2,r2,255
 4044c20:	10801458 	cmpnei	r2,r2,81
 4044c24:	10001d1e 	bne	r2,zero,4044c9c <alt_read_cfi_width+0x100>
 4044c28:	e0bffc43 	ldbu	r2,-15(fp)
 4044c2c:	10803fcc 	andi	r2,r2,255
 4044c30:	10801498 	cmpnei	r2,r2,82
 4044c34:	1000191e 	bne	r2,zero,4044c9c <alt_read_cfi_width+0x100>
 4044c38:	e0bffc83 	ldbu	r2,-14(fp)
 4044c3c:	10803fcc 	andi	r2,r2,255
 4044c40:	10801658 	cmpnei	r2,r2,89
 4044c44:	1000151e 	bne	r2,zero,4044c9c <alt_read_cfi_width+0x100>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
 4044c48:	e0ffff17 	ldw	r3,-4(fp)
 4044c4c:	00800044 	movi	r2,1
 4044c50:	18802e15 	stw	r2,184(r3)
    flash->device_width = 1; 
 4044c54:	e0ffff17 	ldw	r3,-4(fp)
 4044c58:	00800044 	movi	r2,1
 4044c5c:	18802f15 	stw	r2,188(r3)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
 4044c60:	e0bfff17 	ldw	r2,-4(fp)
 4044c64:	10800a17 	ldw	r2,40(r2)
 4044c68:	10800a04 	addi	r2,r2,40
 4044c6c:	1080002b 	ldhuio	r2,0(r2)
 4044c70:	e0bffa0d 	sth	r2,-24(fp)
    iface += 1;
 4044c74:	e0bffa0b 	ldhu	r2,-24(fp)
 4044c78:	10800044 	addi	r2,r2,1
 4044c7c:	e0bffa0d 	sth	r2,-24(fp)
    if (!(iface & 0x1))
 4044c80:	e0bffa0b 	ldhu	r2,-24(fp)
 4044c84:	1080004c 	andi	r2,r2,1
 4044c88:	1004c03a 	cmpne	r2,r2,zero
 4044c8c:	1001a81e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
    {
      ret_code = -ENODEV;
 4044c90:	00bffb44 	movi	r2,-19
 4044c94:	e0bff915 	stw	r2,-28(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 4044c98:	0001a506 	br	4045330 <alt_read_cfi_width+0x794>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 4044c9c:	e0bfff17 	ldw	r2,-4(fp)
 4044ca0:	11000a17 	ldw	r4,40(r2)
 4044ca4:	01401544 	movi	r5,85
 4044ca8:	01802604 	movi	r6,152
 4044cac:	40440e40 	call	40440e4 <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
 4044cb0:	e03ffb15 	stw	zero,-20(fp)
 4044cb4:	00000f06 	br	4044cf4 <alt_read_cfi_width+0x158>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 4044cb8:	e13ffb17 	ldw	r4,-20(fp)
 4044cbc:	e0bfff17 	ldw	r2,-4(fp)
 4044cc0:	10800a17 	ldw	r2,40(r2)
 4044cc4:	1007883a 	mov	r3,r2
 4044cc8:	e0bffb17 	ldw	r2,-20(fp)
 4044ccc:	1885883a 	add	r2,r3,r2
 4044cd0:	10800804 	addi	r2,r2,32
 4044cd4:	10800023 	ldbuio	r2,0(r2)
 4044cd8:	1007883a 	mov	r3,r2
 4044cdc:	e0bffc04 	addi	r2,fp,-16
 4044ce0:	1105883a 	add	r2,r2,r4
 4044ce4:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
 4044ce8:	e0bffb17 	ldw	r2,-20(fp)
 4044cec:	10800044 	addi	r2,r2,1
 4044cf0:	e0bffb15 	stw	r2,-20(fp)
 4044cf4:	e0bffb17 	ldw	r2,-20(fp)
 4044cf8:	10800190 	cmplti	r2,r2,6
 4044cfc:	103fee1e 	bne	r2,zero,4044cb8 <alt_read_cfi_width+0x11c>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 4044d00:	e0bffc03 	ldbu	r2,-16(fp)
 4044d04:	10803fcc 	andi	r2,r2,255
 4044d08:	10801458 	cmpnei	r2,r2,81
 4044d0c:	1000291e 	bne	r2,zero,4044db4 <alt_read_cfi_width+0x218>
 4044d10:	e0bffc43 	ldbu	r2,-15(fp)
 4044d14:	10803fcc 	andi	r2,r2,255
 4044d18:	10801458 	cmpnei	r2,r2,81
 4044d1c:	1000251e 	bne	r2,zero,4044db4 <alt_read_cfi_width+0x218>
 4044d20:	e0bffc83 	ldbu	r2,-14(fp)
 4044d24:	10803fcc 	andi	r2,r2,255
 4044d28:	10801498 	cmpnei	r2,r2,82
 4044d2c:	1000211e 	bne	r2,zero,4044db4 <alt_read_cfi_width+0x218>
 4044d30:	e0bffcc3 	ldbu	r2,-13(fp)
 4044d34:	10803fcc 	andi	r2,r2,255
 4044d38:	10801498 	cmpnei	r2,r2,82
 4044d3c:	10001d1e 	bne	r2,zero,4044db4 <alt_read_cfi_width+0x218>
 4044d40:	e0bffd03 	ldbu	r2,-12(fp)
 4044d44:	10803fcc 	andi	r2,r2,255
 4044d48:	10801658 	cmpnei	r2,r2,89
 4044d4c:	1000191e 	bne	r2,zero,4044db4 <alt_read_cfi_width+0x218>
 4044d50:	e0bffd43 	ldbu	r2,-11(fp)
 4044d54:	10803fcc 	andi	r2,r2,255
 4044d58:	10801658 	cmpnei	r2,r2,89
 4044d5c:	1000151e 	bne	r2,zero,4044db4 <alt_read_cfi_width+0x218>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
 4044d60:	e0ffff17 	ldw	r3,-4(fp)
 4044d64:	00800044 	movi	r2,1
 4044d68:	18802e15 	stw	r2,184(r3)
      flash->device_width = 2; 
 4044d6c:	e0ffff17 	ldw	r3,-4(fp)
 4044d70:	00800084 	movi	r2,2
 4044d74:	18802f15 	stw	r2,188(r3)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 4044d78:	e0bfff17 	ldw	r2,-4(fp)
 4044d7c:	10800a17 	ldw	r2,40(r2)
 4044d80:	10801404 	addi	r2,r2,80
 4044d84:	1080002b 	ldhuio	r2,0(r2)
 4044d88:	e0bffa0d 	sth	r2,-24(fp)
      iface += 1;
 4044d8c:	e0bffa0b 	ldhu	r2,-24(fp)
 4044d90:	10800044 	addi	r2,r2,1
 4044d94:	e0bffa0d 	sth	r2,-24(fp)
      if (!(iface & 0x1))
 4044d98:	e0bffa0b 	ldhu	r2,-24(fp)
 4044d9c:	1080004c 	andi	r2,r2,1
 4044da0:	1004c03a 	cmpne	r2,r2,zero
 4044da4:	1001621e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
      {
        ret_code = -ENODEV;
 4044da8:	00bffb44 	movi	r2,-19
 4044dac:	e0bff915 	stw	r2,-28(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 4044db0:	00015f06 	br	4045330 <alt_read_cfi_width+0x794>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 4044db4:	e0bfff17 	ldw	r2,-4(fp)
 4044db8:	11000a17 	ldw	r4,40(r2)
 4044dbc:	01401544 	movi	r5,85
 4044dc0:	01802604 	movi	r6,152
 4044dc4:	40441a80 	call	40441a8 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
 4044dc8:	e03ffb15 	stw	zero,-20(fp)
 4044dcc:	00000f06 	br	4044e0c <alt_read_cfi_width+0x270>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 4044dd0:	e13ffb17 	ldw	r4,-20(fp)
 4044dd4:	e0bfff17 	ldw	r2,-4(fp)
 4044dd8:	10800a17 	ldw	r2,40(r2)
 4044ddc:	1007883a 	mov	r3,r2
 4044de0:	e0bffb17 	ldw	r2,-20(fp)
 4044de4:	1885883a 	add	r2,r3,r2
 4044de8:	10800804 	addi	r2,r2,32
 4044dec:	10800023 	ldbuio	r2,0(r2)
 4044df0:	1007883a 	mov	r3,r2
 4044df4:	e0bffc04 	addi	r2,fp,-16
 4044df8:	1105883a 	add	r2,r2,r4
 4044dfc:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
 4044e00:	e0bffb17 	ldw	r2,-20(fp)
 4044e04:	10800044 	addi	r2,r2,1
 4044e08:	e0bffb15 	stw	r2,-20(fp)
 4044e0c:	e0bffb17 	ldw	r2,-20(fp)
 4044e10:	10800190 	cmplti	r2,r2,6
 4044e14:	103fee1e 	bne	r2,zero,4044dd0 <alt_read_cfi_width+0x234>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 4044e18:	e0bffc03 	ldbu	r2,-16(fp)
 4044e1c:	10803fcc 	andi	r2,r2,255
 4044e20:	10801458 	cmpnei	r2,r2,81
 4044e24:	1000291e 	bne	r2,zero,4044ecc <alt_read_cfi_width+0x330>
 4044e28:	e0bffc43 	ldbu	r2,-15(fp)
 4044e2c:	10803fcc 	andi	r2,r2,255
 4044e30:	1004c03a 	cmpne	r2,r2,zero
 4044e34:	1000251e 	bne	r2,zero,4044ecc <alt_read_cfi_width+0x330>
 4044e38:	e0bffc83 	ldbu	r2,-14(fp)
 4044e3c:	10803fcc 	andi	r2,r2,255
 4044e40:	10801498 	cmpnei	r2,r2,82
 4044e44:	1000211e 	bne	r2,zero,4044ecc <alt_read_cfi_width+0x330>
 4044e48:	e0bffcc3 	ldbu	r2,-13(fp)
 4044e4c:	10803fcc 	andi	r2,r2,255
 4044e50:	1004c03a 	cmpne	r2,r2,zero
 4044e54:	10001d1e 	bne	r2,zero,4044ecc <alt_read_cfi_width+0x330>
 4044e58:	e0bffd03 	ldbu	r2,-12(fp)
 4044e5c:	10803fcc 	andi	r2,r2,255
 4044e60:	10801658 	cmpnei	r2,r2,89
 4044e64:	1000191e 	bne	r2,zero,4044ecc <alt_read_cfi_width+0x330>
 4044e68:	e0bffd43 	ldbu	r2,-11(fp)
 4044e6c:	10803fcc 	andi	r2,r2,255
 4044e70:	1004c03a 	cmpne	r2,r2,zero
 4044e74:	1000151e 	bne	r2,zero,4044ecc <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
 4044e78:	e0ffff17 	ldw	r3,-4(fp)
 4044e7c:	00800084 	movi	r2,2
 4044e80:	18802e15 	stw	r2,184(r3)
        flash->device_width = 2; 
 4044e84:	e0ffff17 	ldw	r3,-4(fp)
 4044e88:	00800084 	movi	r2,2
 4044e8c:	18802f15 	stw	r2,188(r3)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 4044e90:	e0bfff17 	ldw	r2,-4(fp)
 4044e94:	10800a17 	ldw	r2,40(r2)
 4044e98:	10801404 	addi	r2,r2,80
 4044e9c:	1080002b 	ldhuio	r2,0(r2)
 4044ea0:	e0bffa0d 	sth	r2,-24(fp)
        iface += 1;
 4044ea4:	e0bffa0b 	ldhu	r2,-24(fp)
 4044ea8:	10800044 	addi	r2,r2,1
 4044eac:	e0bffa0d 	sth	r2,-24(fp)
        if (!(iface & 0x2))
 4044eb0:	e0bffa0b 	ldhu	r2,-24(fp)
 4044eb4:	1080008c 	andi	r2,r2,2
 4044eb8:	1004c03a 	cmpne	r2,r2,zero
 4044ebc:	10011c1e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
        {
          ret_code = -ENODEV;
 4044ec0:	00bffb44 	movi	r2,-19
 4044ec4:	e0bff915 	stw	r2,-28(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 4044ec8:	00011906 	br	4045330 <alt_read_cfi_width+0x794>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 4044ecc:	e0bfff17 	ldw	r2,-4(fp)
 4044ed0:	11000a17 	ldw	r4,40(r2)
 4044ed4:	01401544 	movi	r5,85
 4044ed8:	01802604 	movi	r6,152
 4044edc:	40442340 	call	4044234 <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
 4044ee0:	e03ffb15 	stw	zero,-20(fp)
 4044ee4:	00000f06 	br	4044f24 <alt_read_cfi_width+0x388>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 4044ee8:	e13ffb17 	ldw	r4,-20(fp)
 4044eec:	e0bfff17 	ldw	r2,-4(fp)
 4044ef0:	10800a17 	ldw	r2,40(r2)
 4044ef4:	1007883a 	mov	r3,r2
 4044ef8:	e0bffb17 	ldw	r2,-20(fp)
 4044efc:	1885883a 	add	r2,r3,r2
 4044f00:	10801004 	addi	r2,r2,64
 4044f04:	10800023 	ldbuio	r2,0(r2)
 4044f08:	1007883a 	mov	r3,r2
 4044f0c:	e0bffc04 	addi	r2,fp,-16
 4044f10:	1105883a 	add	r2,r2,r4
 4044f14:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
 4044f18:	e0bffb17 	ldw	r2,-20(fp)
 4044f1c:	10800044 	addi	r2,r2,1
 4044f20:	e0bffb15 	stw	r2,-20(fp)
 4044f24:	e0bffb17 	ldw	r2,-20(fp)
 4044f28:	10800310 	cmplti	r2,r2,12
 4044f2c:	103fee1e 	bne	r2,zero,4044ee8 <alt_read_cfi_width+0x34c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 4044f30:	e0bffc03 	ldbu	r2,-16(fp)
 4044f34:	10803fcc 	andi	r2,r2,255
 4044f38:	10801458 	cmpnei	r2,r2,81
 4044f3c:	1000411e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044f40:	e0bffc43 	ldbu	r2,-15(fp)
 4044f44:	10803fcc 	andi	r2,r2,255
 4044f48:	1004c03a 	cmpne	r2,r2,zero
 4044f4c:	10003d1e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044f50:	e0bffc83 	ldbu	r2,-14(fp)
 4044f54:	10803fcc 	andi	r2,r2,255
 4044f58:	1004c03a 	cmpne	r2,r2,zero
 4044f5c:	1000391e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044f60:	e0bffcc3 	ldbu	r2,-13(fp)
 4044f64:	10803fcc 	andi	r2,r2,255
 4044f68:	1004c03a 	cmpne	r2,r2,zero
 4044f6c:	1000351e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044f70:	e0bffd03 	ldbu	r2,-12(fp)
 4044f74:	10803fcc 	andi	r2,r2,255
 4044f78:	10801498 	cmpnei	r2,r2,82
 4044f7c:	1000311e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044f80:	e0bffd43 	ldbu	r2,-11(fp)
 4044f84:	10803fcc 	andi	r2,r2,255
 4044f88:	1004c03a 	cmpne	r2,r2,zero
 4044f8c:	10002d1e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044f90:	e0bffd83 	ldbu	r2,-10(fp)
 4044f94:	10803fcc 	andi	r2,r2,255
 4044f98:	1004c03a 	cmpne	r2,r2,zero
 4044f9c:	1000291e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044fa0:	e0bffdc3 	ldbu	r2,-9(fp)
 4044fa4:	10803fcc 	andi	r2,r2,255
 4044fa8:	1004c03a 	cmpne	r2,r2,zero
 4044fac:	1000251e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044fb0:	e0bffe03 	ldbu	r2,-8(fp)
 4044fb4:	10803fcc 	andi	r2,r2,255
 4044fb8:	10801658 	cmpnei	r2,r2,89
 4044fbc:	1000211e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044fc0:	e0bffe43 	ldbu	r2,-7(fp)
 4044fc4:	10803fcc 	andi	r2,r2,255
 4044fc8:	1004c03a 	cmpne	r2,r2,zero
 4044fcc:	10001d1e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044fd0:	e0bffe83 	ldbu	r2,-6(fp)
 4044fd4:	10803fcc 	andi	r2,r2,255
 4044fd8:	1004c03a 	cmpne	r2,r2,zero
 4044fdc:	1000191e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
 4044fe0:	e0bffec3 	ldbu	r2,-5(fp)
 4044fe4:	10803fcc 	andi	r2,r2,255
 4044fe8:	1004c03a 	cmpne	r2,r2,zero
 4044fec:	1000151e 	bne	r2,zero,4045044 <alt_read_cfi_width+0x4a8>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
 4044ff0:	e0ffff17 	ldw	r3,-4(fp)
 4044ff4:	00800104 	movi	r2,4
 4044ff8:	18802e15 	stw	r2,184(r3)
          flash->device_width = 4; 
 4044ffc:	e0ffff17 	ldw	r3,-4(fp)
 4045000:	00800104 	movi	r2,4
 4045004:	18802f15 	stw	r2,188(r3)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 4045008:	e0bfff17 	ldw	r2,-4(fp)
 404500c:	10800a17 	ldw	r2,40(r2)
 4045010:	10802804 	addi	r2,r2,160
 4045014:	10800037 	ldwio	r2,0(r2)
 4045018:	e0bffa0d 	sth	r2,-24(fp)
          iface += 1;
 404501c:	e0bffa0b 	ldhu	r2,-24(fp)
 4045020:	10800044 	addi	r2,r2,1
 4045024:	e0bffa0d 	sth	r2,-24(fp)
          if (!(iface & 0x4))
 4045028:	e0bffa0b 	ldhu	r2,-24(fp)
 404502c:	1080010c 	andi	r2,r2,4
 4045030:	1004c03a 	cmpne	r2,r2,zero
 4045034:	1000be1e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
          {
            ret_code = -ENODEV;
 4045038:	00bffb44 	movi	r2,-19
 404503c:	e0bff915 	stw	r2,-28(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 4045040:	0000bb06 	br	4045330 <alt_read_cfi_width+0x794>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 4045044:	e0bfff17 	ldw	r2,-4(fp)
 4045048:	11000a17 	ldw	r4,40(r2)
 404504c:	01401544 	movi	r5,85
 4045050:	01802604 	movi	r6,152
 4045054:	40441ec0 	call	40441ec <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
 4045058:	e03ffb15 	stw	zero,-20(fp)
 404505c:	00000f06 	br	404509c <alt_read_cfi_width+0x500>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 4045060:	e13ffb17 	ldw	r4,-20(fp)
 4045064:	e0bfff17 	ldw	r2,-4(fp)
 4045068:	10800a17 	ldw	r2,40(r2)
 404506c:	1007883a 	mov	r3,r2
 4045070:	e0bffb17 	ldw	r2,-20(fp)
 4045074:	1885883a 	add	r2,r3,r2
 4045078:	10801004 	addi	r2,r2,64
 404507c:	10800023 	ldbuio	r2,0(r2)
 4045080:	1007883a 	mov	r3,r2
 4045084:	e0bffc04 	addi	r2,fp,-16
 4045088:	1105883a 	add	r2,r2,r4
 404508c:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
 4045090:	e0bffb17 	ldw	r2,-20(fp)
 4045094:	10800044 	addi	r2,r2,1
 4045098:	e0bffb15 	stw	r2,-20(fp)
 404509c:	e0bffb17 	ldw	r2,-20(fp)
 40450a0:	10800310 	cmplti	r2,r2,12
 40450a4:	103fee1e 	bne	r2,zero,4045060 <alt_read_cfi_width+0x4c4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 40450a8:	e0bffc03 	ldbu	r2,-16(fp)
 40450ac:	10803fcc 	andi	r2,r2,255
 40450b0:	10801458 	cmpnei	r2,r2,81
 40450b4:	1000411e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 40450b8:	e0bffc43 	ldbu	r2,-15(fp)
 40450bc:	10803fcc 	andi	r2,r2,255
 40450c0:	1004c03a 	cmpne	r2,r2,zero
 40450c4:	10003d1e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 40450c8:	e0bffc83 	ldbu	r2,-14(fp)
 40450cc:	10803fcc 	andi	r2,r2,255
 40450d0:	10801458 	cmpnei	r2,r2,81
 40450d4:	1000391e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 40450d8:	e0bffcc3 	ldbu	r2,-13(fp)
 40450dc:	10803fcc 	andi	r2,r2,255
 40450e0:	1004c03a 	cmpne	r2,r2,zero
 40450e4:	1000351e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 40450e8:	e0bffd03 	ldbu	r2,-12(fp)
 40450ec:	10803fcc 	andi	r2,r2,255
 40450f0:	10801498 	cmpnei	r2,r2,82
 40450f4:	1000311e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 40450f8:	e0bffd43 	ldbu	r2,-11(fp)
 40450fc:	10803fcc 	andi	r2,r2,255
 4045100:	1004c03a 	cmpne	r2,r2,zero
 4045104:	10002d1e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 4045108:	e0bffd83 	ldbu	r2,-10(fp)
 404510c:	10803fcc 	andi	r2,r2,255
 4045110:	10801498 	cmpnei	r2,r2,82
 4045114:	1000291e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 4045118:	e0bffdc3 	ldbu	r2,-9(fp)
 404511c:	10803fcc 	andi	r2,r2,255
 4045120:	1004c03a 	cmpne	r2,r2,zero
 4045124:	1000251e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 4045128:	e0bffe03 	ldbu	r2,-8(fp)
 404512c:	10803fcc 	andi	r2,r2,255
 4045130:	10801658 	cmpnei	r2,r2,89
 4045134:	1000211e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 4045138:	e0bffe43 	ldbu	r2,-7(fp)
 404513c:	10803fcc 	andi	r2,r2,255
 4045140:	1004c03a 	cmpne	r2,r2,zero
 4045144:	10001d1e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 4045148:	e0bffe83 	ldbu	r2,-6(fp)
 404514c:	10803fcc 	andi	r2,r2,255
 4045150:	10801658 	cmpnei	r2,r2,89
 4045154:	1000191e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
 4045158:	e0bffec3 	ldbu	r2,-5(fp)
 404515c:	10803fcc 	andi	r2,r2,255
 4045160:	1004c03a 	cmpne	r2,r2,zero
 4045164:	1000151e 	bne	r2,zero,40451bc <alt_read_cfi_width+0x620>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
 4045168:	e0ffff17 	ldw	r3,-4(fp)
 404516c:	00800084 	movi	r2,2
 4045170:	18802e15 	stw	r2,184(r3)
            flash->device_width = 4; 
 4045174:	e0ffff17 	ldw	r3,-4(fp)
 4045178:	00800104 	movi	r2,4
 404517c:	18802f15 	stw	r2,188(r3)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 4045180:	e0bfff17 	ldw	r2,-4(fp)
 4045184:	10800a17 	ldw	r2,40(r2)
 4045188:	10802804 	addi	r2,r2,160
 404518c:	10800037 	ldwio	r2,0(r2)
 4045190:	e0bffa0d 	sth	r2,-24(fp)
            iface += 1;
 4045194:	e0bffa0b 	ldhu	r2,-24(fp)
 4045198:	10800044 	addi	r2,r2,1
 404519c:	e0bffa0d 	sth	r2,-24(fp)
            if (!(iface & 0x4))
 40451a0:	e0bffa0b 	ldhu	r2,-24(fp)
 40451a4:	1080010c 	andi	r2,r2,4
 40451a8:	1004c03a 	cmpne	r2,r2,zero
 40451ac:	1000601e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
            {
              ret_code = -ENODEV;
 40451b0:	00bffb44 	movi	r2,-19
 40451b4:	e0bff915 	stw	r2,-28(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 40451b8:	00005d06 	br	4045330 <alt_read_cfi_width+0x794>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 40451bc:	e0bfff17 	ldw	r2,-4(fp)
 40451c0:	11000a17 	ldw	r4,40(r2)
 40451c4:	01401544 	movi	r5,85
 40451c8:	01802604 	movi	r6,152
 40451cc:	40441600 	call	4044160 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
 40451d0:	e03ffb15 	stw	zero,-20(fp)
 40451d4:	00000f06 	br	4045214 <alt_read_cfi_width+0x678>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 40451d8:	e13ffb17 	ldw	r4,-20(fp)
 40451dc:	e0bfff17 	ldw	r2,-4(fp)
 40451e0:	10800a17 	ldw	r2,40(r2)
 40451e4:	1007883a 	mov	r3,r2
 40451e8:	e0bffb17 	ldw	r2,-20(fp)
 40451ec:	1885883a 	add	r2,r3,r2
 40451f0:	10801004 	addi	r2,r2,64
 40451f4:	10800023 	ldbuio	r2,0(r2)
 40451f8:	1007883a 	mov	r3,r2
 40451fc:	e0bffc04 	addi	r2,fp,-16
 4045200:	1105883a 	add	r2,r2,r4
 4045204:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
 4045208:	e0bffb17 	ldw	r2,-20(fp)
 404520c:	10800044 	addi	r2,r2,1
 4045210:	e0bffb15 	stw	r2,-20(fp)
 4045214:	e0bffb17 	ldw	r2,-20(fp)
 4045218:	10800310 	cmplti	r2,r2,12
 404521c:	103fee1e 	bne	r2,zero,40451d8 <alt_read_cfi_width+0x63c>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 4045220:	e0bffc03 	ldbu	r2,-16(fp)
 4045224:	10803fcc 	andi	r2,r2,255
 4045228:	10801458 	cmpnei	r2,r2,81
 404522c:	1000401e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 4045230:	e0bffc43 	ldbu	r2,-15(fp)
 4045234:	10803fcc 	andi	r2,r2,255
 4045238:	10801458 	cmpnei	r2,r2,81
 404523c:	10003c1e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 4045240:	e0bffc83 	ldbu	r2,-14(fp)
 4045244:	10803fcc 	andi	r2,r2,255
 4045248:	10801458 	cmpnei	r2,r2,81
 404524c:	1000381e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 4045250:	e0bffcc3 	ldbu	r2,-13(fp)
 4045254:	10803fcc 	andi	r2,r2,255
 4045258:	10801458 	cmpnei	r2,r2,81
 404525c:	1000341e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 4045260:	e0bffd03 	ldbu	r2,-12(fp)
 4045264:	10803fcc 	andi	r2,r2,255
 4045268:	10801498 	cmpnei	r2,r2,82
 404526c:	1000301e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 4045270:	e0bffd43 	ldbu	r2,-11(fp)
 4045274:	10803fcc 	andi	r2,r2,255
 4045278:	10801498 	cmpnei	r2,r2,82
 404527c:	10002c1e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 4045280:	e0bffd83 	ldbu	r2,-10(fp)
 4045284:	10803fcc 	andi	r2,r2,255
 4045288:	10801498 	cmpnei	r2,r2,82
 404528c:	1000281e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 4045290:	e0bffdc3 	ldbu	r2,-9(fp)
 4045294:	10803fcc 	andi	r2,r2,255
 4045298:	10801498 	cmpnei	r2,r2,82
 404529c:	1000241e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 40452a0:	e0bffe03 	ldbu	r2,-8(fp)
 40452a4:	10803fcc 	andi	r2,r2,255
 40452a8:	10801658 	cmpnei	r2,r2,89
 40452ac:	1000201e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 40452b0:	e0bffe43 	ldbu	r2,-7(fp)
 40452b4:	10803fcc 	andi	r2,r2,255
 40452b8:	10801658 	cmpnei	r2,r2,89
 40452bc:	10001c1e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 40452c0:	e0bffe83 	ldbu	r2,-6(fp)
 40452c4:	10803fcc 	andi	r2,r2,255
 40452c8:	10801658 	cmpnei	r2,r2,89
 40452cc:	1000181e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
 40452d0:	e0bffec3 	ldbu	r2,-5(fp)
 40452d4:	10803fcc 	andi	r2,r2,255
 40452d8:	10801658 	cmpnei	r2,r2,89
 40452dc:	1000141e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
 40452e0:	e0ffff17 	ldw	r3,-4(fp)
 40452e4:	00800044 	movi	r2,1
 40452e8:	18802e15 	stw	r2,184(r3)
              flash->device_width = 4; 
 40452ec:	e0ffff17 	ldw	r3,-4(fp)
 40452f0:	00800104 	movi	r2,4
 40452f4:	18802f15 	stw	r2,188(r3)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 40452f8:	e0bfff17 	ldw	r2,-4(fp)
 40452fc:	10800a17 	ldw	r2,40(r2)
 4045300:	10802804 	addi	r2,r2,160
 4045304:	10800037 	ldwio	r2,0(r2)
 4045308:	e0bffa0d 	sth	r2,-24(fp)
              iface += 1;
 404530c:	e0bffa0b 	ldhu	r2,-24(fp)
 4045310:	10800044 	addi	r2,r2,1
 4045314:	e0bffa0d 	sth	r2,-24(fp)
              if (!(iface & 0x4))
 4045318:	e0bffa0b 	ldhu	r2,-24(fp)
 404531c:	1080010c 	andi	r2,r2,4
 4045320:	1004c03a 	cmpne	r2,r2,zero
 4045324:	1000021e 	bne	r2,zero,4045330 <alt_read_cfi_width+0x794>
              {
                ret_code = -ENODEV;
 4045328:	00bffb44 	movi	r2,-19
 404532c:	e0bff915 	stw	r2,-28(fp)
        }
      }
    }
  }
  
  return ret_code;
 4045330:	e0bff917 	ldw	r2,-28(fp)
}
 4045334:	e037883a 	mov	sp,fp
 4045338:	dfc00117 	ldw	ra,4(sp)
 404533c:	df000017 	ldw	fp,0(sp)
 4045340:	dec00204 	addi	sp,sp,8
 4045344:	f800283a 	ret

04045348 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
 4045348:	defff904 	addi	sp,sp,-28
 404534c:	dfc00615 	stw	ra,24(sp)
 4045350:	df000515 	stw	fp,20(sp)
 4045354:	dc000415 	stw	r16,16(sp)
 4045358:	df000404 	addi	fp,sp,16
 404535c:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
 4045360:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
 4045364:	e13fff17 	ldw	r4,-4(fp)
 4045368:	01400544 	movi	r5,21
 404536c:	40445a00 	call	40445a0 <alt_read_16bit_query_entry>
 4045370:	10ffffcc 	andi	r3,r2,65535
 4045374:	e0bfff17 	ldw	r2,-4(fp)
 4045378:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 404537c:	e03ffd15 	stw	zero,-12(fp)
 4045380:	00001006 	br	40453c4 <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
 4045384:	e43ffd17 	ldw	r16,-12(fp)
 4045388:	e0bfff17 	ldw	r2,-4(fp)
 404538c:	11803417 	ldw	r6,208(r2)
 4045390:	e0bfff17 	ldw	r2,-4(fp)
 4045394:	10c03217 	ldw	r3,200(r2)
 4045398:	e0bffd17 	ldw	r2,-12(fp)
 404539c:	188b883a 	add	r5,r3,r2
 40453a0:	e13fff17 	ldw	r4,-4(fp)
 40453a4:	303ee83a 	callr	r6
 40453a8:	1007883a 	mov	r3,r2
 40453ac:	e0bffe04 	addi	r2,fp,-8
 40453b0:	1405883a 	add	r2,r2,r16
 40453b4:	10c00005 	stb	r3,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 40453b8:	e0bffd17 	ldw	r2,-12(fp)
 40453bc:	10800044 	addi	r2,r2,1
 40453c0:	e0bffd15 	stw	r2,-12(fp)
 40453c4:	e0bffd17 	ldw	r2,-12(fp)
 40453c8:	108000d0 	cmplti	r2,r2,3
 40453cc:	103fed1e 	bne	r2,zero,4045384 <alt_check_primary_table+0x3c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 40453d0:	e0bffe03 	ldbu	r2,-8(fp)
 40453d4:	10803fcc 	andi	r2,r2,255
 40453d8:	10801418 	cmpnei	r2,r2,80
 40453dc:	1000081e 	bne	r2,zero,4045400 <alt_check_primary_table+0xb8>
 40453e0:	e0bffe43 	ldbu	r2,-7(fp)
 40453e4:	10803fcc 	andi	r2,r2,255
 40453e8:	10801498 	cmpnei	r2,r2,82
 40453ec:	1000041e 	bne	r2,zero,4045400 <alt_check_primary_table+0xb8>
 40453f0:	e0bffe83 	ldbu	r2,-6(fp)
 40453f4:	10803fcc 	andi	r2,r2,255
 40453f8:	10801260 	cmpeqi	r2,r2,73
 40453fc:	1000021e 	bne	r2,zero,4045408 <alt_check_primary_table+0xc0>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
 4045400:	00bffb44 	movi	r2,-19
 4045404:	e0bffc15 	stw	r2,-16(fp)
  }
  
  return ret_code;
 4045408:	e0bffc17 	ldw	r2,-16(fp)
}
 404540c:	e037883a 	mov	sp,fp
 4045410:	dfc00217 	ldw	ra,8(sp)
 4045414:	df000117 	ldw	fp,4(sp)
 4045418:	dc000017 	ldw	r16,0(sp)
 404541c:	dec00304 	addi	sp,sp,12
 4045420:	f800283a 	ret

04045424 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 4045424:	defffa04 	addi	sp,sp,-24
 4045428:	dfc00515 	stw	ra,20(sp)
 404542c:	df000415 	stw	fp,16(sp)
 4045430:	df000404 	addi	fp,sp,16
 4045434:	e13ffd15 	stw	r4,-12(fp)
 4045438:	e17ffe15 	stw	r5,-8(fp)
 404543c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4045440:	e0bffd17 	ldw	r2,-12(fp)
 4045444:	10800017 	ldw	r2,0(r2)
 4045448:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 404544c:	e0bffc17 	ldw	r2,-16(fp)
 4045450:	11000a04 	addi	r4,r2,40
 4045454:	e0bffd17 	ldw	r2,-12(fp)
 4045458:	11c00217 	ldw	r7,8(r2)
 404545c:	e17ffe17 	ldw	r5,-8(fp)
 4045460:	e1bfff17 	ldw	r6,-4(fp)
 4045464:	4045a6c0 	call	4045a6c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 4045468:	e037883a 	mov	sp,fp
 404546c:	dfc00117 	ldw	ra,4(sp)
 4045470:	df000017 	ldw	fp,0(sp)
 4045474:	dec00204 	addi	sp,sp,8
 4045478:	f800283a 	ret

0404547c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 404547c:	defffa04 	addi	sp,sp,-24
 4045480:	dfc00515 	stw	ra,20(sp)
 4045484:	df000415 	stw	fp,16(sp)
 4045488:	df000404 	addi	fp,sp,16
 404548c:	e13ffd15 	stw	r4,-12(fp)
 4045490:	e17ffe15 	stw	r5,-8(fp)
 4045494:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4045498:	e0bffd17 	ldw	r2,-12(fp)
 404549c:	10800017 	ldw	r2,0(r2)
 40454a0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 40454a4:	e0bffc17 	ldw	r2,-16(fp)
 40454a8:	11000a04 	addi	r4,r2,40
 40454ac:	e0bffd17 	ldw	r2,-12(fp)
 40454b0:	11c00217 	ldw	r7,8(r2)
 40454b4:	e17ffe17 	ldw	r5,-8(fp)
 40454b8:	e1bfff17 	ldw	r6,-4(fp)
 40454bc:	4045c900 	call	4045c90 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 40454c0:	e037883a 	mov	sp,fp
 40454c4:	dfc00117 	ldw	ra,4(sp)
 40454c8:	df000017 	ldw	fp,0(sp)
 40454cc:	dec00204 	addi	sp,sp,8
 40454d0:	f800283a 	ret

040454d4 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 40454d4:	defffc04 	addi	sp,sp,-16
 40454d8:	dfc00315 	stw	ra,12(sp)
 40454dc:	df000215 	stw	fp,8(sp)
 40454e0:	df000204 	addi	fp,sp,8
 40454e4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 40454e8:	e0bfff17 	ldw	r2,-4(fp)
 40454ec:	10800017 	ldw	r2,0(r2)
 40454f0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 40454f4:	e0bffe17 	ldw	r2,-8(fp)
 40454f8:	11000a04 	addi	r4,r2,40
 40454fc:	e0bfff17 	ldw	r2,-4(fp)
 4045500:	11400217 	ldw	r5,8(r2)
 4045504:	40459040 	call	4045904 <altera_avalon_jtag_uart_close>
}
 4045508:	e037883a 	mov	sp,fp
 404550c:	dfc00117 	ldw	ra,4(sp)
 4045510:	df000017 	ldw	fp,0(sp)
 4045514:	dec00204 	addi	sp,sp,8
 4045518:	f800283a 	ret

0404551c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 404551c:	defffa04 	addi	sp,sp,-24
 4045520:	dfc00515 	stw	ra,20(sp)
 4045524:	df000415 	stw	fp,16(sp)
 4045528:	df000404 	addi	fp,sp,16
 404552c:	e13ffd15 	stw	r4,-12(fp)
 4045530:	e17ffe15 	stw	r5,-8(fp)
 4045534:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 4045538:	e0bffd17 	ldw	r2,-12(fp)
 404553c:	10800017 	ldw	r2,0(r2)
 4045540:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 4045544:	e0bffc17 	ldw	r2,-16(fp)
 4045548:	11000a04 	addi	r4,r2,40
 404554c:	e17ffe17 	ldw	r5,-8(fp)
 4045550:	e1bfff17 	ldw	r6,-4(fp)
 4045554:	40459780 	call	4045978 <altera_avalon_jtag_uart_ioctl>
}
 4045558:	e037883a 	mov	sp,fp
 404555c:	dfc00117 	ldw	ra,4(sp)
 4045560:	df000017 	ldw	fp,0(sp)
 4045564:	dec00204 	addi	sp,sp,8
 4045568:	f800283a 	ret

0404556c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 404556c:	defffa04 	addi	sp,sp,-24
 4045570:	dfc00515 	stw	ra,20(sp)
 4045574:	df000415 	stw	fp,16(sp)
 4045578:	df000404 	addi	fp,sp,16
 404557c:	e13ffd15 	stw	r4,-12(fp)
 4045580:	e17ffe15 	stw	r5,-8(fp)
 4045584:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4045588:	e0fffd17 	ldw	r3,-12(fp)
 404558c:	00800044 	movi	r2,1
 4045590:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 4045594:	e0bffd17 	ldw	r2,-12(fp)
 4045598:	10800017 	ldw	r2,0(r2)
 404559c:	11000104 	addi	r4,r2,4
 40455a0:	e0bffd17 	ldw	r2,-12(fp)
 40455a4:	10800817 	ldw	r2,32(r2)
 40455a8:	1007883a 	mov	r3,r2
 40455ac:	2005883a 	mov	r2,r4
 40455b0:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 40455b4:	e13ffe17 	ldw	r4,-8(fp)
 40455b8:	e17fff17 	ldw	r5,-4(fp)
 40455bc:	d8000015 	stw	zero,0(sp)
 40455c0:	01810134 	movhi	r6,1028
 40455c4:	31958b04 	addi	r6,r6,22060
 40455c8:	e1fffd17 	ldw	r7,-12(fp)
 40455cc:	40463bc0 	call	40463bc <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 40455d0:	e0bffd17 	ldw	r2,-12(fp)
 40455d4:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 40455d8:	e0bffd17 	ldw	r2,-12(fp)
 40455dc:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 40455e0:	00810174 	movhi	r2,1029
 40455e4:	10ad6904 	addi	r2,r2,-19036
 40455e8:	10800017 	ldw	r2,0(r2)
 40455ec:	100b883a 	mov	r5,r2
 40455f0:	01810134 	movhi	r6,1028
 40455f4:	31961504 	addi	r6,r6,22612
 40455f8:	e1fffd17 	ldw	r7,-12(fp)
 40455fc:	4045ed00 	call	4045ed0 <alt_alarm_start>
 4045600:	1004403a 	cmpge	r2,r2,zero
 4045604:	1000041e 	bne	r2,zero,4045618 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 4045608:	e0fffd17 	ldw	r3,-12(fp)
 404560c:	00a00034 	movhi	r2,32768
 4045610:	10bfffc4 	addi	r2,r2,-1
 4045614:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 4045618:	e037883a 	mov	sp,fp
 404561c:	dfc00117 	ldw	ra,4(sp)
 4045620:	df000017 	ldw	fp,0(sp)
 4045624:	dec00204 	addi	sp,sp,8
 4045628:	f800283a 	ret

0404562c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 404562c:	defff804 	addi	sp,sp,-32
 4045630:	df000715 	stw	fp,28(sp)
 4045634:	df000704 	addi	fp,sp,28
 4045638:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 404563c:	e0bfff17 	ldw	r2,-4(fp)
 4045640:	e0bffe15 	stw	r2,-8(fp)
  unsigned int base = sp->base;
 4045644:	e0bffe17 	ldw	r2,-8(fp)
 4045648:	10800017 	ldw	r2,0(r2)
 404564c:	e0bffd15 	stw	r2,-12(fp)
 4045650:	00000006 	br	4045654 <altera_avalon_jtag_uart_irq+0x28>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4045654:	e0bffd17 	ldw	r2,-12(fp)
 4045658:	10800104 	addi	r2,r2,4
 404565c:	10800037 	ldwio	r2,0(r2)
 4045660:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 4045664:	e0bffc17 	ldw	r2,-16(fp)
 4045668:	1080c00c 	andi	r2,r2,768
 404566c:	1005003a 	cmpeq	r2,r2,zero
 4045670:	1000741e 	bne	r2,zero,4045844 <altera_avalon_jtag_uart_irq+0x218>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 4045674:	e0bffc17 	ldw	r2,-16(fp)
 4045678:	1080400c 	andi	r2,r2,256
 404567c:	1005003a 	cmpeq	r2,r2,zero
 4045680:	1000351e 	bne	r2,zero,4045758 <altera_avalon_jtag_uart_irq+0x12c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 4045684:	00800074 	movhi	r2,1
 4045688:	e0bffb15 	stw	r2,-20(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 404568c:	e0bffe17 	ldw	r2,-8(fp)
 4045690:	10800a17 	ldw	r2,40(r2)
 4045694:	10800044 	addi	r2,r2,1
 4045698:	1081ffcc 	andi	r2,r2,2047
 404569c:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
 40456a0:	e0bffe17 	ldw	r2,-8(fp)
 40456a4:	10c00b17 	ldw	r3,44(r2)
 40456a8:	e0bffa17 	ldw	r2,-24(fp)
 40456ac:	18801626 	beq	r3,r2,4045708 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 40456b0:	e0bffd17 	ldw	r2,-12(fp)
 40456b4:	10800037 	ldwio	r2,0(r2)
 40456b8:	e0bffb15 	stw	r2,-20(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 40456bc:	e0bffb17 	ldw	r2,-20(fp)
 40456c0:	10a0000c 	andi	r2,r2,32768
 40456c4:	1005003a 	cmpeq	r2,r2,zero
 40456c8:	10000f1e 	bne	r2,zero,4045708 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 40456cc:	e0bffe17 	ldw	r2,-8(fp)
 40456d0:	10c00a17 	ldw	r3,40(r2)
 40456d4:	e0bffb17 	ldw	r2,-20(fp)
 40456d8:	1009883a 	mov	r4,r2
 40456dc:	e0bffe17 	ldw	r2,-8(fp)
 40456e0:	1885883a 	add	r2,r3,r2
 40456e4:	10800e04 	addi	r2,r2,56
 40456e8:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 40456ec:	e0bffe17 	ldw	r2,-8(fp)
 40456f0:	10800a17 	ldw	r2,40(r2)
 40456f4:	10800044 	addi	r2,r2,1
 40456f8:	10c1ffcc 	andi	r3,r2,2047
 40456fc:	e0bffe17 	ldw	r2,-8(fp)
 4045700:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 4045704:	003fe106 	br	404568c <altera_avalon_jtag_uart_irq+0x60>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 4045708:	e0bffb17 	ldw	r2,-20(fp)
 404570c:	10bfffec 	andhi	r2,r2,65535
 4045710:	1005003a 	cmpeq	r2,r2,zero
 4045714:	1000101e 	bne	r2,zero,4045758 <altera_avalon_jtag_uart_irq+0x12c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4045718:	e0bffe17 	ldw	r2,-8(fp)
 404571c:	10c00817 	ldw	r3,32(r2)
 4045720:	00bfff84 	movi	r2,-2
 4045724:	1886703a 	and	r3,r3,r2
 4045728:	e0bffe17 	ldw	r2,-8(fp)
 404572c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 4045730:	e0bffd17 	ldw	r2,-12(fp)
 4045734:	11000104 	addi	r4,r2,4
 4045738:	e0bffe17 	ldw	r2,-8(fp)
 404573c:	10800817 	ldw	r2,32(r2)
 4045740:	1007883a 	mov	r3,r2
 4045744:	2005883a 	mov	r2,r4
 4045748:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 404574c:	e0bffd17 	ldw	r2,-12(fp)
 4045750:	10800104 	addi	r2,r2,4
 4045754:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 4045758:	e0bffc17 	ldw	r2,-16(fp)
 404575c:	1080800c 	andi	r2,r2,512
 4045760:	1005003a 	cmpeq	r2,r2,zero
 4045764:	103fbb1e 	bne	r2,zero,4045654 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 4045768:	e0bffc17 	ldw	r2,-16(fp)
 404576c:	10bfffec 	andhi	r2,r2,65535
 4045770:	1004d43a 	srli	r2,r2,16
 4045774:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 4045778:	00001506 	br	40457d0 <altera_avalon_jtag_uart_irq+0x1a4>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 404577c:	e13ffd17 	ldw	r4,-12(fp)
 4045780:	e0bffe17 	ldw	r2,-8(fp)
 4045784:	10c00d17 	ldw	r3,52(r2)
 4045788:	e0bffe17 	ldw	r2,-8(fp)
 404578c:	1885883a 	add	r2,r3,r2
 4045790:	10820e04 	addi	r2,r2,2104
 4045794:	10800003 	ldbu	r2,0(r2)
 4045798:	10c03fcc 	andi	r3,r2,255
 404579c:	18c0201c 	xori	r3,r3,128
 40457a0:	18ffe004 	addi	r3,r3,-128
 40457a4:	2005883a 	mov	r2,r4
 40457a8:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 40457ac:	e0bffe17 	ldw	r2,-8(fp)
 40457b0:	10800d17 	ldw	r2,52(r2)
 40457b4:	10800044 	addi	r2,r2,1
 40457b8:	10c1ffcc 	andi	r3,r2,2047
 40457bc:	e0bffe17 	ldw	r2,-8(fp)
 40457c0:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 40457c4:	e0bff917 	ldw	r2,-28(fp)
 40457c8:	10bfffc4 	addi	r2,r2,-1
 40457cc:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 40457d0:	e0bff917 	ldw	r2,-28(fp)
 40457d4:	1005003a 	cmpeq	r2,r2,zero
 40457d8:	1000051e 	bne	r2,zero,40457f0 <altera_avalon_jtag_uart_irq+0x1c4>
 40457dc:	e0bffe17 	ldw	r2,-8(fp)
 40457e0:	10c00d17 	ldw	r3,52(r2)
 40457e4:	e0bffe17 	ldw	r2,-8(fp)
 40457e8:	10800c17 	ldw	r2,48(r2)
 40457ec:	18bfe31e 	bne	r3,r2,404577c <altera_avalon_jtag_uart_irq+0x150>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 40457f0:	e0bff917 	ldw	r2,-28(fp)
 40457f4:	1005003a 	cmpeq	r2,r2,zero
 40457f8:	103f961e 	bne	r2,zero,4045654 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 40457fc:	e0bffe17 	ldw	r2,-8(fp)
 4045800:	10c00817 	ldw	r3,32(r2)
 4045804:	00bfff44 	movi	r2,-3
 4045808:	1886703a 	and	r3,r3,r2
 404580c:	e0bffe17 	ldw	r2,-8(fp)
 4045810:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4045814:	e0bffe17 	ldw	r2,-8(fp)
 4045818:	10800017 	ldw	r2,0(r2)
 404581c:	11000104 	addi	r4,r2,4
 4045820:	e0bffe17 	ldw	r2,-8(fp)
 4045824:	10800817 	ldw	r2,32(r2)
 4045828:	1007883a 	mov	r3,r2
 404582c:	2005883a 	mov	r2,r4
 4045830:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4045834:	e0bffd17 	ldw	r2,-12(fp)
 4045838:	10800104 	addi	r2,r2,4
 404583c:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 4045840:	003f8406 	br	4045654 <altera_avalon_jtag_uart_irq+0x28>
}
 4045844:	e037883a 	mov	sp,fp
 4045848:	df000017 	ldw	fp,0(sp)
 404584c:	dec00104 	addi	sp,sp,4
 4045850:	f800283a 	ret

04045854 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 4045854:	defffc04 	addi	sp,sp,-16
 4045858:	df000315 	stw	fp,12(sp)
 404585c:	df000304 	addi	fp,sp,12
 4045860:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 4045864:	e0bfff17 	ldw	r2,-4(fp)
 4045868:	e0bffe15 	stw	r2,-8(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 404586c:	e0bffe17 	ldw	r2,-8(fp)
 4045870:	10800017 	ldw	r2,0(r2)
 4045874:	10800104 	addi	r2,r2,4
 4045878:	10800037 	ldwio	r2,0(r2)
 404587c:	e0bffd15 	stw	r2,-12(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 4045880:	e0bffd17 	ldw	r2,-12(fp)
 4045884:	1081000c 	andi	r2,r2,1024
 4045888:	1005003a 	cmpeq	r2,r2,zero
 404588c:	10000c1e 	bne	r2,zero,40458c0 <altera_avalon_jtag_uart_timeout+0x6c>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 4045890:	e0bffe17 	ldw	r2,-8(fp)
 4045894:	10800017 	ldw	r2,0(r2)
 4045898:	11000104 	addi	r4,r2,4
 404589c:	e0bffe17 	ldw	r2,-8(fp)
 40458a0:	10800817 	ldw	r2,32(r2)
 40458a4:	10810014 	ori	r2,r2,1024
 40458a8:	1007883a 	mov	r3,r2
 40458ac:	2005883a 	mov	r2,r4
 40458b0:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 40458b4:	e0bffe17 	ldw	r2,-8(fp)
 40458b8:	10000915 	stw	zero,36(r2)
 40458bc:	00000a06 	br	40458e8 <altera_avalon_jtag_uart_timeout+0x94>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 40458c0:	e0bffe17 	ldw	r2,-8(fp)
 40458c4:	10c00917 	ldw	r3,36(r2)
 40458c8:	00a00034 	movhi	r2,32768
 40458cc:	10bfff04 	addi	r2,r2,-4
 40458d0:	10c00536 	bltu	r2,r3,40458e8 <altera_avalon_jtag_uart_timeout+0x94>
    sp->host_inactive++;
 40458d4:	e0bffe17 	ldw	r2,-8(fp)
 40458d8:	10800917 	ldw	r2,36(r2)
 40458dc:	10c00044 	addi	r3,r2,1
 40458e0:	e0bffe17 	ldw	r2,-8(fp)
 40458e4:	10c00915 	stw	r3,36(r2)
 40458e8:	00810174 	movhi	r2,1029
 40458ec:	10ad6904 	addi	r2,r2,-19036
 40458f0:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 40458f4:	e037883a 	mov	sp,fp
 40458f8:	df000017 	ldw	fp,0(sp)
 40458fc:	dec00104 	addi	sp,sp,4
 4045900:	f800283a 	ret

04045904 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 4045904:	defffc04 	addi	sp,sp,-16
 4045908:	df000315 	stw	fp,12(sp)
 404590c:	df000304 	addi	fp,sp,12
 4045910:	e13ffd15 	stw	r4,-12(fp)
 4045914:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 4045918:	00000706 	br	4045938 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 404591c:	e0bffe17 	ldw	r2,-8(fp)
 4045920:	1090000c 	andi	r2,r2,16384
 4045924:	1005003a 	cmpeq	r2,r2,zero
 4045928:	1000031e 	bne	r2,zero,4045938 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 404592c:	00bffd44 	movi	r2,-11
 4045930:	e0bfff15 	stw	r2,-4(fp)
 4045934:	00000b06 	br	4045964 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 4045938:	e0bffd17 	ldw	r2,-12(fp)
 404593c:	10c00d17 	ldw	r3,52(r2)
 4045940:	e0bffd17 	ldw	r2,-12(fp)
 4045944:	10800c17 	ldw	r2,48(r2)
 4045948:	18800526 	beq	r3,r2,4045960 <altera_avalon_jtag_uart_close+0x5c>
 404594c:	e0bffd17 	ldw	r2,-12(fp)
 4045950:	10c00917 	ldw	r3,36(r2)
 4045954:	e0bffd17 	ldw	r2,-12(fp)
 4045958:	10800117 	ldw	r2,4(r2)
 404595c:	18bfef36 	bltu	r3,r2,404591c <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 4045960:	e03fff15 	stw	zero,-4(fp)
 4045964:	e0bfff17 	ldw	r2,-4(fp)
}
 4045968:	e037883a 	mov	sp,fp
 404596c:	df000017 	ldw	fp,0(sp)
 4045970:	dec00104 	addi	sp,sp,4
 4045974:	f800283a 	ret

04045978 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 4045978:	defff804 	addi	sp,sp,-32
 404597c:	df000715 	stw	fp,28(sp)
 4045980:	df000704 	addi	fp,sp,28
 4045984:	e13ffb15 	stw	r4,-20(fp)
 4045988:	e17ffc15 	stw	r5,-16(fp)
 404598c:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 4045990:	00bff9c4 	movi	r2,-25
 4045994:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 4045998:	e0bffc17 	ldw	r2,-16(fp)
 404599c:	e0bfff15 	stw	r2,-4(fp)
 40459a0:	e0ffff17 	ldw	r3,-4(fp)
 40459a4:	189a8060 	cmpeqi	r2,r3,27137
 40459a8:	1000041e 	bne	r2,zero,40459bc <altera_avalon_jtag_uart_ioctl+0x44>
 40459ac:	e0ffff17 	ldw	r3,-4(fp)
 40459b0:	189a80a0 	cmpeqi	r2,r3,27138
 40459b4:	10001b1e 	bne	r2,zero,4045a24 <altera_avalon_jtag_uart_ioctl+0xac>
 40459b8:	00002706 	br	4045a58 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 40459bc:	e0bffb17 	ldw	r2,-20(fp)
 40459c0:	10c00117 	ldw	r3,4(r2)
 40459c4:	00a00034 	movhi	r2,32768
 40459c8:	10bfffc4 	addi	r2,r2,-1
 40459cc:	18802226 	beq	r3,r2,4045a58 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 40459d0:	e0bffd17 	ldw	r2,-12(fp)
 40459d4:	10800017 	ldw	r2,0(r2)
 40459d8:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 40459dc:	e0bff917 	ldw	r2,-28(fp)
 40459e0:	10800090 	cmplti	r2,r2,2
 40459e4:	1000071e 	bne	r2,zero,4045a04 <altera_avalon_jtag_uart_ioctl+0x8c>
 40459e8:	e0fff917 	ldw	r3,-28(fp)
 40459ec:	00a00034 	movhi	r2,32768
 40459f0:	10bfffc4 	addi	r2,r2,-1
 40459f4:	18800326 	beq	r3,r2,4045a04 <altera_avalon_jtag_uart_ioctl+0x8c>
 40459f8:	e0bff917 	ldw	r2,-28(fp)
 40459fc:	e0bffe15 	stw	r2,-8(fp)
 4045a00:	00000306 	br	4045a10 <altera_avalon_jtag_uart_ioctl+0x98>
 4045a04:	00e00034 	movhi	r3,32768
 4045a08:	18ffff84 	addi	r3,r3,-2
 4045a0c:	e0fffe15 	stw	r3,-8(fp)
 4045a10:	e0bffb17 	ldw	r2,-20(fp)
 4045a14:	e0fffe17 	ldw	r3,-8(fp)
 4045a18:	10c00115 	stw	r3,4(r2)
      rc = 0;
 4045a1c:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 4045a20:	00000d06 	br	4045a58 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 4045a24:	e0bffb17 	ldw	r2,-20(fp)
 4045a28:	10c00117 	ldw	r3,4(r2)
 4045a2c:	00a00034 	movhi	r2,32768
 4045a30:	10bfffc4 	addi	r2,r2,-1
 4045a34:	18800826 	beq	r3,r2,4045a58 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 4045a38:	e13ffd17 	ldw	r4,-12(fp)
 4045a3c:	e0bffb17 	ldw	r2,-20(fp)
 4045a40:	10c00917 	ldw	r3,36(r2)
 4045a44:	e0bffb17 	ldw	r2,-20(fp)
 4045a48:	10800117 	ldw	r2,4(r2)
 4045a4c:	1885803a 	cmpltu	r2,r3,r2
 4045a50:	20800015 	stw	r2,0(r4)
      rc = 0;
 4045a54:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 4045a58:	e0bffa17 	ldw	r2,-24(fp)
}
 4045a5c:	e037883a 	mov	sp,fp
 4045a60:	df000017 	ldw	fp,0(sp)
 4045a64:	dec00104 	addi	sp,sp,4
 4045a68:	f800283a 	ret

04045a6c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 4045a6c:	defff204 	addi	sp,sp,-56
 4045a70:	dfc00d15 	stw	ra,52(sp)
 4045a74:	df000c15 	stw	fp,48(sp)
 4045a78:	df000c04 	addi	fp,sp,48
 4045a7c:	e13ffb15 	stw	r4,-20(fp)
 4045a80:	e17ffc15 	stw	r5,-16(fp)
 4045a84:	e1bffd15 	stw	r6,-12(fp)
 4045a88:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 4045a8c:	e0bffc17 	ldw	r2,-16(fp)
 4045a90:	e0bffa15 	stw	r2,-24(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 4045a94:	00004806 	br	4045bb8 <altera_avalon_jtag_uart_read+0x14c>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 4045a98:	e0bffb17 	ldw	r2,-20(fp)
 4045a9c:	10800a17 	ldw	r2,40(r2)
 4045aa0:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 4045aa4:	e0bffb17 	ldw	r2,-20(fp)
 4045aa8:	10800b17 	ldw	r2,44(r2)
 4045aac:	e0bff615 	stw	r2,-40(fp)

      if (in >= out)
 4045ab0:	e0fff717 	ldw	r3,-36(fp)
 4045ab4:	e0bff617 	ldw	r2,-40(fp)
 4045ab8:	18800536 	bltu	r3,r2,4045ad0 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 4045abc:	e0bff717 	ldw	r2,-36(fp)
 4045ac0:	e0fff617 	ldw	r3,-40(fp)
 4045ac4:	10c5c83a 	sub	r2,r2,r3
 4045ac8:	e0bff815 	stw	r2,-32(fp)
 4045acc:	00000406 	br	4045ae0 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 4045ad0:	00820004 	movi	r2,2048
 4045ad4:	e0fff617 	ldw	r3,-40(fp)
 4045ad8:	10c5c83a 	sub	r2,r2,r3
 4045adc:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
 4045ae0:	e0bff817 	ldw	r2,-32(fp)
 4045ae4:	1005003a 	cmpeq	r2,r2,zero
 4045ae8:	10001f1e 	bne	r2,zero,4045b68 <altera_avalon_jtag_uart_read+0xfc>
        break; /* No more data available */

      if (n > space)
 4045aec:	e0fffd17 	ldw	r3,-12(fp)
 4045af0:	e0bff817 	ldw	r2,-32(fp)
 4045af4:	1880022e 	bgeu	r3,r2,4045b00 <altera_avalon_jtag_uart_read+0x94>
        n = space;
 4045af8:	e0bffd17 	ldw	r2,-12(fp)
 4045afc:	e0bff815 	stw	r2,-32(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 4045b00:	e0bffb17 	ldw	r2,-20(fp)
 4045b04:	10c00e04 	addi	r3,r2,56
 4045b08:	e0bff617 	ldw	r2,-40(fp)
 4045b0c:	1887883a 	add	r3,r3,r2
 4045b10:	e0bffa17 	ldw	r2,-24(fp)
 4045b14:	1009883a 	mov	r4,r2
 4045b18:	180b883a 	mov	r5,r3
 4045b1c:	e1bff817 	ldw	r6,-32(fp)
 4045b20:	40410500 	call	4041050 <memcpy>
      ptr   += n;
 4045b24:	e0fff817 	ldw	r3,-32(fp)
 4045b28:	e0bffa17 	ldw	r2,-24(fp)
 4045b2c:	10c5883a 	add	r2,r2,r3
 4045b30:	e0bffa15 	stw	r2,-24(fp)
      space -= n;
 4045b34:	e0fffd17 	ldw	r3,-12(fp)
 4045b38:	e0bff817 	ldw	r2,-32(fp)
 4045b3c:	1885c83a 	sub	r2,r3,r2
 4045b40:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4045b44:	e0fff617 	ldw	r3,-40(fp)
 4045b48:	e0bff817 	ldw	r2,-32(fp)
 4045b4c:	1885883a 	add	r2,r3,r2
 4045b50:	10c1ffcc 	andi	r3,r2,2047
 4045b54:	e0bffb17 	ldw	r2,-20(fp)
 4045b58:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 4045b5c:	e0bffd17 	ldw	r2,-12(fp)
 4045b60:	10800048 	cmpgei	r2,r2,1
 4045b64:	103fcc1e 	bne	r2,zero,4045a98 <altera_avalon_jtag_uart_read+0x2c>

    /* If we read any data then return it */
    if (ptr != buffer)
 4045b68:	e0fffa17 	ldw	r3,-24(fp)
 4045b6c:	e0bffc17 	ldw	r2,-16(fp)
 4045b70:	1880141e 	bne	r3,r2,4045bc4 <altera_avalon_jtag_uart_read+0x158>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 4045b74:	e0bffe17 	ldw	r2,-8(fp)
 4045b78:	1090000c 	andi	r2,r2,16384
 4045b7c:	1004c03a 	cmpne	r2,r2,zero
 4045b80:	1000101e 	bne	r2,zero,4045bc4 <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 4045b84:	e0bffb17 	ldw	r2,-20(fp)
 4045b88:	10c00a17 	ldw	r3,40(r2)
 4045b8c:	e0bff717 	ldw	r2,-36(fp)
 4045b90:	1880051e 	bne	r3,r2,4045ba8 <altera_avalon_jtag_uart_read+0x13c>
 4045b94:	e0bffb17 	ldw	r2,-20(fp)
 4045b98:	10c00917 	ldw	r3,36(r2)
 4045b9c:	e0bffb17 	ldw	r2,-20(fp)
 4045ba0:	10800117 	ldw	r2,4(r2)
 4045ba4:	18bff736 	bltu	r3,r2,4045b84 <altera_avalon_jtag_uart_read+0x118>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 4045ba8:	e0bffb17 	ldw	r2,-20(fp)
 4045bac:	10c00a17 	ldw	r3,40(r2)
 4045bb0:	e0bff717 	ldw	r2,-36(fp)
 4045bb4:	18800326 	beq	r3,r2,4045bc4 <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 4045bb8:	e0bffd17 	ldw	r2,-12(fp)
 4045bbc:	10800048 	cmpgei	r2,r2,1
 4045bc0:	103fb51e 	bne	r2,zero,4045a98 <altera_avalon_jtag_uart_read+0x2c>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 4045bc4:	e0fffa17 	ldw	r3,-24(fp)
 4045bc8:	e0bffc17 	ldw	r2,-16(fp)
 4045bcc:	18801926 	beq	r3,r2,4045c34 <altera_avalon_jtag_uart_read+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4045bd0:	0005303a 	rdctl	r2,status
 4045bd4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4045bd8:	e0fff517 	ldw	r3,-44(fp)
 4045bdc:	00bfff84 	movi	r2,-2
 4045be0:	1884703a 	and	r2,r3,r2
 4045be4:	1001703a 	wrctl	status,r2
  
  return context;
 4045be8:	e0bff517 	ldw	r2,-44(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 4045bec:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4045bf0:	e0bffb17 	ldw	r2,-20(fp)
 4045bf4:	10800817 	ldw	r2,32(r2)
 4045bf8:	10c00054 	ori	r3,r2,1
 4045bfc:	e0bffb17 	ldw	r2,-20(fp)
 4045c00:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4045c04:	e0bffb17 	ldw	r2,-20(fp)
 4045c08:	10800017 	ldw	r2,0(r2)
 4045c0c:	11000104 	addi	r4,r2,4
 4045c10:	e0bffb17 	ldw	r2,-20(fp)
 4045c14:	10800817 	ldw	r2,32(r2)
 4045c18:	1007883a 	mov	r3,r2
 4045c1c:	2005883a 	mov	r2,r4
 4045c20:	10c00035 	stwio	r3,0(r2)
 4045c24:	e0bff917 	ldw	r2,-28(fp)
 4045c28:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4045c2c:	e0bff417 	ldw	r2,-48(fp)
 4045c30:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 4045c34:	e0fffa17 	ldw	r3,-24(fp)
 4045c38:	e0bffc17 	ldw	r2,-16(fp)
 4045c3c:	18800526 	beq	r3,r2,4045c54 <altera_avalon_jtag_uart_read+0x1e8>
    return ptr - buffer;
 4045c40:	e0fffa17 	ldw	r3,-24(fp)
 4045c44:	e0bffc17 	ldw	r2,-16(fp)
 4045c48:	1887c83a 	sub	r3,r3,r2
 4045c4c:	e0ffff15 	stw	r3,-4(fp)
 4045c50:	00000906 	br	4045c78 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 4045c54:	e0bffe17 	ldw	r2,-8(fp)
 4045c58:	1090000c 	andi	r2,r2,16384
 4045c5c:	1005003a 	cmpeq	r2,r2,zero
 4045c60:	1000031e 	bne	r2,zero,4045c70 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 4045c64:	00bffd44 	movi	r2,-11
 4045c68:	e0bfff15 	stw	r2,-4(fp)
 4045c6c:	00000206 	br	4045c78 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 4045c70:	00bffec4 	movi	r2,-5
 4045c74:	e0bfff15 	stw	r2,-4(fp)
 4045c78:	e0bfff17 	ldw	r2,-4(fp)
}
 4045c7c:	e037883a 	mov	sp,fp
 4045c80:	dfc00117 	ldw	ra,4(sp)
 4045c84:	df000017 	ldw	fp,0(sp)
 4045c88:	dec00204 	addi	sp,sp,8
 4045c8c:	f800283a 	ret

04045c90 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 4045c90:	defff204 	addi	sp,sp,-56
 4045c94:	dfc00d15 	stw	ra,52(sp)
 4045c98:	df000c15 	stw	fp,48(sp)
 4045c9c:	df000c04 	addi	fp,sp,48
 4045ca0:	e13ffb15 	stw	r4,-20(fp)
 4045ca4:	e17ffc15 	stw	r5,-16(fp)
 4045ca8:	e1bffd15 	stw	r6,-12(fp)
 4045cac:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 4045cb0:	e03ff915 	stw	zero,-28(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 4045cb4:	e0bffc17 	ldw	r2,-16(fp)
 4045cb8:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 4045cbc:	00003a06 	br	4045da8 <altera_avalon_jtag_uart_write+0x118>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 4045cc0:	e0bffb17 	ldw	r2,-20(fp)
 4045cc4:	10800c17 	ldw	r2,48(r2)
 4045cc8:	e0bffa15 	stw	r2,-24(fp)
      out = sp->tx_out;
 4045ccc:	e0bffb17 	ldw	r2,-20(fp)
 4045cd0:	10800d17 	ldw	r2,52(r2)
 4045cd4:	e0bff915 	stw	r2,-28(fp)

      if (in < out)
 4045cd8:	e0fffa17 	ldw	r3,-24(fp)
 4045cdc:	e0bff917 	ldw	r2,-28(fp)
 4045ce0:	1880062e 	bgeu	r3,r2,4045cfc <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 4045ce4:	e0fff917 	ldw	r3,-28(fp)
 4045ce8:	e0bffa17 	ldw	r2,-24(fp)
 4045cec:	1885c83a 	sub	r2,r3,r2
 4045cf0:	10bfffc4 	addi	r2,r2,-1
 4045cf4:	e0bff815 	stw	r2,-32(fp)
 4045cf8:	00000c06 	br	4045d2c <altera_avalon_jtag_uart_write+0x9c>
      else if (out > 0)
 4045cfc:	e0bff917 	ldw	r2,-28(fp)
 4045d00:	1005003a 	cmpeq	r2,r2,zero
 4045d04:	1000051e 	bne	r2,zero,4045d1c <altera_avalon_jtag_uart_write+0x8c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 4045d08:	00820004 	movi	r2,2048
 4045d0c:	e0fffa17 	ldw	r3,-24(fp)
 4045d10:	10c5c83a 	sub	r2,r2,r3
 4045d14:	e0bff815 	stw	r2,-32(fp)
 4045d18:	00000406 	br	4045d2c <altera_avalon_jtag_uart_write+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 4045d1c:	0081ffc4 	movi	r2,2047
 4045d20:	e0fffa17 	ldw	r3,-24(fp)
 4045d24:	10c5c83a 	sub	r2,r2,r3
 4045d28:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
 4045d2c:	e0bff817 	ldw	r2,-32(fp)
 4045d30:	1005003a 	cmpeq	r2,r2,zero
 4045d34:	10001f1e 	bne	r2,zero,4045db4 <altera_avalon_jtag_uart_write+0x124>
        break;

      if (n > count)
 4045d38:	e0fffd17 	ldw	r3,-12(fp)
 4045d3c:	e0bff817 	ldw	r2,-32(fp)
 4045d40:	1880022e 	bgeu	r3,r2,4045d4c <altera_avalon_jtag_uart_write+0xbc>
        n = count;
 4045d44:	e0bffd17 	ldw	r2,-12(fp)
 4045d48:	e0bff815 	stw	r2,-32(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 4045d4c:	e0bffb17 	ldw	r2,-20(fp)
 4045d50:	10c20e04 	addi	r3,r2,2104
 4045d54:	e0bffa17 	ldw	r2,-24(fp)
 4045d58:	1885883a 	add	r2,r3,r2
 4045d5c:	e0fffc17 	ldw	r3,-16(fp)
 4045d60:	1009883a 	mov	r4,r2
 4045d64:	180b883a 	mov	r5,r3
 4045d68:	e1bff817 	ldw	r6,-32(fp)
 4045d6c:	40410500 	call	4041050 <memcpy>
      ptr   += n;
 4045d70:	e0fff817 	ldw	r3,-32(fp)
 4045d74:	e0bffc17 	ldw	r2,-16(fp)
 4045d78:	10c5883a 	add	r2,r2,r3
 4045d7c:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 4045d80:	e0fffd17 	ldw	r3,-12(fp)
 4045d84:	e0bff817 	ldw	r2,-32(fp)
 4045d88:	1885c83a 	sub	r2,r3,r2
 4045d8c:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4045d90:	e0fffa17 	ldw	r3,-24(fp)
 4045d94:	e0bff817 	ldw	r2,-32(fp)
 4045d98:	1885883a 	add	r2,r3,r2
 4045d9c:	10c1ffcc 	andi	r3,r2,2047
 4045da0:	e0bffb17 	ldw	r2,-20(fp)
 4045da4:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 4045da8:	e0bffd17 	ldw	r2,-12(fp)
 4045dac:	10800048 	cmpgei	r2,r2,1
 4045db0:	103fc31e 	bne	r2,zero,4045cc0 <altera_avalon_jtag_uart_write+0x30>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4045db4:	0005303a 	rdctl	r2,status
 4045db8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4045dbc:	e0fff517 	ldw	r3,-44(fp)
 4045dc0:	00bfff84 	movi	r2,-2
 4045dc4:	1884703a 	and	r2,r3,r2
 4045dc8:	1001703a 	wrctl	status,r2
  
  return context;
 4045dcc:	e0bff517 	ldw	r2,-44(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 4045dd0:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 4045dd4:	e0bffb17 	ldw	r2,-20(fp)
 4045dd8:	10800817 	ldw	r2,32(r2)
 4045ddc:	10c00094 	ori	r3,r2,2
 4045de0:	e0bffb17 	ldw	r2,-20(fp)
 4045de4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4045de8:	e0bffb17 	ldw	r2,-20(fp)
 4045dec:	10800017 	ldw	r2,0(r2)
 4045df0:	11000104 	addi	r4,r2,4
 4045df4:	e0bffb17 	ldw	r2,-20(fp)
 4045df8:	10800817 	ldw	r2,32(r2)
 4045dfc:	1007883a 	mov	r3,r2
 4045e00:	2005883a 	mov	r2,r4
 4045e04:	10c00035 	stwio	r3,0(r2)
 4045e08:	e0bff717 	ldw	r2,-36(fp)
 4045e0c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4045e10:	e0bff417 	ldw	r2,-48(fp)
 4045e14:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 4045e18:	e0bffd17 	ldw	r2,-12(fp)
 4045e1c:	10800050 	cmplti	r2,r2,1
 4045e20:	1000111e 	bne	r2,zero,4045e68 <altera_avalon_jtag_uart_write+0x1d8>
    {
      if (flags & O_NONBLOCK)
 4045e24:	e0bffe17 	ldw	r2,-8(fp)
 4045e28:	1090000c 	andi	r2,r2,16384
 4045e2c:	1004c03a 	cmpne	r2,r2,zero
 4045e30:	1000101e 	bne	r2,zero,4045e74 <altera_avalon_jtag_uart_write+0x1e4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 4045e34:	e0bffb17 	ldw	r2,-20(fp)
 4045e38:	10c00d17 	ldw	r3,52(r2)
 4045e3c:	e0bff917 	ldw	r2,-28(fp)
 4045e40:	1880051e 	bne	r3,r2,4045e58 <altera_avalon_jtag_uart_write+0x1c8>
 4045e44:	e0bffb17 	ldw	r2,-20(fp)
 4045e48:	10c00917 	ldw	r3,36(r2)
 4045e4c:	e0bffb17 	ldw	r2,-20(fp)
 4045e50:	10800117 	ldw	r2,4(r2)
 4045e54:	18bff736 	bltu	r3,r2,4045e34 <altera_avalon_jtag_uart_write+0x1a4>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 4045e58:	e0bffb17 	ldw	r2,-20(fp)
 4045e5c:	10c00d17 	ldw	r3,52(r2)
 4045e60:	e0bff917 	ldw	r2,-28(fp)
 4045e64:	18800326 	beq	r3,r2,4045e74 <altera_avalon_jtag_uart_write+0x1e4>
        break;
    }
  }
  while (count > 0);
 4045e68:	e0bffd17 	ldw	r2,-12(fp)
 4045e6c:	10800048 	cmpgei	r2,r2,1
 4045e70:	103fcd1e 	bne	r2,zero,4045da8 <altera_avalon_jtag_uart_write+0x118>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 4045e74:	e0fffc17 	ldw	r3,-16(fp)
 4045e78:	e0bff617 	ldw	r2,-40(fp)
 4045e7c:	18800526 	beq	r3,r2,4045e94 <altera_avalon_jtag_uart_write+0x204>
    return ptr - start;
 4045e80:	e0fffc17 	ldw	r3,-16(fp)
 4045e84:	e0bff617 	ldw	r2,-40(fp)
 4045e88:	1887c83a 	sub	r3,r3,r2
 4045e8c:	e0ffff15 	stw	r3,-4(fp)
 4045e90:	00000906 	br	4045eb8 <altera_avalon_jtag_uart_write+0x228>
  else if (flags & O_NONBLOCK)
 4045e94:	e0bffe17 	ldw	r2,-8(fp)
 4045e98:	1090000c 	andi	r2,r2,16384
 4045e9c:	1005003a 	cmpeq	r2,r2,zero
 4045ea0:	1000031e 	bne	r2,zero,4045eb0 <altera_avalon_jtag_uart_write+0x220>
    return -EWOULDBLOCK;
 4045ea4:	00bffd44 	movi	r2,-11
 4045ea8:	e0bfff15 	stw	r2,-4(fp)
 4045eac:	00000206 	br	4045eb8 <altera_avalon_jtag_uart_write+0x228>
  else
    return -EIO; /* Host not connected */
 4045eb0:	00bffec4 	movi	r2,-5
 4045eb4:	e0bfff15 	stw	r2,-4(fp)
 4045eb8:	e0bfff17 	ldw	r2,-4(fp)
}
 4045ebc:	e037883a 	mov	sp,fp
 4045ec0:	dfc00117 	ldw	ra,4(sp)
 4045ec4:	df000017 	ldw	fp,0(sp)
 4045ec8:	dec00204 	addi	sp,sp,8
 4045ecc:	f800283a 	ret

04045ed0 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 4045ed0:	defff404 	addi	sp,sp,-48
 4045ed4:	df000b15 	stw	fp,44(sp)
 4045ed8:	df000b04 	addi	fp,sp,44
 4045edc:	e13ffb15 	stw	r4,-20(fp)
 4045ee0:	e17ffc15 	stw	r5,-16(fp)
 4045ee4:	e1bffd15 	stw	r6,-12(fp)
 4045ee8:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 4045eec:	e03ff915 	stw	zero,-28(fp)
 4045ef0:	00810174 	movhi	r2,1029
 4045ef4:	10ad6904 	addi	r2,r2,-19036
 4045ef8:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 4045efc:	1005003a 	cmpeq	r2,r2,zero
 4045f00:	1000411e 	bne	r2,zero,4046008 <alt_alarm_start+0x138>
  {
    if (alarm)
 4045f04:	e0bffb17 	ldw	r2,-20(fp)
 4045f08:	1005003a 	cmpeq	r2,r2,zero
 4045f0c:	10003b1e 	bne	r2,zero,4045ffc <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 4045f10:	e0fffb17 	ldw	r3,-20(fp)
 4045f14:	e0bffd17 	ldw	r2,-12(fp)
 4045f18:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 4045f1c:	e0fffb17 	ldw	r3,-20(fp)
 4045f20:	e0bffe17 	ldw	r2,-8(fp)
 4045f24:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4045f28:	0005303a 	rdctl	r2,status
 4045f2c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4045f30:	e0fff817 	ldw	r3,-32(fp)
 4045f34:	00bfff84 	movi	r2,-2
 4045f38:	1884703a 	and	r2,r3,r2
 4045f3c:	1001703a 	wrctl	status,r2
  
  return context;
 4045f40:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 4045f44:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 4045f48:	00810174 	movhi	r2,1029
 4045f4c:	10ad6a04 	addi	r2,r2,-19032
 4045f50:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 4045f54:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 4045f58:	e0fffc17 	ldw	r3,-16(fp)
 4045f5c:	e0bff917 	ldw	r2,-28(fp)
 4045f60:	1885883a 	add	r2,r3,r2
 4045f64:	10c00044 	addi	r3,r2,1
 4045f68:	e0bffb17 	ldw	r2,-20(fp)
 4045f6c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 4045f70:	e0bffb17 	ldw	r2,-20(fp)
 4045f74:	10c00217 	ldw	r3,8(r2)
 4045f78:	e0bff917 	ldw	r2,-28(fp)
 4045f7c:	1880042e 	bgeu	r3,r2,4045f90 <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 4045f80:	e0fffb17 	ldw	r3,-20(fp)
 4045f84:	00800044 	movi	r2,1
 4045f88:	18800405 	stb	r2,16(r3)
 4045f8c:	00000206 	br	4045f98 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 4045f90:	e0bffb17 	ldw	r2,-20(fp)
 4045f94:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 4045f98:	e0fffb17 	ldw	r3,-20(fp)
 4045f9c:	00810174 	movhi	r2,1029
 4045fa0:	10a69504 	addi	r2,r2,-26028
 4045fa4:	e0bff615 	stw	r2,-40(fp)
 4045fa8:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 4045fac:	e0fff717 	ldw	r3,-36(fp)
 4045fb0:	e0bff617 	ldw	r2,-40(fp)
 4045fb4:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 4045fb8:	e0bff617 	ldw	r2,-40(fp)
 4045fbc:	10c00017 	ldw	r3,0(r2)
 4045fc0:	e0bff717 	ldw	r2,-36(fp)
 4045fc4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 4045fc8:	e0bff617 	ldw	r2,-40(fp)
 4045fcc:	10c00017 	ldw	r3,0(r2)
 4045fd0:	e0bff717 	ldw	r2,-36(fp)
 4045fd4:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 4045fd8:	e0fff617 	ldw	r3,-40(fp)
 4045fdc:	e0bff717 	ldw	r2,-36(fp)
 4045fe0:	18800015 	stw	r2,0(r3)
 4045fe4:	e0bffa17 	ldw	r2,-24(fp)
 4045fe8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4045fec:	e0bff517 	ldw	r2,-44(fp)
 4045ff0:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 4045ff4:	e03fff15 	stw	zero,-4(fp)
 4045ff8:	00000506 	br	4046010 <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 4045ffc:	00bffa84 	movi	r2,-22
 4046000:	e0bfff15 	stw	r2,-4(fp)
 4046004:	00000206 	br	4046010 <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 4046008:	00bfde84 	movi	r2,-134
 404600c:	e0bfff15 	stw	r2,-4(fp)
 4046010:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 4046014:	e037883a 	mov	sp,fp
 4046018:	df000017 	ldw	fp,0(sp)
 404601c:	dec00104 	addi	sp,sp,4
 4046020:	f800283a 	ret

04046024 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 4046024:	defffb04 	addi	sp,sp,-20
 4046028:	df000415 	stw	fp,16(sp)
 404602c:	df000404 	addi	fp,sp,16
 4046030:	e13ffe15 	stw	r4,-8(fp)
 4046034:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 4046038:	e0fffe17 	ldw	r3,-8(fp)
 404603c:	e0bfff17 	ldw	r2,-4(fp)
 4046040:	1885883a 	add	r2,r3,r2
 4046044:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 4046048:	e0bffe17 	ldw	r2,-8(fp)
 404604c:	e0bffd15 	stw	r2,-12(fp)
 4046050:	00000506 	br	4046068 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 4046054:	e0bffd17 	ldw	r2,-12(fp)
 4046058:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 404605c:	e0bffd17 	ldw	r2,-12(fp)
 4046060:	10800804 	addi	r2,r2,32
 4046064:	e0bffd15 	stw	r2,-12(fp)
 4046068:	e0fffd17 	ldw	r3,-12(fp)
 404606c:	e0bffc17 	ldw	r2,-16(fp)
 4046070:	18bff836 	bltu	r3,r2,4046054 <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 4046074:	e0bffe17 	ldw	r2,-8(fp)
 4046078:	108007cc 	andi	r2,r2,31
 404607c:	1005003a 	cmpeq	r2,r2,zero
 4046080:	1000021e 	bne	r2,zero,404608c <alt_dcache_flush+0x68>
  {
    ALT_FLUSH_DATA(i);
 4046084:	e0bffd17 	ldw	r2,-12(fp)
 4046088:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 404608c:	e037883a 	mov	sp,fp
 4046090:	df000017 	ldw	fp,0(sp)
 4046094:	dec00104 	addi	sp,sp,4
 4046098:	f800283a 	ret

0404609c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 404609c:	defffe04 	addi	sp,sp,-8
 40460a0:	df000115 	stw	fp,4(sp)
 40460a4:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 40460a8:	e03fff15 	stw	zero,-4(fp)
 40460ac:	00000506 	br	40460c4 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 40460b0:	e0bfff17 	ldw	r2,-4(fp)
 40460b4:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 40460b8:	e0bfff17 	ldw	r2,-4(fp)
 40460bc:	10800804 	addi	r2,r2,32
 40460c0:	e0bfff15 	stw	r2,-4(fp)
 40460c4:	e0bfff17 	ldw	r2,-4(fp)
 40460c8:	10820030 	cmpltui	r2,r2,2048
 40460cc:	103ff81e 	bne	r2,zero,40460b0 <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 40460d0:	e037883a 	mov	sp,fp
 40460d4:	df000017 	ldw	fp,0(sp)
 40460d8:	dec00104 	addi	sp,sp,4
 40460dc:	f800283a 	ret

040460e0 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 40460e0:	defff904 	addi	sp,sp,-28
 40460e4:	dfc00615 	stw	ra,24(sp)
 40460e8:	df000515 	stw	fp,20(sp)
 40460ec:	df000504 	addi	fp,sp,20
 40460f0:	e13ffd15 	stw	r4,-12(fp)
 40460f4:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 40460f8:	e0bffd17 	ldw	r2,-12(fp)
 40460fc:	1005003a 	cmpeq	r2,r2,zero
 4046100:	1000041e 	bne	r2,zero,4046114 <alt_dev_llist_insert+0x34>
 4046104:	e0bffd17 	ldw	r2,-12(fp)
 4046108:	10800217 	ldw	r2,8(r2)
 404610c:	1004c03a 	cmpne	r2,r2,zero
 4046110:	1000071e 	bne	r2,zero,4046130 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 4046114:	40461940 	call	4046194 <alt_get_errno>
 4046118:	1007883a 	mov	r3,r2
 404611c:	00800584 	movi	r2,22
 4046120:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 4046124:	00bffa84 	movi	r2,-22
 4046128:	e0bfff15 	stw	r2,-4(fp)
 404612c:	00001306 	br	404617c <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 4046130:	e0fffd17 	ldw	r3,-12(fp)
 4046134:	e0bffe17 	ldw	r2,-8(fp)
 4046138:	e0bffb15 	stw	r2,-20(fp)
 404613c:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 4046140:	e0fffc17 	ldw	r3,-16(fp)
 4046144:	e0bffb17 	ldw	r2,-20(fp)
 4046148:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 404614c:	e0bffb17 	ldw	r2,-20(fp)
 4046150:	10c00017 	ldw	r3,0(r2)
 4046154:	e0bffc17 	ldw	r2,-16(fp)
 4046158:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 404615c:	e0bffb17 	ldw	r2,-20(fp)
 4046160:	10c00017 	ldw	r3,0(r2)
 4046164:	e0bffc17 	ldw	r2,-16(fp)
 4046168:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 404616c:	e0fffb17 	ldw	r3,-20(fp)
 4046170:	e0bffc17 	ldw	r2,-16(fp)
 4046174:	18800015 	stw	r2,0(r3)

  return 0;  
 4046178:	e03fff15 	stw	zero,-4(fp)
 404617c:	e0bfff17 	ldw	r2,-4(fp)
}
 4046180:	e037883a 	mov	sp,fp
 4046184:	dfc00117 	ldw	ra,4(sp)
 4046188:	df000017 	ldw	fp,0(sp)
 404618c:	dec00204 	addi	sp,sp,8
 4046190:	f800283a 	ret

04046194 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4046194:	defffd04 	addi	sp,sp,-12
 4046198:	dfc00215 	stw	ra,8(sp)
 404619c:	df000115 	stw	fp,4(sp)
 40461a0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 40461a4:	00810174 	movhi	r2,1029
 40461a8:	10a69004 	addi	r2,r2,-26048
 40461ac:	10800017 	ldw	r2,0(r2)
 40461b0:	1005003a 	cmpeq	r2,r2,zero
 40461b4:	1000061e 	bne	r2,zero,40461d0 <alt_get_errno+0x3c>
 40461b8:	00810174 	movhi	r2,1029
 40461bc:	10a69004 	addi	r2,r2,-26048
 40461c0:	10800017 	ldw	r2,0(r2)
 40461c4:	103ee83a 	callr	r2
 40461c8:	e0bfff15 	stw	r2,-4(fp)
 40461cc:	00000306 	br	40461dc <alt_get_errno+0x48>
 40461d0:	00810174 	movhi	r2,1029
 40461d4:	10ad6404 	addi	r2,r2,-19056
 40461d8:	e0bfff15 	stw	r2,-4(fp)
 40461dc:	e0bfff17 	ldw	r2,-4(fp)
}
 40461e0:	e037883a 	mov	sp,fp
 40461e4:	dfc00117 	ldw	ra,4(sp)
 40461e8:	df000017 	ldw	fp,0(sp)
 40461ec:	dec00204 	addi	sp,sp,8
 40461f0:	f800283a 	ret

040461f4 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 40461f4:	defffd04 	addi	sp,sp,-12
 40461f8:	dfc00215 	stw	ra,8(sp)
 40461fc:	df000115 	stw	fp,4(sp)
 4046200:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 4046204:	00bfff04 	movi	r2,-4
 4046208:	00c10134 	movhi	r3,1028
 404620c:	18dfb704 	addi	r3,r3,32476
 4046210:	1885883a 	add	r2,r3,r2
 4046214:	e0bfff15 	stw	r2,-4(fp)
 4046218:	00000606 	br	4046234 <_do_ctors+0x40>
        (*ctor) (); 
 404621c:	e0bfff17 	ldw	r2,-4(fp)
 4046220:	10800017 	ldw	r2,0(r2)
 4046224:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 4046228:	e0bfff17 	ldw	r2,-4(fp)
 404622c:	10bfff04 	addi	r2,r2,-4
 4046230:	e0bfff15 	stw	r2,-4(fp)
 4046234:	e0ffff17 	ldw	r3,-4(fp)
 4046238:	00810134 	movhi	r2,1028
 404623c:	109fb604 	addi	r2,r2,32472
 4046240:	18bff62e 	bgeu	r3,r2,404621c <_do_ctors+0x28>
        (*ctor) (); 
}
 4046244:	e037883a 	mov	sp,fp
 4046248:	dfc00117 	ldw	ra,4(sp)
 404624c:	df000017 	ldw	fp,0(sp)
 4046250:	dec00204 	addi	sp,sp,8
 4046254:	f800283a 	ret

04046258 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 4046258:	defffd04 	addi	sp,sp,-12
 404625c:	dfc00215 	stw	ra,8(sp)
 4046260:	df000115 	stw	fp,4(sp)
 4046264:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 4046268:	00bfff04 	movi	r2,-4
 404626c:	00c10134 	movhi	r3,1028
 4046270:	18dfb704 	addi	r3,r3,32476
 4046274:	1885883a 	add	r2,r3,r2
 4046278:	e0bfff15 	stw	r2,-4(fp)
 404627c:	00000606 	br	4046298 <_do_dtors+0x40>
        (*dtor) (); 
 4046280:	e0bfff17 	ldw	r2,-4(fp)
 4046284:	10800017 	ldw	r2,0(r2)
 4046288:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 404628c:	e0bfff17 	ldw	r2,-4(fp)
 4046290:	10bfff04 	addi	r2,r2,-4
 4046294:	e0bfff15 	stw	r2,-4(fp)
 4046298:	e0ffff17 	ldw	r3,-4(fp)
 404629c:	00810134 	movhi	r2,1028
 40462a0:	109fb704 	addi	r2,r2,32476
 40462a4:	18bff62e 	bgeu	r3,r2,4046280 <_do_dtors+0x28>
        (*dtor) (); 
}
 40462a8:	e037883a 	mov	sp,fp
 40462ac:	dfc00117 	ldw	ra,4(sp)
 40462b0:	df000017 	ldw	fp,0(sp)
 40462b4:	dec00204 	addi	sp,sp,8
 40462b8:	f800283a 	ret

040462bc <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 40462bc:	defffb04 	addi	sp,sp,-20
 40462c0:	dfc00415 	stw	ra,16(sp)
 40462c4:	df000315 	stw	fp,12(sp)
 40462c8:	df000304 	addi	fp,sp,12
 40462cc:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 40462d0:	e13ffe17 	ldw	r4,-8(fp)
 40462d4:	d1600b04 	addi	r5,gp,-32724
 40462d8:	404750c0 	call	404750c <alt_find_dev>
 40462dc:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
 40462e0:	e0bffd17 	ldw	r2,-12(fp)
 40462e4:	1005003a 	cmpeq	r2,r2,zero
 40462e8:	10000b1e 	bne	r2,zero,4046318 <alt_flash_open_dev+0x5c>
 40462ec:	e0bffd17 	ldw	r2,-12(fp)
 40462f0:	10800317 	ldw	r2,12(r2)
 40462f4:	1005003a 	cmpeq	r2,r2,zero
 40462f8:	1000071e 	bne	r2,zero,4046318 <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
 40462fc:	e0bffd17 	ldw	r2,-12(fp)
 4046300:	10800317 	ldw	r2,12(r2)
 4046304:	e13ffd17 	ldw	r4,-12(fp)
 4046308:	e17ffe17 	ldw	r5,-8(fp)
 404630c:	103ee83a 	callr	r2
 4046310:	e0bfff15 	stw	r2,-4(fp)
 4046314:	00000206 	br	4046320 <alt_flash_open_dev+0x64>
  }

  return dev;
 4046318:	e0bffd17 	ldw	r2,-12(fp)
 404631c:	e0bfff15 	stw	r2,-4(fp)
 4046320:	e0bfff17 	ldw	r2,-4(fp)
}
 4046324:	e037883a 	mov	sp,fp
 4046328:	dfc00117 	ldw	ra,4(sp)
 404632c:	df000017 	ldw	fp,0(sp)
 4046330:	dec00204 	addi	sp,sp,8
 4046334:	f800283a 	ret

04046338 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 4046338:	defffd04 	addi	sp,sp,-12
 404633c:	dfc00215 	stw	ra,8(sp)
 4046340:	df000115 	stw	fp,4(sp)
 4046344:	df000104 	addi	fp,sp,4
 4046348:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 404634c:	e0bfff17 	ldw	r2,-4(fp)
 4046350:	1005003a 	cmpeq	r2,r2,zero
 4046354:	1000081e 	bne	r2,zero,4046378 <alt_flash_close_dev+0x40>
 4046358:	e0bfff17 	ldw	r2,-4(fp)
 404635c:	10800417 	ldw	r2,16(r2)
 4046360:	1005003a 	cmpeq	r2,r2,zero
 4046364:	1000041e 	bne	r2,zero,4046378 <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
 4046368:	e0bfff17 	ldw	r2,-4(fp)
 404636c:	10800417 	ldw	r2,16(r2)
 4046370:	e13fff17 	ldw	r4,-4(fp)
 4046374:	103ee83a 	callr	r2
  }
  return;
}
 4046378:	e037883a 	mov	sp,fp
 404637c:	dfc00117 	ldw	ra,4(sp)
 4046380:	df000017 	ldw	fp,0(sp)
 4046384:	dec00204 	addi	sp,sp,8
 4046388:	f800283a 	ret

0404638c <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 404638c:	defffe04 	addi	sp,sp,-8
 4046390:	dfc00115 	stw	ra,4(sp)
 4046394:	df000015 	stw	fp,0(sp)
 4046398:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 404639c:	0009883a 	mov	r4,zero
 40463a0:	01440004 	movi	r5,4096
 40463a4:	40477780 	call	4047778 <alt_icache_flush>
#endif
}
 40463a8:	e037883a 	mov	sp,fp
 40463ac:	dfc00117 	ldw	ra,4(sp)
 40463b0:	df000017 	ldw	fp,0(sp)
 40463b4:	dec00204 	addi	sp,sp,8
 40463b8:	f800283a 	ret

040463bc <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 40463bc:	defff904 	addi	sp,sp,-28
 40463c0:	dfc00615 	stw	ra,24(sp)
 40463c4:	df000515 	stw	fp,20(sp)
 40463c8:	df000504 	addi	fp,sp,20
 40463cc:	e13ffc15 	stw	r4,-16(fp)
 40463d0:	e17ffd15 	stw	r5,-12(fp)
 40463d4:	e1bffe15 	stw	r6,-8(fp)
 40463d8:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 40463dc:	e0800217 	ldw	r2,8(fp)
 40463e0:	d8800015 	stw	r2,0(sp)
 40463e4:	e13ffc17 	ldw	r4,-16(fp)
 40463e8:	e17ffd17 	ldw	r5,-12(fp)
 40463ec:	e1bffe17 	ldw	r6,-8(fp)
 40463f0:	e1ffff17 	ldw	r7,-4(fp)
 40463f4:	40465900 	call	4046590 <alt_iic_isr_register>
}  
 40463f8:	e037883a 	mov	sp,fp
 40463fc:	dfc00117 	ldw	ra,4(sp)
 4046400:	df000017 	ldw	fp,0(sp)
 4046404:	dec00204 	addi	sp,sp,8
 4046408:	f800283a 	ret

0404640c <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 404640c:	defff904 	addi	sp,sp,-28
 4046410:	df000615 	stw	fp,24(sp)
 4046414:	df000604 	addi	fp,sp,24
 4046418:	e13ffe15 	stw	r4,-8(fp)
 404641c:	e17fff15 	stw	r5,-4(fp)
 4046420:	e0bfff17 	ldw	r2,-4(fp)
 4046424:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4046428:	0005303a 	rdctl	r2,status
 404642c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4046430:	e0fffb17 	ldw	r3,-20(fp)
 4046434:	00bfff84 	movi	r2,-2
 4046438:	1884703a 	and	r2,r3,r2
 404643c:	1001703a 	wrctl	status,r2
  
  return context;
 4046440:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 4046444:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 4046448:	e0fffc17 	ldw	r3,-16(fp)
 404644c:	00800044 	movi	r2,1
 4046450:	10c4983a 	sll	r2,r2,r3
 4046454:	1007883a 	mov	r3,r2
 4046458:	00810174 	movhi	r2,1029
 404645c:	10ad6804 	addi	r2,r2,-19040
 4046460:	10800017 	ldw	r2,0(r2)
 4046464:	1886b03a 	or	r3,r3,r2
 4046468:	00810174 	movhi	r2,1029
 404646c:	10ad6804 	addi	r2,r2,-19040
 4046470:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 4046474:	00810174 	movhi	r2,1029
 4046478:	10ad6804 	addi	r2,r2,-19040
 404647c:	10800017 	ldw	r2,0(r2)
 4046480:	100170fa 	wrctl	ienable,r2
 4046484:	e0bffd17 	ldw	r2,-12(fp)
 4046488:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 404648c:	e0bffa17 	ldw	r2,-24(fp)
 4046490:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 4046494:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 4046498:	e037883a 	mov	sp,fp
 404649c:	df000017 	ldw	fp,0(sp)
 40464a0:	dec00104 	addi	sp,sp,4
 40464a4:	f800283a 	ret

040464a8 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 40464a8:	defff904 	addi	sp,sp,-28
 40464ac:	df000615 	stw	fp,24(sp)
 40464b0:	df000604 	addi	fp,sp,24
 40464b4:	e13ffe15 	stw	r4,-8(fp)
 40464b8:	e17fff15 	stw	r5,-4(fp)
 40464bc:	e0bfff17 	ldw	r2,-4(fp)
 40464c0:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 40464c4:	0005303a 	rdctl	r2,status
 40464c8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40464cc:	e0fffb17 	ldw	r3,-20(fp)
 40464d0:	00bfff84 	movi	r2,-2
 40464d4:	1884703a 	and	r2,r3,r2
 40464d8:	1001703a 	wrctl	status,r2
  
  return context;
 40464dc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 40464e0:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
 40464e4:	e0fffc17 	ldw	r3,-16(fp)
 40464e8:	00800044 	movi	r2,1
 40464ec:	10c4983a 	sll	r2,r2,r3
 40464f0:	0084303a 	nor	r2,zero,r2
 40464f4:	1007883a 	mov	r3,r2
 40464f8:	00810174 	movhi	r2,1029
 40464fc:	10ad6804 	addi	r2,r2,-19040
 4046500:	10800017 	ldw	r2,0(r2)
 4046504:	1886703a 	and	r3,r3,r2
 4046508:	00810174 	movhi	r2,1029
 404650c:	10ad6804 	addi	r2,r2,-19040
 4046510:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 4046514:	00810174 	movhi	r2,1029
 4046518:	10ad6804 	addi	r2,r2,-19040
 404651c:	10800017 	ldw	r2,0(r2)
 4046520:	100170fa 	wrctl	ienable,r2
 4046524:	e0bffd17 	ldw	r2,-12(fp)
 4046528:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 404652c:	e0bffa17 	ldw	r2,-24(fp)
 4046530:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 4046534:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 4046538:	e037883a 	mov	sp,fp
 404653c:	df000017 	ldw	fp,0(sp)
 4046540:	dec00104 	addi	sp,sp,4
 4046544:	f800283a 	ret

04046548 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 4046548:	defffc04 	addi	sp,sp,-16
 404654c:	df000315 	stw	fp,12(sp)
 4046550:	df000304 	addi	fp,sp,12
 4046554:	e13ffe15 	stw	r4,-8(fp)
 4046558:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 404655c:	000530fa 	rdctl	r2,ienable
 4046560:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 4046564:	e0ffff17 	ldw	r3,-4(fp)
 4046568:	00800044 	movi	r2,1
 404656c:	10c4983a 	sll	r2,r2,r3
 4046570:	1007883a 	mov	r3,r2
 4046574:	e0bffd17 	ldw	r2,-12(fp)
 4046578:	1884703a 	and	r2,r3,r2
 404657c:	1004c03a 	cmpne	r2,r2,zero
}
 4046580:	e037883a 	mov	sp,fp
 4046584:	df000017 	ldw	fp,0(sp)
 4046588:	dec00104 	addi	sp,sp,4
 404658c:	f800283a 	ret

04046590 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 4046590:	defff404 	addi	sp,sp,-48
 4046594:	dfc00b15 	stw	ra,44(sp)
 4046598:	df000a15 	stw	fp,40(sp)
 404659c:	df000a04 	addi	fp,sp,40
 40465a0:	e13ffb15 	stw	r4,-20(fp)
 40465a4:	e17ffc15 	stw	r5,-16(fp)
 40465a8:	e1bffd15 	stw	r6,-12(fp)
 40465ac:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
 40465b0:	00bffa84 	movi	r2,-22
 40465b4:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 40465b8:	e0bffc17 	ldw	r2,-16(fp)
 40465bc:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 40465c0:	e0bff917 	ldw	r2,-28(fp)
 40465c4:	10800808 	cmpgei	r2,r2,32
 40465c8:	1000291e 	bne	r2,zero,4046670 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 40465cc:	0005303a 	rdctl	r2,status
 40465d0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 40465d4:	e0fff717 	ldw	r3,-36(fp)
 40465d8:	00bfff84 	movi	r2,-2
 40465dc:	1884703a 	and	r2,r3,r2
 40465e0:	1001703a 	wrctl	status,r2
  
  return context;
 40465e4:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 40465e8:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
 40465ec:	e0bff917 	ldw	r2,-28(fp)
 40465f0:	00c10174 	movhi	r3,1029
 40465f4:	18ed7504 	addi	r3,r3,-18988
 40465f8:	100490fa 	slli	r2,r2,3
 40465fc:	10c7883a 	add	r3,r2,r3
 4046600:	e0bffd17 	ldw	r2,-12(fp)
 4046604:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
 4046608:	e0bff917 	ldw	r2,-28(fp)
 404660c:	00c10174 	movhi	r3,1029
 4046610:	18ed7504 	addi	r3,r3,-18988
 4046614:	100490fa 	slli	r2,r2,3
 4046618:	10c5883a 	add	r2,r2,r3
 404661c:	10c00104 	addi	r3,r2,4
 4046620:	e0bffe17 	ldw	r2,-8(fp)
 4046624:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 4046628:	e0bffd17 	ldw	r2,-12(fp)
 404662c:	1005003a 	cmpeq	r2,r2,zero
 4046630:	1000051e 	bne	r2,zero,4046648 <alt_iic_isr_register+0xb8>
 4046634:	e17ff917 	ldw	r5,-28(fp)
 4046638:	e13ffb17 	ldw	r4,-20(fp)
 404663c:	404640c0 	call	404640c <alt_ic_irq_enable>
 4046640:	e0bfff15 	stw	r2,-4(fp)
 4046644:	00000406 	br	4046658 <alt_iic_isr_register+0xc8>
 4046648:	e17ff917 	ldw	r5,-28(fp)
 404664c:	e13ffb17 	ldw	r4,-20(fp)
 4046650:	40464a80 	call	40464a8 <alt_ic_irq_disable>
 4046654:	e0bfff15 	stw	r2,-4(fp)
 4046658:	e0bfff17 	ldw	r2,-4(fp)
 404665c:	e0bffa15 	stw	r2,-24(fp)
 4046660:	e0bff817 	ldw	r2,-32(fp)
 4046664:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4046668:	e0bff617 	ldw	r2,-40(fp)
 404666c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 4046670:	e0bffa17 	ldw	r2,-24(fp)
}
 4046674:	e037883a 	mov	sp,fp
 4046678:	dfc00117 	ldw	ra,4(sp)
 404667c:	df000017 	ldw	fp,0(sp)
 4046680:	dec00204 	addi	sp,sp,8
 4046684:	f800283a 	ret

04046688 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 4046688:	defff904 	addi	sp,sp,-28
 404668c:	dfc00615 	stw	ra,24(sp)
 4046690:	df000515 	stw	fp,20(sp)
 4046694:	df000504 	addi	fp,sp,20
 4046698:	e13ffc15 	stw	r4,-16(fp)
 404669c:	e17ffd15 	stw	r5,-12(fp)
 40466a0:	e1bffe15 	stw	r6,-8(fp)
 40466a4:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 40466a8:	e13ffd17 	ldw	r4,-12(fp)
 40466ac:	e17ffe17 	ldw	r5,-8(fp)
 40466b0:	e1bfff17 	ldw	r6,-4(fp)
 40466b4:	40468a00 	call	40468a0 <open>
 40466b8:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 40466bc:	e0bffb17 	ldw	r2,-20(fp)
 40466c0:	1004803a 	cmplt	r2,r2,zero
 40466c4:	10001c1e 	bne	r2,zero,4046738 <alt_open_fd+0xb0>
  {
    fd->dev      = alt_fd_list[old].dev;
 40466c8:	e0bffb17 	ldw	r2,-20(fp)
 40466cc:	00c10174 	movhi	r3,1029
 40466d0:	18e1d904 	addi	r3,r3,-30876
 40466d4:	10800324 	muli	r2,r2,12
 40466d8:	10c5883a 	add	r2,r2,r3
 40466dc:	10c00017 	ldw	r3,0(r2)
 40466e0:	e0bffc17 	ldw	r2,-16(fp)
 40466e4:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 40466e8:	e0bffb17 	ldw	r2,-20(fp)
 40466ec:	00c10174 	movhi	r3,1029
 40466f0:	18e1d904 	addi	r3,r3,-30876
 40466f4:	10800324 	muli	r2,r2,12
 40466f8:	10c5883a 	add	r2,r2,r3
 40466fc:	10800104 	addi	r2,r2,4
 4046700:	10c00017 	ldw	r3,0(r2)
 4046704:	e0bffc17 	ldw	r2,-16(fp)
 4046708:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 404670c:	e0bffb17 	ldw	r2,-20(fp)
 4046710:	00c10174 	movhi	r3,1029
 4046714:	18e1d904 	addi	r3,r3,-30876
 4046718:	10800324 	muli	r2,r2,12
 404671c:	10c5883a 	add	r2,r2,r3
 4046720:	10800204 	addi	r2,r2,8
 4046724:	10c00017 	ldw	r3,0(r2)
 4046728:	e0bffc17 	ldw	r2,-16(fp)
 404672c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 4046730:	e13ffb17 	ldw	r4,-20(fp)
 4046734:	40433bc0 	call	40433bc <alt_release_fd>
  }
} 
 4046738:	e037883a 	mov	sp,fp
 404673c:	dfc00117 	ldw	ra,4(sp)
 4046740:	df000017 	ldw	fp,0(sp)
 4046744:	dec00204 	addi	sp,sp,8
 4046748:	f800283a 	ret

0404674c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 404674c:	defffb04 	addi	sp,sp,-20
 4046750:	dfc00415 	stw	ra,16(sp)
 4046754:	df000315 	stw	fp,12(sp)
 4046758:	df000304 	addi	fp,sp,12
 404675c:	e13ffd15 	stw	r4,-12(fp)
 4046760:	e17ffe15 	stw	r5,-8(fp)
 4046764:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 4046768:	01010174 	movhi	r4,1029
 404676c:	2121dc04 	addi	r4,r4,-30864
 4046770:	e17ffd17 	ldw	r5,-12(fp)
 4046774:	01800044 	movi	r6,1
 4046778:	01c07fc4 	movi	r7,511
 404677c:	40466880 	call	4046688 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 4046780:	01010174 	movhi	r4,1029
 4046784:	2121d904 	addi	r4,r4,-30876
 4046788:	e17ffe17 	ldw	r5,-8(fp)
 404678c:	000d883a 	mov	r6,zero
 4046790:	01c07fc4 	movi	r7,511
 4046794:	40466880 	call	4046688 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 4046798:	01010174 	movhi	r4,1029
 404679c:	2121df04 	addi	r4,r4,-30852
 40467a0:	e17fff17 	ldw	r5,-4(fp)
 40467a4:	01800044 	movi	r6,1
 40467a8:	01c07fc4 	movi	r7,511
 40467ac:	40466880 	call	4046688 <alt_open_fd>
}  
 40467b0:	e037883a 	mov	sp,fp
 40467b4:	dfc00117 	ldw	ra,4(sp)
 40467b8:	df000017 	ldw	fp,0(sp)
 40467bc:	dec00204 	addi	sp,sp,8
 40467c0:	f800283a 	ret

040467c4 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 40467c4:	defffc04 	addi	sp,sp,-16
 40467c8:	df000315 	stw	fp,12(sp)
 40467cc:	df000304 	addi	fp,sp,12
 40467d0:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 40467d4:	e0bffe17 	ldw	r2,-8(fp)
 40467d8:	10800217 	ldw	r2,8(r2)
 40467dc:	10d00034 	orhi	r3,r2,16384
 40467e0:	e0bffe17 	ldw	r2,-8(fp)
 40467e4:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 40467e8:	e03ffd15 	stw	zero,-12(fp)
 40467ec:	00002006 	br	4046870 <alt_file_locked+0xac>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 40467f0:	e0bffd17 	ldw	r2,-12(fp)
 40467f4:	00c10174 	movhi	r3,1029
 40467f8:	18e1d904 	addi	r3,r3,-30876
 40467fc:	10800324 	muli	r2,r2,12
 4046800:	10c5883a 	add	r2,r2,r3
 4046804:	10c00017 	ldw	r3,0(r2)
 4046808:	e0bffe17 	ldw	r2,-8(fp)
 404680c:	10800017 	ldw	r2,0(r2)
 4046810:	1880141e 	bne	r3,r2,4046864 <alt_file_locked+0xa0>
 4046814:	e0bffd17 	ldw	r2,-12(fp)
 4046818:	00c10174 	movhi	r3,1029
 404681c:	18e1d904 	addi	r3,r3,-30876
 4046820:	10800324 	muli	r2,r2,12
 4046824:	10c5883a 	add	r2,r2,r3
 4046828:	10800204 	addi	r2,r2,8
 404682c:	10800017 	ldw	r2,0(r2)
 4046830:	1004403a 	cmpge	r2,r2,zero
 4046834:	10000b1e 	bne	r2,zero,4046864 <alt_file_locked+0xa0>
 4046838:	e0bffd17 	ldw	r2,-12(fp)
 404683c:	10800324 	muli	r2,r2,12
 4046840:	1007883a 	mov	r3,r2
 4046844:	00810174 	movhi	r2,1029
 4046848:	10a1d904 	addi	r2,r2,-30876
 404684c:	1887883a 	add	r3,r3,r2
 4046850:	e0bffe17 	ldw	r2,-8(fp)
 4046854:	18800326 	beq	r3,r2,4046864 <alt_file_locked+0xa0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 4046858:	00bffcc4 	movi	r2,-13
 404685c:	e0bfff15 	stw	r2,-4(fp)
 4046860:	00000a06 	br	404688c <alt_file_locked+0xc8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 4046864:	e0bffd17 	ldw	r2,-12(fp)
 4046868:	10800044 	addi	r2,r2,1
 404686c:	e0bffd15 	stw	r2,-12(fp)
 4046870:	00810174 	movhi	r2,1029
 4046874:	10a68f04 	addi	r2,r2,-26052
 4046878:	10800017 	ldw	r2,0(r2)
 404687c:	1007883a 	mov	r3,r2
 4046880:	e0bffd17 	ldw	r2,-12(fp)
 4046884:	18bfda2e 	bgeu	r3,r2,40467f0 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 4046888:	e03fff15 	stw	zero,-4(fp)
 404688c:	e0bfff17 	ldw	r2,-4(fp)
}
 4046890:	e037883a 	mov	sp,fp
 4046894:	df000017 	ldw	fp,0(sp)
 4046898:	dec00104 	addi	sp,sp,4
 404689c:	f800283a 	ret

040468a0 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 40468a0:	defff404 	addi	sp,sp,-48
 40468a4:	dfc00b15 	stw	ra,44(sp)
 40468a8:	df000a15 	stw	fp,40(sp)
 40468ac:	df000a04 	addi	fp,sp,40
 40468b0:	e13ffb15 	stw	r4,-20(fp)
 40468b4:	e17ffc15 	stw	r5,-16(fp)
 40468b8:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 40468bc:	00bfffc4 	movi	r2,-1
 40468c0:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 40468c4:	00bffb44 	movi	r2,-19
 40468c8:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 40468cc:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 40468d0:	e13ffb17 	ldw	r4,-20(fp)
 40468d4:	01410174 	movhi	r5,1029
 40468d8:	29668d04 	addi	r5,r5,-26060
 40468dc:	404750c0 	call	404750c <alt_find_dev>
 40468e0:	e0bffa15 	stw	r2,-24(fp)
 40468e4:	e0bffa17 	ldw	r2,-24(fp)
 40468e8:	1004c03a 	cmpne	r2,r2,zero
 40468ec:	1000051e 	bne	r2,zero,4046904 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 40468f0:	e13ffb17 	ldw	r4,-20(fp)
 40468f4:	40475a00 	call	40475a0 <alt_find_file>
 40468f8:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 40468fc:	00800044 	movi	r2,1
 4046900:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 4046904:	e0bffa17 	ldw	r2,-24(fp)
 4046908:	1005003a 	cmpeq	r2,r2,zero
 404690c:	1000301e 	bne	r2,zero,40469d0 <open+0x130>
  {
    if ((index = alt_get_fd (dev)) < 0)
 4046910:	e13ffa17 	ldw	r4,-24(fp)
 4046914:	40476c00 	call	40476c0 <alt_get_fd>
 4046918:	e0bff815 	stw	r2,-32(fp)
 404691c:	e0bff817 	ldw	r2,-32(fp)
 4046920:	1004403a 	cmpge	r2,r2,zero
 4046924:	1000031e 	bne	r2,zero,4046934 <open+0x94>
    {
      status = index;
 4046928:	e0bff817 	ldw	r2,-32(fp)
 404692c:	e0bff715 	stw	r2,-36(fp)
 4046930:	00002906 	br	40469d8 <open+0x138>
    }
    else
    {
      fd = &alt_fd_list[index];
 4046934:	e0bff817 	ldw	r2,-32(fp)
 4046938:	10800324 	muli	r2,r2,12
 404693c:	1007883a 	mov	r3,r2
 4046940:	00810174 	movhi	r2,1029
 4046944:	10a1d904 	addi	r2,r2,-30876
 4046948:	1885883a 	add	r2,r3,r2
 404694c:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 4046950:	e0fffc17 	ldw	r3,-16(fp)
 4046954:	00900034 	movhi	r2,16384
 4046958:	10bfffc4 	addi	r2,r2,-1
 404695c:	1886703a 	and	r3,r3,r2
 4046960:	e0bff917 	ldw	r2,-28(fp)
 4046964:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 4046968:	e0bff617 	ldw	r2,-40(fp)
 404696c:	1004c03a 	cmpne	r2,r2,zero
 4046970:	1000061e 	bne	r2,zero,404698c <open+0xec>
 4046974:	e13ff917 	ldw	r4,-28(fp)
 4046978:	40467c40 	call	40467c4 <alt_file_locked>
 404697c:	e0bff715 	stw	r2,-36(fp)
 4046980:	e0bff717 	ldw	r2,-36(fp)
 4046984:	1004803a 	cmplt	r2,r2,zero
 4046988:	1000131e 	bne	r2,zero,40469d8 <open+0x138>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 404698c:	e0bffa17 	ldw	r2,-24(fp)
 4046990:	10800317 	ldw	r2,12(r2)
 4046994:	1005003a 	cmpeq	r2,r2,zero
 4046998:	1000091e 	bne	r2,zero,40469c0 <open+0x120>
 404699c:	e0bffa17 	ldw	r2,-24(fp)
 40469a0:	10800317 	ldw	r2,12(r2)
 40469a4:	e13ff917 	ldw	r4,-28(fp)
 40469a8:	e17ffb17 	ldw	r5,-20(fp)
 40469ac:	e1bffc17 	ldw	r6,-16(fp)
 40469b0:	e1fffd17 	ldw	r7,-12(fp)
 40469b4:	103ee83a 	callr	r2
 40469b8:	e0bfff15 	stw	r2,-4(fp)
 40469bc:	00000106 	br	40469c4 <open+0x124>
 40469c0:	e03fff15 	stw	zero,-4(fp)
 40469c4:	e0bfff17 	ldw	r2,-4(fp)
 40469c8:	e0bff715 	stw	r2,-36(fp)
 40469cc:	00000206 	br	40469d8 <open+0x138>
      }
    }
  }
  else
  {
    status = -ENODEV;
 40469d0:	00bffb44 	movi	r2,-19
 40469d4:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 40469d8:	e0bff717 	ldw	r2,-36(fp)
 40469dc:	1004403a 	cmpge	r2,r2,zero
 40469e0:	1000091e 	bne	r2,zero,4046a08 <open+0x168>
  {
    alt_release_fd (index);  
 40469e4:	e13ff817 	ldw	r4,-32(fp)
 40469e8:	40433bc0 	call	40433bc <alt_release_fd>
    ALT_ERRNO = -status;
 40469ec:	4046a280 	call	4046a28 <alt_get_errno>
 40469f0:	e0fff717 	ldw	r3,-36(fp)
 40469f4:	00c7c83a 	sub	r3,zero,r3
 40469f8:	10c00015 	stw	r3,0(r2)
    return -1;
 40469fc:	00bfffc4 	movi	r2,-1
 4046a00:	e0bffe15 	stw	r2,-8(fp)
 4046a04:	00000206 	br	4046a10 <open+0x170>
  }
  
  /* return the reference upon success */

  return index;
 4046a08:	e0bff817 	ldw	r2,-32(fp)
 4046a0c:	e0bffe15 	stw	r2,-8(fp)
 4046a10:	e0bffe17 	ldw	r2,-8(fp)
}
 4046a14:	e037883a 	mov	sp,fp
 4046a18:	dfc00117 	ldw	ra,4(sp)
 4046a1c:	df000017 	ldw	fp,0(sp)
 4046a20:	dec00204 	addi	sp,sp,8
 4046a24:	f800283a 	ret

04046a28 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4046a28:	defffd04 	addi	sp,sp,-12
 4046a2c:	dfc00215 	stw	ra,8(sp)
 4046a30:	df000115 	stw	fp,4(sp)
 4046a34:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 4046a38:	00810174 	movhi	r2,1029
 4046a3c:	10a69004 	addi	r2,r2,-26048
 4046a40:	10800017 	ldw	r2,0(r2)
 4046a44:	1005003a 	cmpeq	r2,r2,zero
 4046a48:	1000061e 	bne	r2,zero,4046a64 <alt_get_errno+0x3c>
 4046a4c:	00810174 	movhi	r2,1029
 4046a50:	10a69004 	addi	r2,r2,-26048
 4046a54:	10800017 	ldw	r2,0(r2)
 4046a58:	103ee83a 	callr	r2
 4046a5c:	e0bfff15 	stw	r2,-4(fp)
 4046a60:	00000306 	br	4046a70 <alt_get_errno+0x48>
 4046a64:	00810174 	movhi	r2,1029
 4046a68:	10ad6404 	addi	r2,r2,-19056
 4046a6c:	e0bfff15 	stw	r2,-4(fp)
 4046a70:	e0bfff17 	ldw	r2,-4(fp)
}
 4046a74:	e037883a 	mov	sp,fp
 4046a78:	dfc00117 	ldw	ra,4(sp)
 4046a7c:	df000017 	ldw	fp,0(sp)
 4046a80:	dec00204 	addi	sp,sp,8
 4046a84:	f800283a 	ret

04046a88 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 4046a88:	defffa04 	addi	sp,sp,-24
 4046a8c:	df000515 	stw	fp,20(sp)
 4046a90:	df000504 	addi	fp,sp,20
 4046a94:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4046a98:	0005303a 	rdctl	r2,status
 4046a9c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4046aa0:	e0fffd17 	ldw	r3,-12(fp)
 4046aa4:	00bfff84 	movi	r2,-2
 4046aa8:	1884703a 	and	r2,r3,r2
 4046aac:	1001703a 	wrctl	status,r2
  
  return context;
 4046ab0:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 4046ab4:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 4046ab8:	e0bfff17 	ldw	r2,-4(fp)
 4046abc:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 4046ac0:	e0bffc17 	ldw	r2,-16(fp)
 4046ac4:	10c00017 	ldw	r3,0(r2)
 4046ac8:	e0bffc17 	ldw	r2,-16(fp)
 4046acc:	10800117 	ldw	r2,4(r2)
 4046ad0:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 4046ad4:	e0bffc17 	ldw	r2,-16(fp)
 4046ad8:	10c00117 	ldw	r3,4(r2)
 4046adc:	e0bffc17 	ldw	r2,-16(fp)
 4046ae0:	10800017 	ldw	r2,0(r2)
 4046ae4:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 4046ae8:	e0fffc17 	ldw	r3,-16(fp)
 4046aec:	e0bffc17 	ldw	r2,-16(fp)
 4046af0:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 4046af4:	e0fffc17 	ldw	r3,-16(fp)
 4046af8:	e0bffc17 	ldw	r2,-16(fp)
 4046afc:	18800015 	stw	r2,0(r3)
 4046b00:	e0bffe17 	ldw	r2,-8(fp)
 4046b04:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4046b08:	e0bffb17 	ldw	r2,-20(fp)
 4046b0c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 4046b10:	e037883a 	mov	sp,fp
 4046b14:	df000017 	ldw	fp,0(sp)
 4046b18:	dec00104 	addi	sp,sp,4
 4046b1c:	f800283a 	ret

04046b20 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 4046b20:	defffb04 	addi	sp,sp,-20
 4046b24:	dfc00415 	stw	ra,16(sp)
 4046b28:	df000315 	stw	fp,12(sp)
 4046b2c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 4046b30:	d0a00e17 	ldw	r2,-32712(gp)
 4046b34:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 4046b38:	d0a6e317 	ldw	r2,-25716(gp)
 4046b3c:	10800044 	addi	r2,r2,1
 4046b40:	d0a6e315 	stw	r2,-25716(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 4046b44:	00003106 	br	4046c0c <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 4046b48:	e0bffe17 	ldw	r2,-8(fp)
 4046b4c:	10800017 	ldw	r2,0(r2)
 4046b50:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 4046b54:	e0bffe17 	ldw	r2,-8(fp)
 4046b58:	10800403 	ldbu	r2,16(r2)
 4046b5c:	10803fcc 	andi	r2,r2,255
 4046b60:	1005003a 	cmpeq	r2,r2,zero
 4046b64:	1000051e 	bne	r2,zero,4046b7c <alt_tick+0x5c>
 4046b68:	d0a6e317 	ldw	r2,-25716(gp)
 4046b6c:	1004c03a 	cmpne	r2,r2,zero
 4046b70:	1000021e 	bne	r2,zero,4046b7c <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 4046b74:	e0bffe17 	ldw	r2,-8(fp)
 4046b78:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 4046b7c:	e0bffe17 	ldw	r2,-8(fp)
 4046b80:	10c00217 	ldw	r3,8(r2)
 4046b84:	d0a6e317 	ldw	r2,-25716(gp)
 4046b88:	10c01e36 	bltu	r2,r3,4046c04 <alt_tick+0xe4>
 4046b8c:	e0bffe17 	ldw	r2,-8(fp)
 4046b90:	10800403 	ldbu	r2,16(r2)
 4046b94:	10803fcc 	andi	r2,r2,255
 4046b98:	1004c03a 	cmpne	r2,r2,zero
 4046b9c:	1000191e 	bne	r2,zero,4046c04 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 4046ba0:	e0bffe17 	ldw	r2,-8(fp)
 4046ba4:	10c00317 	ldw	r3,12(r2)
 4046ba8:	e0bffe17 	ldw	r2,-8(fp)
 4046bac:	11000517 	ldw	r4,20(r2)
 4046bb0:	183ee83a 	callr	r3
 4046bb4:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 4046bb8:	e0bffd17 	ldw	r2,-12(fp)
 4046bbc:	1004c03a 	cmpne	r2,r2,zero
 4046bc0:	1000031e 	bne	r2,zero,4046bd0 <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 4046bc4:	e13ffe17 	ldw	r4,-8(fp)
 4046bc8:	4046a880 	call	4046a88 <alt_alarm_stop>
 4046bcc:	00000d06 	br	4046c04 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 4046bd0:	e0bffe17 	ldw	r2,-8(fp)
 4046bd4:	10c00217 	ldw	r3,8(r2)
 4046bd8:	e0bffd17 	ldw	r2,-12(fp)
 4046bdc:	1887883a 	add	r3,r3,r2
 4046be0:	e0bffe17 	ldw	r2,-8(fp)
 4046be4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 4046be8:	e0bffe17 	ldw	r2,-8(fp)
 4046bec:	10c00217 	ldw	r3,8(r2)
 4046bf0:	d0a6e317 	ldw	r2,-25716(gp)
 4046bf4:	1880032e 	bgeu	r3,r2,4046c04 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 4046bf8:	e0fffe17 	ldw	r3,-8(fp)
 4046bfc:	00800044 	movi	r2,1
 4046c00:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 4046c04:	e0bfff17 	ldw	r2,-4(fp)
 4046c08:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 4046c0c:	d0e00e04 	addi	r3,gp,-32712
 4046c10:	e0bffe17 	ldw	r2,-8(fp)
 4046c14:	10ffcc1e 	bne	r2,r3,4046b48 <alt_tick+0x28>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
 4046c18:	e037883a 	mov	sp,fp
 4046c1c:	dfc00117 	ldw	ra,4(sp)
 4046c20:	df000017 	ldw	fp,0(sp)
 4046c24:	dec00204 	addi	sp,sp,8
 4046c28:	f800283a 	ret

04046c2c <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 4046c2c:	deffff04 	addi	sp,sp,-4
 4046c30:	df000015 	stw	fp,0(sp)
 4046c34:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 4046c38:	000170fa 	wrctl	ienable,zero
}
 4046c3c:	e037883a 	mov	sp,fp
 4046c40:	df000017 	ldw	fp,0(sp)
 4046c44:	dec00104 	addi	sp,sp,4
 4046c48:	f800283a 	ret

04046c4c <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 4046c4c:	defff704 	addi	sp,sp,-36
 4046c50:	dfc00815 	stw	ra,32(sp)
 4046c54:	df000715 	stw	fp,28(sp)
 4046c58:	df000704 	addi	fp,sp,28
 4046c5c:	e13ffc15 	stw	r4,-16(fp)
 4046c60:	e17ffd15 	stw	r5,-12(fp)
 4046c64:	e1bffe15 	stw	r6,-8(fp)
 4046c68:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 4046c6c:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 4046c70:	e0bffc17 	ldw	r2,-16(fp)
 4046c74:	e0bffa15 	stw	r2,-24(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 4046c78:	e1bfff17 	ldw	r6,-4(fp)
 4046c7c:	00810134 	movhi	r2,1028
 4046c80:	109bfc04 	addi	r2,r2,28656
 4046c84:	d8800015 	stw	r2,0(sp)
 4046c88:	e13ffa17 	ldw	r4,-24(fp)
 4046c8c:	e17ffe17 	ldw	r5,-8(fp)
 4046c90:	e1c00217 	ldw	r7,8(fp)
 4046c94:	4043d040 	call	4043d04 <alt_flash_program_block>
 4046c98:	e0bffb15 	stw	r2,-20(fp)
                                    alt_write_word_amd);
  return ret_code;
 4046c9c:	e0bffb17 	ldw	r2,-20(fp)
}
 4046ca0:	e037883a 	mov	sp,fp
 4046ca4:	dfc00117 	ldw	ra,4(sp)
 4046ca8:	df000017 	ldw	fp,0(sp)
 4046cac:	dec00204 	addi	sp,sp,8
 4046cb0:	f800283a 	ret

04046cb4 <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
 4046cb4:	defff804 	addi	sp,sp,-32
 4046cb8:	dfc00715 	stw	ra,28(sp)
 4046cbc:	df000615 	stw	fp,24(sp)
 4046cc0:	df000604 	addi	fp,sp,24
 4046cc4:	e13ffe15 	stw	r4,-8(fp)
 4046cc8:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 4046ccc:	e03ffc15 	stw	zero,-16(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 4046cd0:	e0bffe17 	ldw	r2,-8(fp)
 4046cd4:	e0bffa15 	stw	r2,-24(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 4046cd8:	e0bffa17 	ldw	r2,-24(fp)
 4046cdc:	10c03317 	ldw	r3,204(r2)
 4046ce0:	e0bffa17 	ldw	r2,-24(fp)
 4046ce4:	11000a17 	ldw	r4,40(r2)
 4046ce8:	01415544 	movi	r5,1365
 4046cec:	01802a84 	movi	r6,170
 4046cf0:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 4046cf4:	e0bffa17 	ldw	r2,-24(fp)
 4046cf8:	10c03317 	ldw	r3,204(r2)
 4046cfc:	e0bffa17 	ldw	r2,-24(fp)
 4046d00:	11000a17 	ldw	r4,40(r2)
 4046d04:	0140aa84 	movi	r5,682
 4046d08:	01801544 	movi	r6,85
 4046d0c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
 4046d10:	e0bffa17 	ldw	r2,-24(fp)
 4046d14:	10c03317 	ldw	r3,204(r2)
 4046d18:	e0bffa17 	ldw	r2,-24(fp)
 4046d1c:	11000a17 	ldw	r4,40(r2)
 4046d20:	01415544 	movi	r5,1365
 4046d24:	01802004 	movi	r6,128
 4046d28:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 4046d2c:	e0bffa17 	ldw	r2,-24(fp)
 4046d30:	10c03317 	ldw	r3,204(r2)
 4046d34:	e0bffa17 	ldw	r2,-24(fp)
 4046d38:	11000a17 	ldw	r4,40(r2)
 4046d3c:	01415544 	movi	r5,1365
 4046d40:	01802a84 	movi	r6,170
 4046d44:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 4046d48:	e0bffa17 	ldw	r2,-24(fp)
 4046d4c:	10c03317 	ldw	r3,204(r2)
 4046d50:	e0bffa17 	ldw	r2,-24(fp)
 4046d54:	11000a17 	ldw	r4,40(r2)
 4046d58:	0140aa84 	movi	r5,682
 4046d5c:	01801544 	movi	r6,85
 4046d60:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
 4046d64:	e0bffa17 	ldw	r2,-24(fp)
 4046d68:	11803517 	ldw	r6,212(r2)
 4046d6c:	e0bffa17 	ldw	r2,-24(fp)
 4046d70:	10800a17 	ldw	r2,40(r2)
 4046d74:	1007883a 	mov	r3,r2
 4046d78:	e0bfff17 	ldw	r2,-4(fp)
 4046d7c:	1889883a 	add	r4,r3,r2
 4046d80:	01400c04 	movi	r5,48
 4046d84:	303ee83a 	callr	r6

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
 4046d88:	0109c404 	movi	r4,10000
 4046d8c:	40478080 	call	4047808 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
 4046d90:	00800c84 	movi	r2,50
 4046d94:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 4046d98:	e0bffa17 	ldw	r2,-24(fp)
 4046d9c:	10800a17 	ldw	r2,40(r2)
 4046da0:	1007883a 	mov	r3,r2
 4046da4:	e0bfff17 	ldw	r2,-4(fp)
 4046da8:	1885883a 	add	r2,r3,r2
 4046dac:	10800023 	ldbuio	r2,0(r2)
 4046db0:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
 4046db4:	0100fa04 	movi	r4,1000
 4046db8:	40478080 	call	4047808 <usleep>
    timeout--;
 4046dbc:	e0bffb17 	ldw	r2,-20(fp)
 4046dc0:	10bfffc4 	addi	r2,r2,-1
 4046dc4:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
 4046dc8:	e0bffd03 	ldbu	r2,-12(fp)
 4046dcc:	10803fcc 	andi	r2,r2,255
 4046dd0:	1080020c 	andi	r2,r2,8
 4046dd4:	1004c03a 	cmpne	r2,r2,zero
 4046dd8:	1000031e 	bne	r2,zero,4046de8 <alt_erase_block_amd+0x134>
 4046ddc:	e0bffb17 	ldw	r2,-20(fp)
 4046de0:	10800048 	cmpgei	r2,r2,1
 4046de4:	103fec1e 	bne	r2,zero,4046d98 <alt_erase_block_amd+0xe4>


  timeout = flash->erase_timeout;
 4046de8:	e0bffa17 	ldw	r2,-24(fp)
 4046dec:	10803117 	ldw	r2,196(r2)
 4046df0:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 4046df4:	00001706 	br	4046e54 <alt_erase_block_amd+0x1a0>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 4046df8:	e0bffa17 	ldw	r2,-24(fp)
 4046dfc:	10800a17 	ldw	r2,40(r2)
 4046e00:	1007883a 	mov	r3,r2
 4046e04:	e0bfff17 	ldw	r2,-4(fp)
 4046e08:	1885883a 	add	r2,r3,r2
 4046e0c:	10800023 	ldbuio	r2,0(r2)
 4046e10:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
 4046e14:	e0bffd03 	ldbu	r2,-12(fp)
 4046e18:	10803fcc 	andi	r2,r2,255
 4046e1c:	1080201c 	xori	r2,r2,128
 4046e20:	10bfe004 	addi	r2,r2,-128
 4046e24:	1004803a 	cmplt	r2,r2,zero
 4046e28:	10000d1e 	bne	r2,zero,4046e60 <alt_erase_block_amd+0x1ac>
 4046e2c:	e0bffd03 	ldbu	r2,-12(fp)
 4046e30:	10803fcc 	andi	r2,r2,255
 4046e34:	1080080c 	andi	r2,r2,32
 4046e38:	1004c03a 	cmpne	r2,r2,zero
 4046e3c:	1000081e 	bne	r2,zero,4046e60 <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
 4046e40:	0100fa04 	movi	r4,1000
 4046e44:	40478080 	call	4047808 <usleep>
    timeout -= 1000;
 4046e48:	e0bffb17 	ldw	r2,-20(fp)
 4046e4c:	10bf0604 	addi	r2,r2,-1000
 4046e50:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 4046e54:	e0bffb17 	ldw	r2,-20(fp)
 4046e58:	10800048 	cmpgei	r2,r2,1
 4046e5c:	103fe61e 	bne	r2,zero,4046df8 <alt_erase_block_amd+0x144>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
 4046e60:	e0bffb17 	ldw	r2,-20(fp)
 4046e64:	10800048 	cmpgei	r2,r2,1
 4046e68:	1000031e 	bne	r2,zero,4046e78 <alt_erase_block_amd+0x1c4>
  {
    ret_code = -ETIMEDOUT;
 4046e6c:	00bfe304 	movi	r2,-116
 4046e70:	e0bffc15 	stw	r2,-16(fp)
 4046e74:	00000f06 	br	4046eb4 <alt_erase_block_amd+0x200>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 4046e78:	e0bffa17 	ldw	r2,-24(fp)
 4046e7c:	10800a17 	ldw	r2,40(r2)
 4046e80:	1007883a 	mov	r3,r2
 4046e84:	e0bfff17 	ldw	r2,-4(fp)
 4046e88:	1885883a 	add	r2,r3,r2
 4046e8c:	10800023 	ldbuio	r2,0(r2)
 4046e90:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
 4046e94:	e0bffd03 	ldbu	r2,-12(fp)
 4046e98:	10803fcc 	andi	r2,r2,255
 4046e9c:	1080201c 	xori	r2,r2,128
 4046ea0:	10bfe004 	addi	r2,r2,-128
 4046ea4:	1004803a 	cmplt	r2,r2,zero
 4046ea8:	1000021e 	bne	r2,zero,4046eb4 <alt_erase_block_amd+0x200>
    {
      ret_code = -EIO;
 4046eac:	00bffec4 	movi	r2,-5
 4046eb0:	e0bffc15 	stw	r2,-16(fp)
    }
  }    
  
  return ret_code;
 4046eb4:	e0bffc17 	ldw	r2,-16(fp)
}
 4046eb8:	e037883a 	mov	sp,fp
 4046ebc:	dfc00117 	ldw	ra,4(sp)
 4046ec0:	df000017 	ldw	fp,0(sp)
 4046ec4:	dec00204 	addi	sp,sp,8
 4046ec8:	f800283a 	ret

04046ecc <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
 4046ecc:	defff804 	addi	sp,sp,-32
 4046ed0:	dfc00715 	stw	ra,28(sp)
 4046ed4:	df000615 	stw	fp,24(sp)
 4046ed8:	df000604 	addi	fp,sp,24
 4046edc:	e13ffd15 	stw	r4,-12(fp)
 4046ee0:	e17ffe15 	stw	r5,-8(fp)
 4046ee4:	e1bfff05 	stb	r6,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
 4046ee8:	e0bffd17 	ldw	r2,-12(fp)
 4046eec:	10803017 	ldw	r2,192(r2)
 4046ef0:	10801924 	muli	r2,r2,100
 4046ef4:	e0bffb15 	stw	r2,-20(fp)
  int ret_code = 0;
 4046ef8:	e03ffa15 	stw	zero,-24(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
 4046efc:	e0bffd17 	ldw	r2,-12(fp)
 4046f00:	10800a17 	ldw	r2,40(r2)
 4046f04:	1007883a 	mov	r3,r2
 4046f08:	e0bffe17 	ldw	r2,-8(fp)
 4046f0c:	1885883a 	add	r2,r3,r2
 4046f10:	10800023 	ldbuio	r2,0(r2)
 4046f14:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
 4046f18:	00001706 	br	4046f78 <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 4046f1c:	e0bffc03 	ldbu	r2,-16(fp)
 4046f20:	10803fcc 	andi	r2,r2,255
 4046f24:	10c0200c 	andi	r3,r2,128
 4046f28:	e0bfff03 	ldbu	r2,-4(fp)
 4046f2c:	1080200c 	andi	r2,r2,128
 4046f30:	18801426 	beq	r3,r2,4046f84 <alt_wait_for_command_to_complete_amd+0xb8>
 4046f34:	e0bffc03 	ldbu	r2,-16(fp)
 4046f38:	10803fcc 	andi	r2,r2,255
 4046f3c:	1080080c 	andi	r2,r2,32
 4046f40:	1004c03a 	cmpne	r2,r2,zero
 4046f44:	10000f1e 	bne	r2,zero,4046f84 <alt_wait_for_command_to_complete_amd+0xb8>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
 4046f48:	01000044 	movi	r4,1
 4046f4c:	40478080 	call	4047808 <usleep>
    timeout--;
 4046f50:	e0bffb17 	ldw	r2,-20(fp)
 4046f54:	10bfffc4 	addi	r2,r2,-1
 4046f58:	e0bffb15 	stw	r2,-20(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 4046f5c:	e0bffd17 	ldw	r2,-12(fp)
 4046f60:	10800a17 	ldw	r2,40(r2)
 4046f64:	1007883a 	mov	r3,r2
 4046f68:	e0bffe17 	ldw	r2,-8(fp)
 4046f6c:	1885883a 	add	r2,r3,r2
 4046f70:	10800023 	ldbuio	r2,0(r2)
 4046f74:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
 4046f78:	e0bffb17 	ldw	r2,-20(fp)
 4046f7c:	10800048 	cmpgei	r2,r2,1
 4046f80:	103fe61e 	bne	r2,zero,4046f1c <alt_wait_for_command_to_complete_amd+0x50>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
 4046f84:	e0bffb17 	ldw	r2,-20(fp)
 4046f88:	1004c03a 	cmpne	r2,r2,zero
 4046f8c:	1000031e 	bne	r2,zero,4046f9c <alt_wait_for_command_to_complete_amd+0xd0>
  {
    ret_code = -ETIMEDOUT;
 4046f90:	00bfe304 	movi	r2,-116
 4046f94:	e0bffa15 	stw	r2,-24(fp)
 4046f98:	00000f06 	br	4046fd8 <alt_wait_for_command_to_complete_amd+0x10c>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 4046f9c:	e0bffd17 	ldw	r2,-12(fp)
 4046fa0:	10800a17 	ldw	r2,40(r2)
 4046fa4:	1007883a 	mov	r3,r2
 4046fa8:	e0bffe17 	ldw	r2,-8(fp)
 4046fac:	1885883a 	add	r2,r3,r2
 4046fb0:	10800023 	ldbuio	r2,0(r2)
 4046fb4:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
 4046fb8:	e0bffc03 	ldbu	r2,-16(fp)
 4046fbc:	10803fcc 	andi	r2,r2,255
 4046fc0:	10c0200c 	andi	r3,r2,128
 4046fc4:	e0bfff03 	ldbu	r2,-4(fp)
 4046fc8:	1080200c 	andi	r2,r2,128
 4046fcc:	18800226 	beq	r3,r2,4046fd8 <alt_wait_for_command_to_complete_amd+0x10c>
    {
      ret_code = -EIO;
 4046fd0:	00bffec4 	movi	r2,-5
 4046fd4:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  return ret_code;
 4046fd8:	e0bffa17 	ldw	r2,-24(fp)
}
 4046fdc:	e037883a 	mov	sp,fp
 4046fe0:	dfc00117 	ldw	ra,4(sp)
 4046fe4:	df000017 	ldw	fp,0(sp)
 4046fe8:	dec00204 	addi	sp,sp,8
 4046fec:	f800283a 	ret

04046ff0 <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
 4046ff0:	defff904 	addi	sp,sp,-28
 4046ff4:	dfc00615 	stw	ra,24(sp)
 4046ff8:	df000515 	stw	fp,20(sp)
 4046ffc:	df000504 	addi	fp,sp,20
 4047000:	e13ffd15 	stw	r4,-12(fp)
 4047004:	e17ffe15 	stw	r5,-8(fp)
 4047008:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 404700c:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 4047010:	e0bffd17 	ldw	r2,-12(fp)
 4047014:	10c03317 	ldw	r3,204(r2)
 4047018:	e0bffd17 	ldw	r2,-12(fp)
 404701c:	11000a17 	ldw	r4,40(r2)
 4047020:	01415544 	movi	r5,1365
 4047024:	01802a84 	movi	r6,170
 4047028:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 404702c:	e0bffd17 	ldw	r2,-12(fp)
 4047030:	10c03317 	ldw	r3,204(r2)
 4047034:	e0bffd17 	ldw	r2,-12(fp)
 4047038:	11000a17 	ldw	r4,40(r2)
 404703c:	0140aa84 	movi	r5,682
 4047040:	01801544 	movi	r6,85
 4047044:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
 4047048:	e0bffd17 	ldw	r2,-12(fp)
 404704c:	10c03317 	ldw	r3,204(r2)
 4047050:	e0bffd17 	ldw	r2,-12(fp)
 4047054:	11000a17 	ldw	r4,40(r2)
 4047058:	01415544 	movi	r5,1365
 404705c:	01802804 	movi	r6,160
 4047060:	183ee83a 	callr	r3
  
  value = *src_addr;
 4047064:	e0bfff17 	ldw	r2,-4(fp)
 4047068:	10800003 	ldbu	r2,0(r2)
 404706c:	e0bffb05 	stb	r2,-20(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
 4047070:	e13ffd17 	ldw	r4,-12(fp)
 4047074:	e17ffe17 	ldw	r5,-8(fp)
 4047078:	e1bfff17 	ldw	r6,-4(fp)
 404707c:	4043ba00 	call	4043ba0 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
 4047080:	e1bffb03 	ldbu	r6,-20(fp)
 4047084:	e13ffd17 	ldw	r4,-12(fp)
 4047088:	e17ffe17 	ldw	r5,-8(fp)
 404708c:	4046ecc0 	call	4046ecc <alt_wait_for_command_to_complete_amd>
 4047090:	e0bffc15 	stw	r2,-16(fp)
                                                  offset,
                                                  value);
  return ret_code;
 4047094:	e0bffc17 	ldw	r2,-16(fp)
  
}
 4047098:	e037883a 	mov	sp,fp
 404709c:	dfc00117 	ldw	ra,4(sp)
 40470a0:	df000017 	ldw	fp,0(sp)
 40470a4:	dec00204 	addi	sp,sp,8
 40470a8:	f800283a 	ret

040470ac <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 40470ac:	defff704 	addi	sp,sp,-36
 40470b0:	dfc00815 	stw	ra,32(sp)
 40470b4:	df000715 	stw	fp,28(sp)
 40470b8:	df000704 	addi	fp,sp,28
 40470bc:	e13ffc15 	stw	r4,-16(fp)
 40470c0:	e17ffd15 	stw	r5,-12(fp)
 40470c4:	e1bffe15 	stw	r6,-8(fp)
 40470c8:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 40470cc:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 40470d0:	e0bffc17 	ldw	r2,-16(fp)
 40470d4:	e0bffa15 	stw	r2,-24(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 40470d8:	e13ffa17 	ldw	r4,-24(fp)
 40470dc:	e17ffd17 	ldw	r5,-12(fp)
 40470e0:	40472a40 	call	40472a4 <alt_unlock_block_intel>
 40470e4:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 40470e8:	e0bffb17 	ldw	r2,-20(fp)
 40470ec:	1004c03a 	cmpne	r2,r2,zero
 40470f0:	1000091e 	bne	r2,zero,4047118 <alt_program_intel+0x6c>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 40470f4:	e1bfff17 	ldw	r6,-4(fp)
 40470f8:	00810134 	movhi	r2,1028
 40470fc:	109d0c04 	addi	r2,r2,29744
 4047100:	d8800015 	stw	r2,0(sp)
 4047104:	e13ffa17 	ldw	r4,-24(fp)
 4047108:	e17ffe17 	ldw	r5,-8(fp)
 404710c:	e1c00217 	ldw	r7,8(fp)
 4047110:	4043d040 	call	4043d04 <alt_flash_program_block>
 4047114:	e0bffb15 	stw	r2,-20(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
 4047118:	e0bffb17 	ldw	r2,-20(fp)
}
 404711c:	e037883a 	mov	sp,fp
 4047120:	dfc00117 	ldw	ra,4(sp)
 4047124:	df000017 	ldw	fp,0(sp)
 4047128:	dec00204 	addi	sp,sp,8
 404712c:	f800283a 	ret

04047130 <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
 4047130:	defff804 	addi	sp,sp,-32
 4047134:	dfc00715 	stw	ra,28(sp)
 4047138:	df000615 	stw	fp,24(sp)
 404713c:	df000604 	addi	fp,sp,24
 4047140:	e13ffe15 	stw	r4,-8(fp)
 4047144:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 4047148:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 404714c:	e0bffe17 	ldw	r2,-8(fp)
 4047150:	e0bffb15 	stw	r2,-20(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
 4047154:	e0bffb17 	ldw	r2,-20(fp)
 4047158:	10803117 	ldw	r2,196(r2)
 404715c:	e0bffa15 	stw	r2,-24(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 4047160:	e13ffb17 	ldw	r4,-20(fp)
 4047164:	e17fff17 	ldw	r5,-4(fp)
 4047168:	40472a40 	call	40472a4 <alt_unlock_block_intel>
 404716c:	e0bffc15 	stw	r2,-16(fp)

  if (!ret_code)
 4047170:	e0bffc17 	ldw	r2,-16(fp)
 4047174:	1004c03a 	cmpne	r2,r2,zero
 4047178:	1000441e 	bne	r2,zero,404728c <alt_erase_block_intel+0x15c>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
 404717c:	e0bffb17 	ldw	r2,-20(fp)
 4047180:	11803517 	ldw	r6,212(r2)
 4047184:	e0bffb17 	ldw	r2,-20(fp)
 4047188:	10800a17 	ldw	r2,40(r2)
 404718c:	1007883a 	mov	r3,r2
 4047190:	e0bfff17 	ldw	r2,-4(fp)
 4047194:	1889883a 	add	r4,r3,r2
 4047198:	01400804 	movi	r5,32
 404719c:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 40471a0:	e0bffb17 	ldw	r2,-20(fp)
 40471a4:	11803517 	ldw	r6,212(r2)
 40471a8:	e0bffb17 	ldw	r2,-20(fp)
 40471ac:	10800a17 	ldw	r2,40(r2)
 40471b0:	1007883a 	mov	r3,r2
 40471b4:	e0bfff17 	ldw	r2,-4(fp)
 40471b8:	1889883a 	add	r4,r3,r2
 40471bc:	01403404 	movi	r5,208
 40471c0:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 40471c4:	e0bffb17 	ldw	r2,-20(fp)
 40471c8:	10800a17 	ldw	r2,40(r2)
 40471cc:	1007883a 	mov	r3,r2
 40471d0:	e0bfff17 	ldw	r2,-4(fp)
 40471d4:	1885883a 	add	r2,r3,r2
 40471d8:	10800023 	ldbuio	r2,0(r2)
 40471dc:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 40471e0:	e0bffd03 	ldbu	r2,-12(fp)
 40471e4:	10803fcc 	andi	r2,r2,255
 40471e8:	1080201c 	xori	r2,r2,128
 40471ec:	10bfe004 	addi	r2,r2,-128
 40471f0:	1004803a 	cmplt	r2,r2,zero
 40471f4:	1000081e 	bne	r2,zero,4047218 <alt_erase_block_intel+0xe8>
      {
        break;
      }
      usleep(1000);
 40471f8:	0100fa04 	movi	r4,1000
 40471fc:	40478080 	call	4047808 <usleep>
      timeout -= 1000;
 4047200:	e0bffa17 	ldw	r2,-24(fp)
 4047204:	10bf0604 	addi	r2,r2,-1000
 4047208:	e0bffa15 	stw	r2,-24(fp)
    }while(timeout > 0);
 404720c:	e0bffa17 	ldw	r2,-24(fp)
 4047210:	10800048 	cmpgei	r2,r2,1
 4047214:	103feb1e 	bne	r2,zero,40471c4 <alt_erase_block_intel+0x94>
    
    if (timeout <= 0)
 4047218:	e0bffa17 	ldw	r2,-24(fp)
 404721c:	10800048 	cmpgei	r2,r2,1
 4047220:	1000031e 	bne	r2,zero,4047230 <alt_erase_block_intel+0x100>
    {
      ret_code = -ETIMEDOUT;
 4047224:	00bfe304 	movi	r2,-116
 4047228:	e0bffc15 	stw	r2,-16(fp)
 404722c:	00000e06 	br	4047268 <alt_erase_block_intel+0x138>
    }
    else if (status & 0x7f)
 4047230:	e0bffd03 	ldbu	r2,-12(fp)
 4047234:	10803fcc 	andi	r2,r2,255
 4047238:	10801fcc 	andi	r2,r2,127
 404723c:	1005003a 	cmpeq	r2,r2,zero
 4047240:	1000091e 	bne	r2,zero,4047268 <alt_erase_block_intel+0x138>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 4047244:	00bffec4 	movi	r2,-5
 4047248:	e0bffc15 	stw	r2,-16(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 404724c:	e0bffb17 	ldw	r2,-20(fp)
 4047250:	10800a17 	ldw	r2,40(r2)
 4047254:	1007883a 	mov	r3,r2
 4047258:	e0bfff17 	ldw	r2,-4(fp)
 404725c:	1885883a 	add	r2,r3,r2
 4047260:	10800023 	ldbuio	r2,0(r2)
 4047264:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 4047268:	e0bffb17 	ldw	r2,-20(fp)
 404726c:	11803517 	ldw	r6,212(r2)
 4047270:	e0bffb17 	ldw	r2,-20(fp)
 4047274:	10800a17 	ldw	r2,40(r2)
 4047278:	1007883a 	mov	r3,r2
 404727c:	e0bfff17 	ldw	r2,-4(fp)
 4047280:	1889883a 	add	r4,r3,r2
 4047284:	01403fc4 	movi	r5,255
 4047288:	303ee83a 	callr	r6
  }
  
  return ret_code;
 404728c:	e0bffc17 	ldw	r2,-16(fp)
}
 4047290:	e037883a 	mov	sp,fp
 4047294:	dfc00117 	ldw	ra,4(sp)
 4047298:	df000017 	ldw	fp,0(sp)
 404729c:	dec00204 	addi	sp,sp,8
 40472a0:	f800283a 	ret

040472a4 <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
 40472a4:	defff904 	addi	sp,sp,-28
 40472a8:	dfc00615 	stw	ra,24(sp)
 40472ac:	df000515 	stw	fp,20(sp)
 40472b0:	df000504 	addi	fp,sp,20
 40472b4:	e13ffe15 	stw	r4,-8(fp)
 40472b8:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
 40472bc:	e03ffc15 	stw	zero,-16(fp)
  int timeout = flash->write_timeout * 100;
 40472c0:	e0bffe17 	ldw	r2,-8(fp)
 40472c4:	10803017 	ldw	r2,192(r2)
 40472c8:	10801924 	muli	r2,r2,100
 40472cc:	e0bffb15 	stw	r2,-20(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
 40472d0:	e0bffe17 	ldw	r2,-8(fp)
 40472d4:	11803517 	ldw	r6,212(r2)
 40472d8:	e0bffe17 	ldw	r2,-8(fp)
 40472dc:	10800a17 	ldw	r2,40(r2)
 40472e0:	1007883a 	mov	r3,r2
 40472e4:	e0bfff17 	ldw	r2,-4(fp)
 40472e8:	1889883a 	add	r4,r3,r2
 40472ec:	01402404 	movi	r5,144
 40472f0:	303ee83a 	callr	r6
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
 40472f4:	e0bffe17 	ldw	r2,-8(fp)
 40472f8:	10800a17 	ldw	r2,40(r2)
 40472fc:	1007883a 	mov	r3,r2
 4047300:	e0bfff17 	ldw	r2,-4(fp)
 4047304:	1885883a 	add	r2,r3,r2
 4047308:	10800104 	addi	r2,r2,4
 404730c:	10800023 	ldbuio	r2,0(r2)
 4047310:	e0bffd45 	stb	r2,-11(fp)
  if (locked & 0x1)
 4047314:	e0bffd43 	ldbu	r2,-11(fp)
 4047318:	1080004c 	andi	r2,r2,1
 404731c:	10803fcc 	andi	r2,r2,255
 4047320:	1005003a 	cmpeq	r2,r2,zero
 4047324:	1000331e 	bne	r2,zero,40473f4 <alt_unlock_block_intel+0x150>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
 4047328:	e0bffe17 	ldw	r2,-8(fp)
 404732c:	11803517 	ldw	r6,212(r2)
 4047330:	e0bffe17 	ldw	r2,-8(fp)
 4047334:	10800a17 	ldw	r2,40(r2)
 4047338:	1007883a 	mov	r3,r2
 404733c:	e0bfff17 	ldw	r2,-4(fp)
 4047340:	1889883a 	add	r4,r3,r2
 4047344:	01401804 	movi	r5,96
 4047348:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 404734c:	e0bffe17 	ldw	r2,-8(fp)
 4047350:	11803517 	ldw	r6,212(r2)
 4047354:	e0bffe17 	ldw	r2,-8(fp)
 4047358:	10800a17 	ldw	r2,40(r2)
 404735c:	1007883a 	mov	r3,r2
 4047360:	e0bfff17 	ldw	r2,-4(fp)
 4047364:	1889883a 	add	r4,r3,r2
 4047368:	01403404 	movi	r5,208
 404736c:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 4047370:	e0bffe17 	ldw	r2,-8(fp)
 4047374:	10800a17 	ldw	r2,40(r2)
 4047378:	1007883a 	mov	r3,r2
 404737c:	e0bfff17 	ldw	r2,-4(fp)
 4047380:	1885883a 	add	r2,r3,r2
 4047384:	10800023 	ldbuio	r2,0(r2)
 4047388:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 404738c:	e0bffd03 	ldbu	r2,-12(fp)
 4047390:	10803fcc 	andi	r2,r2,255
 4047394:	1080201c 	xori	r2,r2,128
 4047398:	10bfe004 	addi	r2,r2,-128
 404739c:	1004803a 	cmplt	r2,r2,zero
 40473a0:	1000081e 	bne	r2,zero,40473c4 <alt_unlock_block_intel+0x120>
      {
        break;
      }
      timeout--;
 40473a4:	e0bffb17 	ldw	r2,-20(fp)
 40473a8:	10bfffc4 	addi	r2,r2,-1
 40473ac:	e0bffb15 	stw	r2,-20(fp)
      usleep(1);
 40473b0:	01000044 	movi	r4,1
 40473b4:	40478080 	call	4047808 <usleep>
    }while(timeout > 0);
 40473b8:	e0bffb17 	ldw	r2,-20(fp)
 40473bc:	10800048 	cmpgei	r2,r2,1
 40473c0:	103feb1e 	bne	r2,zero,4047370 <alt_unlock_block_intel+0xcc>

    if (timeout == 0)
 40473c4:	e0bffb17 	ldw	r2,-20(fp)
 40473c8:	1004c03a 	cmpne	r2,r2,zero
 40473cc:	1000031e 	bne	r2,zero,40473dc <alt_unlock_block_intel+0x138>
    {
      ret_code = -ETIMEDOUT;
 40473d0:	00bfe304 	movi	r2,-116
 40473d4:	e0bffc15 	stw	r2,-16(fp)
 40473d8:	00000606 	br	40473f4 <alt_unlock_block_intel+0x150>
    }
    else if (status & 0x7f)
 40473dc:	e0bffd03 	ldbu	r2,-12(fp)
 40473e0:	10801fcc 	andi	r2,r2,127
 40473e4:	1005003a 	cmpeq	r2,r2,zero
 40473e8:	1000021e 	bne	r2,zero,40473f4 <alt_unlock_block_intel+0x150>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 40473ec:	00bffec4 	movi	r2,-5
 40473f0:	e0bffc15 	stw	r2,-16(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 40473f4:	e0bffe17 	ldw	r2,-8(fp)
 40473f8:	11803517 	ldw	r6,212(r2)
 40473fc:	e0bffe17 	ldw	r2,-8(fp)
 4047400:	10800a17 	ldw	r2,40(r2)
 4047404:	1007883a 	mov	r3,r2
 4047408:	e0bfff17 	ldw	r2,-4(fp)
 404740c:	1889883a 	add	r4,r3,r2
 4047410:	01403fc4 	movi	r5,255
 4047414:	303ee83a 	callr	r6

  return ret_code;
 4047418:	e0bffc17 	ldw	r2,-16(fp)
}
 404741c:	e037883a 	mov	sp,fp
 4047420:	dfc00117 	ldw	ra,4(sp)
 4047424:	df000017 	ldw	fp,0(sp)
 4047428:	dec00204 	addi	sp,sp,8
 404742c:	f800283a 	ret

04047430 <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
 4047430:	defff904 	addi	sp,sp,-28
 4047434:	dfc00615 	stw	ra,24(sp)
 4047438:	df000515 	stw	fp,20(sp)
 404743c:	df000504 	addi	fp,sp,20
 4047440:	e13ffd15 	stw	r4,-12(fp)
 4047444:	e17ffe15 	stw	r5,-8(fp)
 4047448:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 404744c:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
 4047450:	e0bffd17 	ldw	r2,-12(fp)
 4047454:	11803517 	ldw	r6,212(r2)
 4047458:	e0bffd17 	ldw	r2,-12(fp)
 404745c:	10800a17 	ldw	r2,40(r2)
 4047460:	1007883a 	mov	r3,r2
 4047464:	e0bffe17 	ldw	r2,-8(fp)
 4047468:	1889883a 	add	r4,r3,r2
 404746c:	01401004 	movi	r5,64
 4047470:	303ee83a 	callr	r6
  alt_write_value_to_flash(flash, offset, src_addr);
 4047474:	e13ffd17 	ldw	r4,-12(fp)
 4047478:	e17ffe17 	ldw	r5,-8(fp)
 404747c:	e1bfff17 	ldw	r6,-4(fp)
 4047480:	4043ba00 	call	4043ba0 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
 4047484:	e0bffd17 	ldw	r2,-12(fp)
 4047488:	10800a17 	ldw	r2,40(r2)
 404748c:	1007883a 	mov	r3,r2
 4047490:	e0bffe17 	ldw	r2,-8(fp)
 4047494:	1885883a 	add	r2,r3,r2
 4047498:	10800023 	ldbuio	r2,0(r2)
 404749c:	e0bffb05 	stb	r2,-20(fp)
  }while(!(status & 0x80));
 40474a0:	e0bffb03 	ldbu	r2,-20(fp)
 40474a4:	10803fcc 	andi	r2,r2,255
 40474a8:	1080201c 	xori	r2,r2,128
 40474ac:	10bfe004 	addi	r2,r2,-128
 40474b0:	1004403a 	cmpge	r2,r2,zero
 40474b4:	103ff31e 	bne	r2,zero,4047484 <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
 40474b8:	e0bffb03 	ldbu	r2,-20(fp)
 40474bc:	10801fcc 	andi	r2,r2,127
 40474c0:	1005003a 	cmpeq	r2,r2,zero
 40474c4:	1000021e 	bne	r2,zero,40474d0 <alt_write_word_intel+0xa0>
  {
    ret_code = -EIO;
 40474c8:	00bffec4 	movi	r2,-5
 40474cc:	e0bffc15 	stw	r2,-16(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
 40474d0:	e0bffd17 	ldw	r2,-12(fp)
 40474d4:	11803517 	ldw	r6,212(r2)
 40474d8:	e0bffd17 	ldw	r2,-12(fp)
 40474dc:	10800a17 	ldw	r2,40(r2)
 40474e0:	1007883a 	mov	r3,r2
 40474e4:	e0bffe17 	ldw	r2,-8(fp)
 40474e8:	1889883a 	add	r4,r3,r2
 40474ec:	01403fc4 	movi	r5,255
 40474f0:	303ee83a 	callr	r6
  
  return ret_code;
 40474f4:	e0bffc17 	ldw	r2,-16(fp)
}
 40474f8:	e037883a 	mov	sp,fp
 40474fc:	dfc00117 	ldw	ra,4(sp)
 4047500:	df000017 	ldw	fp,0(sp)
 4047504:	dec00204 	addi	sp,sp,8
 4047508:	f800283a 	ret

0404750c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 404750c:	defff904 	addi	sp,sp,-28
 4047510:	dfc00615 	stw	ra,24(sp)
 4047514:	df000515 	stw	fp,20(sp)
 4047518:	df000504 	addi	fp,sp,20
 404751c:	e13ffd15 	stw	r4,-12(fp)
 4047520:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 4047524:	e0bffe17 	ldw	r2,-8(fp)
 4047528:	10800017 	ldw	r2,0(r2)
 404752c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 4047530:	e13ffd17 	ldw	r4,-12(fp)
 4047534:	404031c0 	call	404031c <strlen>
 4047538:	10800044 	addi	r2,r2,1
 404753c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 4047540:	00000d06 	br	4047578 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 4047544:	e0bffc17 	ldw	r2,-16(fp)
 4047548:	11000217 	ldw	r4,8(r2)
 404754c:	e1bffb17 	ldw	r6,-20(fp)
 4047550:	e17ffd17 	ldw	r5,-12(fp)
 4047554:	40479d00 	call	40479d0 <memcmp>
 4047558:	1004c03a 	cmpne	r2,r2,zero
 404755c:	1000031e 	bne	r2,zero,404756c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 4047560:	e0bffc17 	ldw	r2,-16(fp)
 4047564:	e0bfff15 	stw	r2,-4(fp)
 4047568:	00000706 	br	4047588 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 404756c:	e0bffc17 	ldw	r2,-16(fp)
 4047570:	10800017 	ldw	r2,0(r2)
 4047574:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 4047578:	e0fffe17 	ldw	r3,-8(fp)
 404757c:	e0bffc17 	ldw	r2,-16(fp)
 4047580:	10fff01e 	bne	r2,r3,4047544 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 4047584:	e03fff15 	stw	zero,-4(fp)
 4047588:	e0bfff17 	ldw	r2,-4(fp)
}
 404758c:	e037883a 	mov	sp,fp
 4047590:	dfc00117 	ldw	ra,4(sp)
 4047594:	df000017 	ldw	fp,0(sp)
 4047598:	dec00204 	addi	sp,sp,8
 404759c:	f800283a 	ret

040475a0 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 40475a0:	defffa04 	addi	sp,sp,-24
 40475a4:	dfc00515 	stw	ra,20(sp)
 40475a8:	df000415 	stw	fp,16(sp)
 40475ac:	df000404 	addi	fp,sp,16
 40475b0:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 40475b4:	00810174 	movhi	r2,1029
 40475b8:	10a68b04 	addi	r2,r2,-26068
 40475bc:	10800017 	ldw	r2,0(r2)
 40475c0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 40475c4:	00003306 	br	4047694 <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 40475c8:	e0bffd17 	ldw	r2,-12(fp)
 40475cc:	11000217 	ldw	r4,8(r2)
 40475d0:	404031c0 	call	404031c <strlen>
 40475d4:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 40475d8:	e0bffd17 	ldw	r2,-12(fp)
 40475dc:	10c00217 	ldw	r3,8(r2)
 40475e0:	e0bffc17 	ldw	r2,-16(fp)
 40475e4:	1885883a 	add	r2,r3,r2
 40475e8:	10bfffc4 	addi	r2,r2,-1
 40475ec:	10800003 	ldbu	r2,0(r2)
 40475f0:	10803fcc 	andi	r2,r2,255
 40475f4:	1080201c 	xori	r2,r2,128
 40475f8:	10bfe004 	addi	r2,r2,-128
 40475fc:	10800bd8 	cmpnei	r2,r2,47
 4047600:	1000031e 	bne	r2,zero,4047610 <alt_find_file+0x70>
    {
      len -= 1;
 4047604:	e0bffc17 	ldw	r2,-16(fp)
 4047608:	10bfffc4 	addi	r2,r2,-1
 404760c:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 4047610:	e0bffc17 	ldw	r2,-16(fp)
 4047614:	1007883a 	mov	r3,r2
 4047618:	e0bffe17 	ldw	r2,-8(fp)
 404761c:	1885883a 	add	r2,r3,r2
 4047620:	10800003 	ldbu	r2,0(r2)
 4047624:	10803fcc 	andi	r2,r2,255
 4047628:	1080201c 	xori	r2,r2,128
 404762c:	10bfe004 	addi	r2,r2,-128
 4047630:	10800be0 	cmpeqi	r2,r2,47
 4047634:	10000a1e 	bne	r2,zero,4047660 <alt_find_file+0xc0>
 4047638:	e0bffc17 	ldw	r2,-16(fp)
 404763c:	1007883a 	mov	r3,r2
 4047640:	e0bffe17 	ldw	r2,-8(fp)
 4047644:	1885883a 	add	r2,r3,r2
 4047648:	10800003 	ldbu	r2,0(r2)
 404764c:	10803fcc 	andi	r2,r2,255
 4047650:	1080201c 	xori	r2,r2,128
 4047654:	10bfe004 	addi	r2,r2,-128
 4047658:	1004c03a 	cmpne	r2,r2,zero
 404765c:	10000a1e 	bne	r2,zero,4047688 <alt_find_file+0xe8>
 4047660:	e0bffd17 	ldw	r2,-12(fp)
 4047664:	11000217 	ldw	r4,8(r2)
 4047668:	e1bffc17 	ldw	r6,-16(fp)
 404766c:	e17ffe17 	ldw	r5,-8(fp)
 4047670:	40479d00 	call	40479d0 <memcmp>
 4047674:	1004c03a 	cmpne	r2,r2,zero
 4047678:	1000031e 	bne	r2,zero,4047688 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 404767c:	e0bffd17 	ldw	r2,-12(fp)
 4047680:	e0bfff15 	stw	r2,-4(fp)
 4047684:	00000806 	br	40476a8 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 4047688:	e0bffd17 	ldw	r2,-12(fp)
 404768c:	10800017 	ldw	r2,0(r2)
 4047690:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 4047694:	00c10174 	movhi	r3,1029
 4047698:	18e68b04 	addi	r3,r3,-26068
 404769c:	e0bffd17 	ldw	r2,-12(fp)
 40476a0:	10ffc91e 	bne	r2,r3,40475c8 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 40476a4:	e03fff15 	stw	zero,-4(fp)
 40476a8:	e0bfff17 	ldw	r2,-4(fp)
}
 40476ac:	e037883a 	mov	sp,fp
 40476b0:	dfc00117 	ldw	ra,4(sp)
 40476b4:	df000017 	ldw	fp,0(sp)
 40476b8:	dec00204 	addi	sp,sp,8
 40476bc:	f800283a 	ret

040476c0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 40476c0:	defffc04 	addi	sp,sp,-16
 40476c4:	df000315 	stw	fp,12(sp)
 40476c8:	df000304 	addi	fp,sp,12
 40476cc:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 40476d0:	00bffa04 	movi	r2,-24
 40476d4:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 40476d8:	e03ffe15 	stw	zero,-8(fp)
 40476dc:	00001e06 	br	4047758 <alt_get_fd+0x98>
  {
    if (!alt_fd_list[i].dev)
 40476e0:	e0bffe17 	ldw	r2,-8(fp)
 40476e4:	00c10174 	movhi	r3,1029
 40476e8:	18e1d904 	addi	r3,r3,-30876
 40476ec:	10800324 	muli	r2,r2,12
 40476f0:	10c5883a 	add	r2,r2,r3
 40476f4:	10800017 	ldw	r2,0(r2)
 40476f8:	1004c03a 	cmpne	r2,r2,zero
 40476fc:	1000131e 	bne	r2,zero,404774c <alt_get_fd+0x8c>
    {
      alt_fd_list[i].dev = dev;
 4047700:	e0bffe17 	ldw	r2,-8(fp)
 4047704:	00c10174 	movhi	r3,1029
 4047708:	18e1d904 	addi	r3,r3,-30876
 404770c:	10800324 	muli	r2,r2,12
 4047710:	10c7883a 	add	r3,r2,r3
 4047714:	e0bfff17 	ldw	r2,-4(fp)
 4047718:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 404771c:	00810174 	movhi	r2,1029
 4047720:	10a68f04 	addi	r2,r2,-26052
 4047724:	10c00017 	ldw	r3,0(r2)
 4047728:	e0bffe17 	ldw	r2,-8(fp)
 404772c:	1880040e 	bge	r3,r2,4047740 <alt_get_fd+0x80>
      {
        alt_max_fd = i;
 4047730:	00c10174 	movhi	r3,1029
 4047734:	18e68f04 	addi	r3,r3,-26052
 4047738:	e0bffe17 	ldw	r2,-8(fp)
 404773c:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 4047740:	e0bffe17 	ldw	r2,-8(fp)
 4047744:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
 4047748:	00000606 	br	4047764 <alt_get_fd+0xa4>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 404774c:	e0bffe17 	ldw	r2,-8(fp)
 4047750:	10800044 	addi	r2,r2,1
 4047754:	e0bffe15 	stw	r2,-8(fp)
 4047758:	e0bffe17 	ldw	r2,-8(fp)
 404775c:	10800810 	cmplti	r2,r2,32
 4047760:	103fdf1e 	bne	r2,zero,40476e0 <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 4047764:	e0bffd17 	ldw	r2,-12(fp)
}
 4047768:	e037883a 	mov	sp,fp
 404776c:	df000017 	ldw	fp,0(sp)
 4047770:	dec00104 	addi	sp,sp,4
 4047774:	f800283a 	ret

04047778 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 4047778:	defffb04 	addi	sp,sp,-20
 404777c:	df000415 	stw	fp,16(sp)
 4047780:	df000404 	addi	fp,sp,16
 4047784:	e13ffe15 	stw	r4,-8(fp)
 4047788:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 404778c:	e0bfff17 	ldw	r2,-4(fp)
 4047790:	10840070 	cmpltui	r2,r2,4097
 4047794:	1000021e 	bne	r2,zero,40477a0 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 4047798:	00840004 	movi	r2,4096
 404779c:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 40477a0:	e0fffe17 	ldw	r3,-8(fp)
 40477a4:	e0bfff17 	ldw	r2,-4(fp)
 40477a8:	1885883a 	add	r2,r3,r2
 40477ac:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 40477b0:	e0bffe17 	ldw	r2,-8(fp)
 40477b4:	e0bffd15 	stw	r2,-12(fp)
 40477b8:	00000506 	br	40477d0 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 40477bc:	e0bffd17 	ldw	r2,-12(fp)
 40477c0:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 40477c4:	e0bffd17 	ldw	r2,-12(fp)
 40477c8:	10800804 	addi	r2,r2,32
 40477cc:	e0bffd15 	stw	r2,-12(fp)
 40477d0:	e0fffd17 	ldw	r3,-12(fp)
 40477d4:	e0bffc17 	ldw	r2,-16(fp)
 40477d8:	18bff836 	bltu	r3,r2,40477bc <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 40477dc:	e0bffe17 	ldw	r2,-8(fp)
 40477e0:	108007cc 	andi	r2,r2,31
 40477e4:	1005003a 	cmpeq	r2,r2,zero
 40477e8:	1000021e 	bne	r2,zero,40477f4 <alt_icache_flush+0x7c>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 40477ec:	e0bffd17 	ldw	r2,-12(fp)
 40477f0:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 40477f4:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 40477f8:	e037883a 	mov	sp,fp
 40477fc:	df000017 	ldw	fp,0(sp)
 4047800:	dec00104 	addi	sp,sp,4
 4047804:	f800283a 	ret

04047808 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 4047808:	defffd04 	addi	sp,sp,-12
 404780c:	dfc00215 	stw	ra,8(sp)
 4047810:	df000115 	stw	fp,4(sp)
 4047814:	df000104 	addi	fp,sp,4
 4047818:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 404781c:	e13fff17 	ldw	r4,-4(fp)
 4047820:	40478380 	call	4047838 <alt_busy_sleep>
}
 4047824:	e037883a 	mov	sp,fp
 4047828:	dfc00117 	ldw	ra,4(sp)
 404782c:	df000017 	ldw	fp,0(sp)
 4047830:	dec00204 	addi	sp,sp,8
 4047834:	f800283a 	ret

04047838 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 4047838:	defffa04 	addi	sp,sp,-24
 404783c:	dfc00515 	stw	ra,20(sp)
 4047840:	df000415 	stw	fp,16(sp)
 4047844:	df000404 	addi	fp,sp,16
 4047848:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 404784c:	008000c4 	movi	r2,3
 4047850:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
 4047854:	e0fffc17 	ldw	r3,-16(fp)
 4047858:	008003f4 	movhi	r2,15
 404785c:	10909004 	addi	r2,r2,16960
 4047860:	188b383a 	mul	r5,r3,r2
 4047864:	0100bef4 	movhi	r4,763
 4047868:	213c2004 	addi	r4,r4,-3968
 404786c:	4047e680 	call	4047e68 <__udivsi3>
 4047870:	100b883a 	mov	r5,r2
 4047874:	01200034 	movhi	r4,32768
 4047878:	213fffc4 	addi	r4,r4,-1
 404787c:	4047e680 	call	4047e68 <__udivsi3>
 4047880:	100b883a 	mov	r5,r2
 4047884:	e13fff17 	ldw	r4,-4(fp)
 4047888:	4047e680 	call	4047e68 <__udivsi3>
 404788c:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 4047890:	e0bffd17 	ldw	r2,-12(fp)
 4047894:	1005003a 	cmpeq	r2,r2,zero
 4047898:	1000281e 	bne	r2,zero,404793c <alt_busy_sleep+0x104>
  {
    for(i=0;i<big_loops;i++)
 404789c:	e03ffe15 	stw	zero,-8(fp)
 40478a0:	00001606 	br	40478fc <alt_busy_sleep+0xc4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 40478a4:	00a00034 	movhi	r2,32768
 40478a8:	10bfffc4 	addi	r2,r2,-1
 40478ac:	10bfffc4 	addi	r2,r2,-1
 40478b0:	103ffe1e 	bne	r2,zero,40478ac <alt_busy_sleep+0x74>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 40478b4:	e0fffc17 	ldw	r3,-16(fp)
 40478b8:	008003f4 	movhi	r2,15
 40478bc:	10909004 	addi	r2,r2,16960
 40478c0:	188b383a 	mul	r5,r3,r2
 40478c4:	0100bef4 	movhi	r4,763
 40478c8:	213c2004 	addi	r4,r4,-3968
 40478cc:	4047e680 	call	4047e68 <__udivsi3>
 40478d0:	100b883a 	mov	r5,r2
 40478d4:	01200034 	movhi	r4,32768
 40478d8:	213fffc4 	addi	r4,r4,-1
 40478dc:	4047e680 	call	4047e68 <__udivsi3>
 40478e0:	1007883a 	mov	r3,r2
 40478e4:	e0bfff17 	ldw	r2,-4(fp)
 40478e8:	10c5c83a 	sub	r2,r2,r3
 40478ec:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 40478f0:	e0bffe17 	ldw	r2,-8(fp)
 40478f4:	10800044 	addi	r2,r2,1
 40478f8:	e0bffe15 	stw	r2,-8(fp)
 40478fc:	e0fffe17 	ldw	r3,-8(fp)
 4047900:	e0bffd17 	ldw	r2,-12(fp)
 4047904:	18bfe716 	blt	r3,r2,40478a4 <alt_busy_sleep+0x6c>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 4047908:	e0fffc17 	ldw	r3,-16(fp)
 404790c:	008003f4 	movhi	r2,15
 4047910:	10909004 	addi	r2,r2,16960
 4047914:	188b383a 	mul	r5,r3,r2
 4047918:	0100bef4 	movhi	r4,763
 404791c:	213c2004 	addi	r4,r4,-3968
 4047920:	4047e680 	call	4047e68 <__udivsi3>
 4047924:	1007883a 	mov	r3,r2
 4047928:	e0bfff17 	ldw	r2,-4(fp)
 404792c:	1885383a 	mul	r2,r3,r2
 4047930:	10bfffc4 	addi	r2,r2,-1
 4047934:	103ffe1e 	bne	r2,zero,4047930 <alt_busy_sleep+0xf8>
 4047938:	00000c06 	br	404796c <alt_busy_sleep+0x134>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 404793c:	e0fffc17 	ldw	r3,-16(fp)
 4047940:	008003f4 	movhi	r2,15
 4047944:	10909004 	addi	r2,r2,16960
 4047948:	188b383a 	mul	r5,r3,r2
 404794c:	0100bef4 	movhi	r4,763
 4047950:	213c2004 	addi	r4,r4,-3968
 4047954:	4047e680 	call	4047e68 <__udivsi3>
 4047958:	1007883a 	mov	r3,r2
 404795c:	e0bfff17 	ldw	r2,-4(fp)
 4047960:	1885383a 	mul	r2,r3,r2
 4047964:	10bfffc4 	addi	r2,r2,-1
 4047968:	00bffe16 	blt	zero,r2,4047964 <alt_busy_sleep+0x12c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 404796c:	0005883a 	mov	r2,zero
}
 4047970:	e037883a 	mov	sp,fp
 4047974:	dfc00117 	ldw	ra,4(sp)
 4047978:	df000017 	ldw	fp,0(sp)
 404797c:	dec00204 	addi	sp,sp,8
 4047980:	f800283a 	ret

04047984 <atexit>:
 4047984:	200b883a 	mov	r5,r4
 4047988:	000d883a 	mov	r6,zero
 404798c:	0009883a 	mov	r4,zero
 4047990:	000f883a 	mov	r7,zero
 4047994:	4047a441 	jmpi	4047a44 <__register_exitproc>

04047998 <exit>:
 4047998:	defffe04 	addi	sp,sp,-8
 404799c:	000b883a 	mov	r5,zero
 40479a0:	dc000015 	stw	r16,0(sp)
 40479a4:	dfc00115 	stw	ra,4(sp)
 40479a8:	2021883a 	mov	r16,r4
 40479ac:	4047b7c0 	call	4047b7c <__call_exitprocs>
 40479b0:	00810174 	movhi	r2,1029
 40479b4:	10a68804 	addi	r2,r2,-26080
 40479b8:	11000017 	ldw	r4,0(r2)
 40479bc:	20800f17 	ldw	r2,60(r4)
 40479c0:	10000126 	beq	r2,zero,40479c8 <exit+0x30>
 40479c4:	103ee83a 	callr	r2
 40479c8:	8009883a 	mov	r4,r16
 40479cc:	4047eb80 	call	4047eb8 <_exit>

040479d0 <memcmp>:
 40479d0:	00c000c4 	movi	r3,3
 40479d4:	1980032e 	bgeu	r3,r6,40479e4 <memcmp+0x14>
 40479d8:	2144b03a 	or	r2,r4,r5
 40479dc:	10c4703a 	and	r2,r2,r3
 40479e0:	10000f26 	beq	r2,zero,4047a20 <memcmp+0x50>
 40479e4:	31ffffc4 	addi	r7,r6,-1
 40479e8:	3000061e 	bne	r6,zero,4047a04 <memcmp+0x34>
 40479ec:	00000a06 	br	4047a18 <memcmp+0x48>
 40479f0:	39ffffc4 	addi	r7,r7,-1
 40479f4:	00bfffc4 	movi	r2,-1
 40479f8:	21000044 	addi	r4,r4,1
 40479fc:	29400044 	addi	r5,r5,1
 4047a00:	38800526 	beq	r7,r2,4047a18 <memcmp+0x48>
 4047a04:	20c00003 	ldbu	r3,0(r4)
 4047a08:	28800003 	ldbu	r2,0(r5)
 4047a0c:	18bff826 	beq	r3,r2,40479f0 <memcmp+0x20>
 4047a10:	1885c83a 	sub	r2,r3,r2
 4047a14:	f800283a 	ret
 4047a18:	0005883a 	mov	r2,zero
 4047a1c:	f800283a 	ret
 4047a20:	180f883a 	mov	r7,r3
 4047a24:	20c00017 	ldw	r3,0(r4)
 4047a28:	28800017 	ldw	r2,0(r5)
 4047a2c:	18bfed1e 	bne	r3,r2,40479e4 <memcmp+0x14>
 4047a30:	31bfff04 	addi	r6,r6,-4
 4047a34:	21000104 	addi	r4,r4,4
 4047a38:	29400104 	addi	r5,r5,4
 4047a3c:	39bff936 	bltu	r7,r6,4047a24 <memcmp+0x54>
 4047a40:	003fe806 	br	40479e4 <memcmp+0x14>

04047a44 <__register_exitproc>:
 4047a44:	defffa04 	addi	sp,sp,-24
 4047a48:	00810174 	movhi	r2,1029
 4047a4c:	10a68804 	addi	r2,r2,-26080
 4047a50:	dc000015 	stw	r16,0(sp)
 4047a54:	14000017 	ldw	r16,0(r2)
 4047a58:	dd000415 	stw	r20,16(sp)
 4047a5c:	2829883a 	mov	r20,r5
 4047a60:	81405217 	ldw	r5,328(r16)
 4047a64:	dcc00315 	stw	r19,12(sp)
 4047a68:	dc800215 	stw	r18,8(sp)
 4047a6c:	dc400115 	stw	r17,4(sp)
 4047a70:	dfc00515 	stw	ra,20(sp)
 4047a74:	2023883a 	mov	r17,r4
 4047a78:	3027883a 	mov	r19,r6
 4047a7c:	3825883a 	mov	r18,r7
 4047a80:	28002526 	beq	r5,zero,4047b18 <__register_exitproc+0xd4>
 4047a84:	29000117 	ldw	r4,4(r5)
 4047a88:	008007c4 	movi	r2,31
 4047a8c:	11002716 	blt	r2,r4,4047b2c <__register_exitproc+0xe8>
 4047a90:	8800101e 	bne	r17,zero,4047ad4 <__register_exitproc+0x90>
 4047a94:	2105883a 	add	r2,r4,r4
 4047a98:	1085883a 	add	r2,r2,r2
 4047a9c:	20c00044 	addi	r3,r4,1
 4047aa0:	1145883a 	add	r2,r2,r5
 4047aa4:	0009883a 	mov	r4,zero
 4047aa8:	15000215 	stw	r20,8(r2)
 4047aac:	28c00115 	stw	r3,4(r5)
 4047ab0:	2005883a 	mov	r2,r4
 4047ab4:	dfc00517 	ldw	ra,20(sp)
 4047ab8:	dd000417 	ldw	r20,16(sp)
 4047abc:	dcc00317 	ldw	r19,12(sp)
 4047ac0:	dc800217 	ldw	r18,8(sp)
 4047ac4:	dc400117 	ldw	r17,4(sp)
 4047ac8:	dc000017 	ldw	r16,0(sp)
 4047acc:	dec00604 	addi	sp,sp,24
 4047ad0:	f800283a 	ret
 4047ad4:	29802204 	addi	r6,r5,136
 4047ad8:	00800044 	movi	r2,1
 4047adc:	110e983a 	sll	r7,r2,r4
 4047ae0:	30c04017 	ldw	r3,256(r6)
 4047ae4:	2105883a 	add	r2,r4,r4
 4047ae8:	1085883a 	add	r2,r2,r2
 4047aec:	1185883a 	add	r2,r2,r6
 4047af0:	19c6b03a 	or	r3,r3,r7
 4047af4:	14802015 	stw	r18,128(r2)
 4047af8:	14c00015 	stw	r19,0(r2)
 4047afc:	00800084 	movi	r2,2
 4047b00:	30c04015 	stw	r3,256(r6)
 4047b04:	88bfe31e 	bne	r17,r2,4047a94 <__register_exitproc+0x50>
 4047b08:	30804117 	ldw	r2,260(r6)
 4047b0c:	11c4b03a 	or	r2,r2,r7
 4047b10:	30804115 	stw	r2,260(r6)
 4047b14:	003fdf06 	br	4047a94 <__register_exitproc+0x50>
 4047b18:	00810174 	movhi	r2,1029
 4047b1c:	10adb504 	addi	r2,r2,-18732
 4047b20:	100b883a 	mov	r5,r2
 4047b24:	80805215 	stw	r2,328(r16)
 4047b28:	003fd606 	br	4047a84 <__register_exitproc+0x40>
 4047b2c:	00800034 	movhi	r2,0
 4047b30:	10800004 	addi	r2,r2,0
 4047b34:	1000021e 	bne	r2,zero,4047b40 <__register_exitproc+0xfc>
 4047b38:	013fffc4 	movi	r4,-1
 4047b3c:	003fdc06 	br	4047ab0 <__register_exitproc+0x6c>
 4047b40:	01006404 	movi	r4,400
 4047b44:	103ee83a 	callr	r2
 4047b48:	1007883a 	mov	r3,r2
 4047b4c:	103ffa26 	beq	r2,zero,4047b38 <__register_exitproc+0xf4>
 4047b50:	80805217 	ldw	r2,328(r16)
 4047b54:	180b883a 	mov	r5,r3
 4047b58:	18000115 	stw	zero,4(r3)
 4047b5c:	18800015 	stw	r2,0(r3)
 4047b60:	80c05215 	stw	r3,328(r16)
 4047b64:	18006215 	stw	zero,392(r3)
 4047b68:	18006315 	stw	zero,396(r3)
 4047b6c:	0009883a 	mov	r4,zero
 4047b70:	883fc826 	beq	r17,zero,4047a94 <__register_exitproc+0x50>
 4047b74:	003fd706 	br	4047ad4 <__register_exitproc+0x90>

04047b78 <register_fini>:
 4047b78:	f800283a 	ret

04047b7c <__call_exitprocs>:
 4047b7c:	00810174 	movhi	r2,1029
 4047b80:	10a68804 	addi	r2,r2,-26080
 4047b84:	10800017 	ldw	r2,0(r2)
 4047b88:	defff304 	addi	sp,sp,-52
 4047b8c:	df000b15 	stw	fp,44(sp)
 4047b90:	d8800115 	stw	r2,4(sp)
 4047b94:	00800034 	movhi	r2,0
 4047b98:	10800004 	addi	r2,r2,0
 4047b9c:	1005003a 	cmpeq	r2,r2,zero
 4047ba0:	d8800215 	stw	r2,8(sp)
 4047ba4:	d8800117 	ldw	r2,4(sp)
 4047ba8:	dd400815 	stw	r21,32(sp)
 4047bac:	dd000715 	stw	r20,28(sp)
 4047bb0:	10805204 	addi	r2,r2,328
 4047bb4:	dfc00c15 	stw	ra,48(sp)
 4047bb8:	ddc00a15 	stw	r23,40(sp)
 4047bbc:	dd800915 	stw	r22,36(sp)
 4047bc0:	dcc00615 	stw	r19,24(sp)
 4047bc4:	dc800515 	stw	r18,20(sp)
 4047bc8:	dc400415 	stw	r17,16(sp)
 4047bcc:	dc000315 	stw	r16,12(sp)
 4047bd0:	282b883a 	mov	r21,r5
 4047bd4:	2039883a 	mov	fp,r4
 4047bd8:	d8800015 	stw	r2,0(sp)
 4047bdc:	2829003a 	cmpeq	r20,r5,zero
 4047be0:	d8800117 	ldw	r2,4(sp)
 4047be4:	14405217 	ldw	r17,328(r2)
 4047be8:	88001026 	beq	r17,zero,4047c2c <__call_exitprocs+0xb0>
 4047bec:	ddc00017 	ldw	r23,0(sp)
 4047bf0:	88800117 	ldw	r2,4(r17)
 4047bf4:	8c802204 	addi	r18,r17,136
 4047bf8:	143fffc4 	addi	r16,r2,-1
 4047bfc:	80000916 	blt	r16,zero,4047c24 <__call_exitprocs+0xa8>
 4047c00:	05bfffc4 	movi	r22,-1
 4047c04:	a000151e 	bne	r20,zero,4047c5c <__call_exitprocs+0xe0>
 4047c08:	8409883a 	add	r4,r16,r16
 4047c0c:	2105883a 	add	r2,r4,r4
 4047c10:	1485883a 	add	r2,r2,r18
 4047c14:	10c02017 	ldw	r3,128(r2)
 4047c18:	a8c01126 	beq	r21,r3,4047c60 <__call_exitprocs+0xe4>
 4047c1c:	843fffc4 	addi	r16,r16,-1
 4047c20:	85bff81e 	bne	r16,r22,4047c04 <__call_exitprocs+0x88>
 4047c24:	d8800217 	ldw	r2,8(sp)
 4047c28:	10003126 	beq	r2,zero,4047cf0 <__call_exitprocs+0x174>
 4047c2c:	dfc00c17 	ldw	ra,48(sp)
 4047c30:	df000b17 	ldw	fp,44(sp)
 4047c34:	ddc00a17 	ldw	r23,40(sp)
 4047c38:	dd800917 	ldw	r22,36(sp)
 4047c3c:	dd400817 	ldw	r21,32(sp)
 4047c40:	dd000717 	ldw	r20,28(sp)
 4047c44:	dcc00617 	ldw	r19,24(sp)
 4047c48:	dc800517 	ldw	r18,20(sp)
 4047c4c:	dc400417 	ldw	r17,16(sp)
 4047c50:	dc000317 	ldw	r16,12(sp)
 4047c54:	dec00d04 	addi	sp,sp,52
 4047c58:	f800283a 	ret
 4047c5c:	8409883a 	add	r4,r16,r16
 4047c60:	88c00117 	ldw	r3,4(r17)
 4047c64:	2105883a 	add	r2,r4,r4
 4047c68:	1445883a 	add	r2,r2,r17
 4047c6c:	18ffffc4 	addi	r3,r3,-1
 4047c70:	11800217 	ldw	r6,8(r2)
 4047c74:	1c001526 	beq	r3,r16,4047ccc <__call_exitprocs+0x150>
 4047c78:	10000215 	stw	zero,8(r2)
 4047c7c:	303fe726 	beq	r6,zero,4047c1c <__call_exitprocs+0xa0>
 4047c80:	00c00044 	movi	r3,1
 4047c84:	1c06983a 	sll	r3,r3,r16
 4047c88:	90804017 	ldw	r2,256(r18)
 4047c8c:	8cc00117 	ldw	r19,4(r17)
 4047c90:	1884703a 	and	r2,r3,r2
 4047c94:	10001426 	beq	r2,zero,4047ce8 <__call_exitprocs+0x16c>
 4047c98:	90804117 	ldw	r2,260(r18)
 4047c9c:	1884703a 	and	r2,r3,r2
 4047ca0:	10000c1e 	bne	r2,zero,4047cd4 <__call_exitprocs+0x158>
 4047ca4:	2105883a 	add	r2,r4,r4
 4047ca8:	1485883a 	add	r2,r2,r18
 4047cac:	11400017 	ldw	r5,0(r2)
 4047cb0:	e009883a 	mov	r4,fp
 4047cb4:	303ee83a 	callr	r6
 4047cb8:	88800117 	ldw	r2,4(r17)
 4047cbc:	98bfc81e 	bne	r19,r2,4047be0 <__call_exitprocs+0x64>
 4047cc0:	b8800017 	ldw	r2,0(r23)
 4047cc4:	147fd526 	beq	r2,r17,4047c1c <__call_exitprocs+0xa0>
 4047cc8:	003fc506 	br	4047be0 <__call_exitprocs+0x64>
 4047ccc:	8c000115 	stw	r16,4(r17)
 4047cd0:	003fea06 	br	4047c7c <__call_exitprocs+0x100>
 4047cd4:	2105883a 	add	r2,r4,r4
 4047cd8:	1485883a 	add	r2,r2,r18
 4047cdc:	11000017 	ldw	r4,0(r2)
 4047ce0:	303ee83a 	callr	r6
 4047ce4:	003ff406 	br	4047cb8 <__call_exitprocs+0x13c>
 4047ce8:	303ee83a 	callr	r6
 4047cec:	003ff206 	br	4047cb8 <__call_exitprocs+0x13c>
 4047cf0:	88800117 	ldw	r2,4(r17)
 4047cf4:	1000081e 	bne	r2,zero,4047d18 <__call_exitprocs+0x19c>
 4047cf8:	89000017 	ldw	r4,0(r17)
 4047cfc:	20000726 	beq	r4,zero,4047d1c <__call_exitprocs+0x1a0>
 4047d00:	b9000015 	stw	r4,0(r23)
 4047d04:	8809883a 	mov	r4,r17
 4047d08:	00000000 	call	0 <__reset>
 4047d0c:	bc400017 	ldw	r17,0(r23)
 4047d10:	883fb71e 	bne	r17,zero,4047bf0 <__call_exitprocs+0x74>
 4047d14:	003fc506 	br	4047c2c <__call_exitprocs+0xb0>
 4047d18:	89000017 	ldw	r4,0(r17)
 4047d1c:	882f883a 	mov	r23,r17
 4047d20:	2023883a 	mov	r17,r4
 4047d24:	883fb21e 	bne	r17,zero,4047bf0 <__call_exitprocs+0x74>
 4047d28:	003fc006 	br	4047c2c <__call_exitprocs+0xb0>

04047d2c <udivmodsi4>:
 4047d2c:	29001b2e 	bgeu	r5,r4,4047d9c <udivmodsi4+0x70>
 4047d30:	28001a16 	blt	r5,zero,4047d9c <udivmodsi4+0x70>
 4047d34:	00800044 	movi	r2,1
 4047d38:	0007883a 	mov	r3,zero
 4047d3c:	01c007c4 	movi	r7,31
 4047d40:	00000306 	br	4047d50 <udivmodsi4+0x24>
 4047d44:	19c01326 	beq	r3,r7,4047d94 <udivmodsi4+0x68>
 4047d48:	18c00044 	addi	r3,r3,1
 4047d4c:	28000416 	blt	r5,zero,4047d60 <udivmodsi4+0x34>
 4047d50:	294b883a 	add	r5,r5,r5
 4047d54:	1085883a 	add	r2,r2,r2
 4047d58:	293ffa36 	bltu	r5,r4,4047d44 <udivmodsi4+0x18>
 4047d5c:	10000d26 	beq	r2,zero,4047d94 <udivmodsi4+0x68>
 4047d60:	0007883a 	mov	r3,zero
 4047d64:	21400236 	bltu	r4,r5,4047d70 <udivmodsi4+0x44>
 4047d68:	2149c83a 	sub	r4,r4,r5
 4047d6c:	1886b03a 	or	r3,r3,r2
 4047d70:	1004d07a 	srli	r2,r2,1
 4047d74:	280ad07a 	srli	r5,r5,1
 4047d78:	103ffa1e 	bne	r2,zero,4047d64 <udivmodsi4+0x38>
 4047d7c:	30000226 	beq	r6,zero,4047d88 <udivmodsi4+0x5c>
 4047d80:	2005883a 	mov	r2,r4
 4047d84:	f800283a 	ret
 4047d88:	1809883a 	mov	r4,r3
 4047d8c:	2005883a 	mov	r2,r4
 4047d90:	f800283a 	ret
 4047d94:	0007883a 	mov	r3,zero
 4047d98:	003ff806 	br	4047d7c <udivmodsi4+0x50>
 4047d9c:	00800044 	movi	r2,1
 4047da0:	0007883a 	mov	r3,zero
 4047da4:	003fef06 	br	4047d64 <udivmodsi4+0x38>

04047da8 <__divsi3>:
 4047da8:	defffe04 	addi	sp,sp,-8
 4047dac:	dc000015 	stw	r16,0(sp)
 4047db0:	dfc00115 	stw	ra,4(sp)
 4047db4:	0021883a 	mov	r16,zero
 4047db8:	20000c16 	blt	r4,zero,4047dec <__divsi3+0x44>
 4047dbc:	000d883a 	mov	r6,zero
 4047dc0:	28000e16 	blt	r5,zero,4047dfc <__divsi3+0x54>
 4047dc4:	4047d2c0 	call	4047d2c <udivmodsi4>
 4047dc8:	1007883a 	mov	r3,r2
 4047dcc:	8005003a 	cmpeq	r2,r16,zero
 4047dd0:	1000011e 	bne	r2,zero,4047dd8 <__divsi3+0x30>
 4047dd4:	00c7c83a 	sub	r3,zero,r3
 4047dd8:	1805883a 	mov	r2,r3
 4047ddc:	dfc00117 	ldw	ra,4(sp)
 4047de0:	dc000017 	ldw	r16,0(sp)
 4047de4:	dec00204 	addi	sp,sp,8
 4047de8:	f800283a 	ret
 4047dec:	0109c83a 	sub	r4,zero,r4
 4047df0:	04000044 	movi	r16,1
 4047df4:	000d883a 	mov	r6,zero
 4047df8:	283ff20e 	bge	r5,zero,4047dc4 <__divsi3+0x1c>
 4047dfc:	014bc83a 	sub	r5,zero,r5
 4047e00:	8021003a 	cmpeq	r16,r16,zero
 4047e04:	003fef06 	br	4047dc4 <__divsi3+0x1c>

04047e08 <__modsi3>:
 4047e08:	deffff04 	addi	sp,sp,-4
 4047e0c:	dfc00015 	stw	ra,0(sp)
 4047e10:	01800044 	movi	r6,1
 4047e14:	2807883a 	mov	r3,r5
 4047e18:	20000416 	blt	r4,zero,4047e2c <__modsi3+0x24>
 4047e1c:	28000c16 	blt	r5,zero,4047e50 <__modsi3+0x48>
 4047e20:	dfc00017 	ldw	ra,0(sp)
 4047e24:	dec00104 	addi	sp,sp,4
 4047e28:	4047d2c1 	jmpi	4047d2c <udivmodsi4>
 4047e2c:	0109c83a 	sub	r4,zero,r4
 4047e30:	28000b16 	blt	r5,zero,4047e60 <__modsi3+0x58>
 4047e34:	180b883a 	mov	r5,r3
 4047e38:	01800044 	movi	r6,1
 4047e3c:	4047d2c0 	call	4047d2c <udivmodsi4>
 4047e40:	0085c83a 	sub	r2,zero,r2
 4047e44:	dfc00017 	ldw	ra,0(sp)
 4047e48:	dec00104 	addi	sp,sp,4
 4047e4c:	f800283a 	ret
 4047e50:	014bc83a 	sub	r5,zero,r5
 4047e54:	dfc00017 	ldw	ra,0(sp)
 4047e58:	dec00104 	addi	sp,sp,4
 4047e5c:	4047d2c1 	jmpi	4047d2c <udivmodsi4>
 4047e60:	0147c83a 	sub	r3,zero,r5
 4047e64:	003ff306 	br	4047e34 <__modsi3+0x2c>

04047e68 <__udivsi3>:
 4047e68:	000d883a 	mov	r6,zero
 4047e6c:	4047d2c1 	jmpi	4047d2c <udivmodsi4>

04047e70 <__umodsi3>:
 4047e70:	01800044 	movi	r6,1
 4047e74:	4047d2c1 	jmpi	4047d2c <udivmodsi4>

04047e78 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
 4047e78:	defffd04 	addi	sp,sp,-12
 4047e7c:	df000215 	stw	fp,8(sp)
 4047e80:	df000204 	addi	fp,sp,8
 4047e84:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
 4047e88:	e0bfff17 	ldw	r2,-4(fp)
 4047e8c:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 4047e90:	e0bffe17 	ldw	r2,-8(fp)
 4047e94:	1005003a 	cmpeq	r2,r2,zero
 4047e98:	1000021e 	bne	r2,zero,4047ea4 <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
 4047e9c:	002af070 	cmpltui	zero,zero,43969
 4047ea0:	00000106 	br	4047ea8 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
 4047ea4:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
 4047ea8:	e037883a 	mov	sp,fp
 4047eac:	df000017 	ldw	fp,0(sp)
 4047eb0:	dec00104 	addi	sp,sp,4
 4047eb4:	f800283a 	ret

04047eb8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 4047eb8:	defffd04 	addi	sp,sp,-12
 4047ebc:	dfc00215 	stw	ra,8(sp)
 4047ec0:	df000115 	stw	fp,4(sp)
 4047ec4:	df000104 	addi	fp,sp,4
 4047ec8:	e13fff15 	stw	r4,-4(fp)
  ALT_OS_STOP();

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
 4047ecc:	e13fff17 	ldw	r4,-4(fp)
 4047ed0:	4047e780 	call	4047e78 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 4047ed4:	003fff06 	br	4047ed4 <_exit+0x1c>
 4047ed8:	04047b78 	rdprs	r16,zero,4589
